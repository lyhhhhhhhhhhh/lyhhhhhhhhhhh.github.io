<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Internet |  🍋航爱coding
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="🍋航爱coding" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-Internet" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Internet
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/03/Internet/" class="article-date">
  <time datetime="2020-03-03T15:14:36.000Z" itemprop="datePublished">2020-03-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/cs/">cs</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.5k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">26分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>internet for my lovely offer.</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分组交换电路交换：<br>分组交换更加高效，利用率更高，利用了储存转发的思想。</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" alt="pic"></p>
<p>注意传输时延与传播时延：</p>
<ul>
<li>传输时延是主机或者路由器传输数据帧需要的时延</li>
<li>传播时延是数据在线路上传播需要的时延。</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="pic"></p>
<p>五层协议体系：</p>
<ul>
<li>应用层：HTTP、DNS、SMTP协议等</li>
<li>运输层：为<strong>进程提供通用的数据传输服务</strong>–TCP/UDP<ul>
<li>可靠性传输：TCP<ul>
<li>三次握手，四次挥手</li>
<li>数据单位为报文段</li>
<li>按字节确认</li>
</ul>
</li>
<li>用户数据报协议：<ul>
<li>不可靠、无链接</li>
</ul>
</li>
</ul>
</li>
<li>网络层：为主机提供数据传输服务 IP</li>
<li>链路层：针对的依旧是是主机间的传输服务 </li>
</ul>
<p>OSI体系：<br>在应用层和运输层之间添加了表示层和会话层</p>
<ul>
<li>表示层：处理数据，使得应用程序不需要关心在各台主机中数据内部格式问题。</li>
<li>会话层：建立及管理会话</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>这是一个分布式的数据库，提供主机名和服务器IP的转换服务。DNS是具有层次的。</p>
<p>DNS一般只使用UDP传输，端口号为53</p>
<p>只有在返回的响应超过512字节（UDP最大传输容量）或者进行区域传送（主服务器向辅助域名服务器传送变化的部分）使用TCP</p>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>文件传送协议，需要两个连接来传送一个文件：</p>
<ol>
<li>控制连接：打开端口号21等待客户端连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ol>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"/> </div><br>

<h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ul>
<li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：<strong>IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。</strong>该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关（第一跳路由器）。</p>
</li>
</ul>
<h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ul>
<li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li><p><strong>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</strong></p>
</li>
<li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
</li>
<li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ul>
<li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ul>
<li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>网络层只负责将数据传递给主机，而真正通信的应该是主机中的进程。传输层提供了进程之间的逻辑通信，实现多路复用与多路分解。</p>
<p>端口————用于标记应用层进程或者是线程（16bit）</p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><ul>
<li><p>序号：对于字节流进行编号，表示传输数据的第一个字节的序号</p>
</li>
<li><p><strong>确认号</strong>：希望收到的下一段报文的序号（TCP是累计确认）</p>
</li>
<li><p><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li><p><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li><p><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li><p><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h3 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h3><ul>
<li>三次握手</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="pic"></p>
<ol>
<li>首先B处于监听状态，等待客户的连接请求。</li>
<li>A向B发送连接请求报文，SYN=1，ACK=0，选择一个初始序号x</li>
<li>B收到连接请求报文，如果统一建立连接则发送确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A收到B的连接确认之后，还要向B发出确认，确认号为y+1，序号为x+1</li>
<li>B收到A确认后连接建立</li>
</ol>
<p>三次握手的原因：<br>防止失效连接请求到达服务器，错误开启连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<ul>
<li>四次挥手</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="pic"></p>
<ol>
<li>A发送连接释放报文，FIN=1</li>
<li>B收到后发出确认，此时TCP为半关闭状态，B能向A发送数据但是A不能向B发送。</li>
<li>B不再需要连接时，发送连接释放报文。</li>
<li>A收到后进入TIME-WAIT状态，等待两个最大报文存活时间后释放连接</li>
<li>B收到A的确认请求后释放连接。</li>
</ol>
<p>四次挥手的原因：</p>
<p>客户端发送FIN连接释放报文之后，服务器收到了这个报文，进入CLOSE-WAIT状态等待报文传输结束后发送释放连接报文。</p>
<p>四次挥手的原因还有一个就是TCP是全双工，因此需要两边都关闭。</p>
<p><strong>TIME-WAIT</strong><br>客户端收到FIN报文后进入此状态，并不直接close，因为：</p>
<ol>
<li>确保最后一个报文能到达，如果A的释放确认报文没有到达的话，B超时之后会重新发送释放请求报文，A等待就是为了处理这个。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ol>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>慢开始、拥塞避免、快速重传、快速恢复</p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>最开始cwnd为1，慢开始阶段没收到一个ACK，cwnd++，因此发送方能发送的报文数量为2，4，6，8.。。。</p>
<p>当cwnd达到之前设置好的ssthresh时，进入拥塞避免阶段，cwnd线性增长。</p>
<p>如果超时则，ssthresh=cwnd/2，重新慢开始</p>
<h4 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h4><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时<strong>直接进入拥塞避免</strong>。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层是整个互联网的核心，因此应当让网络层尽可能简单，使用IP协议可以把异构的物理网络连接起来，是的网络成看起来像是一个统一的网络。</p>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="ip"></p>
<ul>
<li><p><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p>
</li>
<li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。<strong>片偏移的单位为 8 字节。</strong></p>
</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt="pic"></p>
<h3 id="IP地址编码"><a href="#IP地址编码" class="headerlink" title="IP地址编码"></a>IP地址编码</h3><ol>
<li>分类：网络号+主机号，不公的分类具有不同的固定的网络号长度</li>
<li>子网划分：网络号中划分一部分作为子网，IP地址变为三级，使用时需要子网掩码</li>
<li>无分类（网络前缀）：CIDR =&gt; 路由聚合<br>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。<br>路由表中项目由“网络前缀”和“下一跳地址”组成，遵循最长前缀匹配原则。</li>
</ol>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p>网络层实现主机之间的通信，而链路层负责每段具体链路的通信。因此在实际传输过程中，IP数据报的源地址和目的地址始终不变，MAC地址一直在改变。</p>
<p>而ARP协议可以通过IP地址得到MAC地址。</p>
<h3 id="虚拟专用网络"><a href="#虚拟专用网络" class="headerlink" title="虚拟专用网络"></a>虚拟专用网络</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>开放最短路径优先算法，洪泛式交换节点的信息，快速收敛，通过Dijkstra算法计算最短路径。</p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
</ul>
</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器</p>
<h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" alt="pic"></p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" alt="pic"></p>
<h2 id="HTTP-TCP-UDP"><a href="#HTTP-TCP-UDP" class="headerlink" title="HTTP/TCP/UDP"></a>HTTP/TCP/UDP</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">http参考文章</a></p>
<p>http是一个客户端终端和服务器端请求和应答的标准。</p>
<p>http协议中并未指定必须使用的层。http实际可以运行在任何协议上，只不过其假定下层协议提供可靠的传输，因此，任何提供这种保证的下层协议都可以被使用。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>协议定义了客户端如何从服务器请求web页面，以及服务器如何将web页面返回客户端。</p>
<p>http协议使用了请求/响应模型：<br>客户端向服务器端发送一个请求报文，其中包括<strong>请求的方法、URL、协议版本以及请求头部和请求数据</strong>。服务器则以一个状态行作为响应，内容包括协议版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>在浏览器键入一个url，会经历一下流程：</p>
<ol>
<li>dns解析url域名中对应的ip地址</li>
<li>解析出ip地址之后，根据ip和默认端口号80，和服务器建立tcp连接。</li>
<li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li>
<li>服务器根据请求内容作出响应，返回相应报文</li>
<li>根据连接类型断开连接或者维持一段时间。</li>
<li>浏览器页面渲染。</li>
</ol>
<p>http是一种无状态的协议，也就是说其自身不对请求/响应之间的通讯状态进行保存。也就是说，在协议级别，不对之前的请求和响应做保存。</p>
<p>cookie技术是解决这个问题的方式。</p>
<h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><p>http/1.1中一共有8种方法：</p>
<ol>
<li><p>GET<br>向指定资源发起请求。该方法应只用在读取数据，而不应当用在产生副作用的操作中。原因是get可以被爬虫随意访问。</p>
</li>
<li><p>HEAD<br>同get类似，是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。</p>
</li>
<li><p>POST<br>向指定资源提交数据，请求服务器进行处理。数据被放在请求体中，可能会创建资源或者修改资源。</p>
</li>
<li><p>PUT<br>向指定位置上传其最新内容。</p>
</li>
<li><p>DELETE<br>请求服务器删除标识资源。</p>
</li>
<li><p>TRACE<br>回显服务器收到的请求，用于调试</p>
</li>
<li><p>OPTIONS<br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
<li><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p>
</li>
</ol>
<p>⚠️注意事项：</p>
<ol>
<li><p>方法名区分大小写。<br>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p>
</li>
<li><p>服务器至少应当实现GET或者HEAD方法，其他方法都是可选的。</p>
</li>
</ol>
<h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><p>所有的http响应第一行都是状态码，依次是http版本号、三位状态码、以及描述状态的短语由空格分隔。</p>
<table>
<thead>
<tr>
<th>开头</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3</td>
<td>重定向状态码</td>
<td>需要附加请求以完成操作</td>
</tr>
<tr>
<td>4</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><p>超文本传输协议的统一资源定位符将从因特网获取信息的<strong>五个基本元素</strong>包括在一个简单的地址中：</p>
<ul>
<li>传送协议</li>
<li>层级URL标记符号（为//，固定不变）</li>
<li>访问资源的凭证信息（可以省略）</li>
<li>服务器（通常为域名，也可以为ip地址）</li>
<li>端口号（数字方式表示，如果为默认值可以省略）</li>
<li>路径（以/划分每一层目录名称）</li>
<li>查询（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）</li>
<li>片段（以#为起点，前段路由hash模式）</li>
</ul>
<h4 id="http请求-响应格式"><a href="#http请求-响应格式" class="headerlink" title="http请求/响应格式"></a>http请求/响应格式</h4><p><img src="https://i.loli.net/2020/03/06/RiWD5GPCMzmvyo2.jpg" alt="Jietu20200306-153746@2x"></p>
<p><img src="https://i.loli.net/2020/03/06/OZrnNMlbTEHtm92.jpg" alt="Jietu20200306-153814@2x"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP收到数据后需要发送一个确认，但是不是立即发送的，需要等待几分之一秒。</p>
<p>TCP保持<strong>首部和数据</strong>的检验和，这个检验和是端到端的，如果有变化则丢弃不要。</p>
<p>TCP用序号来标识发送的字节流，其中序号标识发送的报文段中的第一个数据字节，序号是32位无符号整数，当到末尾后从0重新开始。</p>
<p>当建立一个新连接时，SYN标志为1。序号字段包含由这个主机选择的该链接的初始序号ISN。该主机要发送数据的第一个字节序号为这个序号加1，因为SYN标志占了一个序号。</p>
<p>确认序号包含发送确认一端所期望的下一个序号。因此确认序号是上次已经接收到的数据字节序号加1.只有ACK标志为1的时候确认才有效。</p>
<p>TCP为应用层提供全双工的链接，这意味着数据能在两个放心啊个上独立的传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p>
<p>TCP缺少选择确认或者选择否认，它只能累计确认。</p>
<p>TCP的流量控制由窗口来提供。窗口大小为字节数，窗口大小是一个16bit的字段。</p>
<p>TCP中还有一个比较常见的字段MSS，指的是可以传输块的最大大小。其实际上是与物理线路有关的。<br>其只能出现在SYN报文中。</p>
<p><img src="https://i.loli.net/2020/03/07/oNTuXQpfhawsFe4.jpg" alt="Jietu20200307-145330@2x"></p>
<h3 id="TCP的连接与终止"><a href="#TCP的连接与终止" class="headerlink" title="TCP的连接与终止"></a>TCP的连接与终止</h3><p><img src="https://i.loli.net/2020/03/07/TX9eD8ZK4fB5PrO.jpg" alt="Jietu20200307-145852@2x"></p>
<p>当一端为了建立连接而发送SYN时，需要为连接选择一个初始的序号，ISN是随时间改变的，因此每个连接都有不同的ISN。这样选择序号的目的在于防止在网络中被延迟的分组以后又被重传，而导致某个连接的一方对其错误解释。</p>
<p>建立一个连接需要三次握手，而终止需要四次挥手。这是因为TCP的半关闭，既然一个TCP连接是全双工，那么每个方向就必须单独关闭。</p>
<blockquote>
<p>半关闭是指TCP一端关闭了数据的发送之后还可以从另一端接收数据。</p>
</blockquote>
<p>BSD版中的TCP采用一种500ms的定时器，用于确定终止和连接中的所有超时。</p>
<p>当TCP的一端接收到FIN报文的时候，会给上层的应用一个文件结束符表明数据接收到头了。</p>
<p><img src="https://i.loli.net/2020/03/07/r3SiqIEkP7KUpTB.jpg" alt="Jietu20200307-151433@2x"></p>
<p><img src="https://i.loli.net/2020/03/07/bV52f3jPK7NmgcI.jpg" alt="Jietu20200307-151722@2x"></p>
<h4 id="2MSL的等待状态"><a href="#2MSL的等待状态" class="headerlink" title="2MSL的等待状态"></a>2MSL的等待状态</h4><p>MSL：最大报文生存时间，TCP实现选择的，可以是30s、1min、2min</p>
<p>这样可以防止最后一个ack丢失，等待另一段超时重发最后的FIN</p>
<p>这段时间内不能使用这个socket。</p>
<p>这段时间内任何迟到的报文将被丢弃。</p>
<p>存在一个问题，服务器主动关闭一个连接之后在2MSL的时间间隔内不能使用这个端口。</p>
<h3 id="复位报文段（RST-1）"><a href="#复位报文段（RST-1）" class="headerlink" title="复位报文段（RST=1）"></a>复位报文段（RST=1）</h3><p>产生复位的原因是连接请求到达时，目的端口没有在听。</p>
<p>也可以通过复位来进行异常释放。</p>
<p>当一方由于掉电等原因意外断开之后，接收到报文会以复位回应。</p>
<h3 id="同时打开-关闭"><a href="#同时打开-关闭" class="headerlink" title="同时打开/关闭"></a>同时打开/关闭</h3><p><img src="https://i.loli.net/2020/03/07/adC6cMlqKDoxUNe.jpg" alt="Jietu20200307-153946@2x"></p>
<p><img src="https://i.loli.net/2020/03/07/Dot3ATvkVj2RmS9.jpg" alt="Jietu20200307-154112@2x"></p>
<h3 id="超时与重传"><a href="#超时与重传" class="headerlink" title="超时与重传"></a>超时与重传</h3><p>TCP为每个连接维持4个不同的定时器：</p>
<ol>
<li>重传定时器使用于希望收到另一端的确认</li>
<li>persist定时器使窗口大小信息不断流动</li>
<li>keepalive检测一个空闲连接何时崩溃或重启</li>
<li>2MSL定时器</li>
</ol>
<p>RTT估测；</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        shell
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://lyhhhhhhhhhhh.github.io/2020/03/03/Internet/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/internet/" rel="tag">internet</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/03/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%89%AB%E7%9B%B2/" class="article-nav-link">
        <strong class="article-nav-caption"><<</strong>
        <div class="article-nav-title">
          
            消息队列扫盲
          
        </div>
      </a>
    
    
      <a href="/2020/03/03/operating-system/" class="article-nav-link">
        <strong class="article-nav-caption">>></strong>
        <div class="article-nav-title">operating system</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'UJJrvaXXm06Um0bqrqXMa1gO-gzGzoHsz',
        app_key: 'g2NktDxnwWHiG84di6iVBq80',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'retro',
        placeholder: '有什么想说的嘛？',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        lyhhhhh
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="🍋航爱coding"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['热爱生活，热爱自我','宠辱不惊，不卑不亢','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>