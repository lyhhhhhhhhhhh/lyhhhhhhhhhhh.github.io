<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🍋航爱coding</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lyhhhhhhhhhhh.github.io/"/>
  <updated>2020-02-25T03:21:09.502Z</updated>
  <id>http://lyhhhhhhhhhhh.github.io/</id>
  
  <author>
    <name>lyhhhhh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go标准库contains/List使用</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/25/go%E6%A0%87%E5%87%86%E5%BA%93contains-List%E4%BD%BF%E7%94%A8/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/25/go%E6%A0%87%E5%87%86%E5%BA%93contains-List%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-25T03:03:18.000Z</published>
    <updated>2020-02-25T03:21:09.502Z</updated>
    
    <content type="html"><![CDATA[<p>这几天刷leetcode算法题树的部分的时候频繁的需要用到队列和栈，一开始我想拿slice实现，后面看了别人的题解中有用到list这个标准库，提供了一个双向的链表感觉很方便，就拿来一用</p><p>不过因为其使用interface{}类型来实现泛型，所以使用起来有一些需要注意的地方，所以用这片博客记录一下。</p><p>官方文档：<a href="https://go-zh.org/pkg/container/list/" target="_blank" rel="noopener">list文档</a></p><a id="more"></a><p>首先list中储存了一个Element类型的变量，其定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The value stored with this element.</span></span><br><span class="line">    Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用了接口类型定义Value，这样以来Element就可以实现存储任何值。</p><p>list的操作其实不难，定义在其中的方法看名字就能看出来是啥，使用的一个简单示例如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a new list and put some numbers in it.</span></span><br><span class="line">l := list.New()</span><br><span class="line">e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line">e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line">l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line">l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="interface-类型断言"><a href="#interface-类型断言" class="headerlink" title="interface{}类型断言"></a>interface{}类型断言</h2><p>值得注意的只有一点，就是iterface在进行类型转换的时候是需要使用类型断言的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    stack := list.New()</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack.PushBack(root)</span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cur  := stack.Back()</span><br><span class="line">        curValue, _ := cur.Value.(*TreeNode)</span><br><span class="line">        stack.Remove(cur)</span><br><span class="line">        <span class="keyword">if</span> curValue != <span class="literal">nil</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, curValue.Val)</span><br><span class="line">            stack.PushBack(curValue.Right)</span><br><span class="line">            stack.PushBack(curValue.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如刚刚做完的那道前序遍历的题，其中<code>curValue, _ := cur.Value.(*TreeNode)</code>就是一句类型断言。</p><p>类型断言是访问接口类型底层值的唯一方法，可以通过断言来在运行时检查interface中是否含有某种类型。上述的方法其实不够规范，因为忽略了后面返回的那个值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天刷leetcode算法题树的部分的时候频繁的需要用到队列和栈，一开始我想拿slice实现，后面看了别人的题解中有用到list这个标准库，提供了一个双向的链表感觉很方便，就拿来一用&lt;/p&gt;
&lt;p&gt;不过因为其使用interface{}类型来实现泛型，所以使用起来有一些需要注意的地方，所以用这片博客记录一下。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://go-zh.org/pkg/container/list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;list文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="golang" scheme="http://lyhhhhhhhhhhh.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ECS设置grub默认kernel</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/22/ECS%E8%AE%BE%E7%BD%AEgrub%E9%BB%98%E8%AE%A4kernel/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/22/ECS%E8%AE%BE%E7%BD%AEgrub%E9%BB%98%E8%AE%A4kernel/</id>
    <published>2020-02-22T07:49:49.000Z</published>
    <updated>2020-02-22T07:57:19.361Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统课设要编译内核，因为不想使用mac跑虚拟机所以选择租了阿里云一个ECS来进行。之前的步骤都进行的很愉快，直到我不管怎样设置grub都不能使用我新编译的那个内核。</p><p>设置默认内核的方法有这些：</p><ol><li><p>/etc/default/grub 修改这个文件。参考<a href="https://help.aliyun.com/knowledge_detail/58187.html?spm=5176.13910061.0.0.7241523fvOwstK&aly_as=tZCH4b4a" target="_blank" rel="noopener">阿里云手册</a></p></li><li><p>使用这个命令 <code>sudo grub-set-default</code>，最终我是使用这个解决的，但是需要注意的是，不能只给出内核的名字，还要写成这样<code>sudo grub-set-default &quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.4.137&quot;</code><a href="https://www.jianshu.com/p/c76bc5e113f1" target="_blank" rel="noopener">参考这个博客</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作系统课设要编译内核，因为不想使用mac跑虚拟机所以选择租了阿里云一个ECS来进行。之前的步骤都进行的很愉快，直到我不管怎样设置grub都不能使用我新编译的那个内核。&lt;/p&gt;
&lt;p&gt;设置默认内核的方法有这些：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;/etc/default/gr
      
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="kernel" scheme="http://lyhhhhhhhhhhh.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Database Notes</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/17/Database-Notes/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/17/Database-Notes/</id>
    <published>2020-02-17T14:41:02.000Z</published>
    <updated>2020-02-22T07:00:13.545Z</updated>
    
    <content type="html"><![CDATA[<p>看到很多大厂都有对于数据库掌握的要求，打算从mysql和Redis入手填充下数据库方面的知识栈。</p><a id="more"></a><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库是按照数据结构来组织、存储和管理数据的仓库，关系型数据库（RDBMS）是建立在关系模型上的数据库，借助于集合代数的方法和概念来管理数据库，关系型数据库有以下特点：</p><ol><li>数据以表格形式给出。</li><li>每行为各记录名称，每列为记录名称对应的数据域。</li><li>许多行列结合形成一张表单</li><li>若干表单组合成database</li></ol><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>mysql是最流行的关系型数据库管理系统，在web应用方面是最好的关系型数据库管理系统之一。</p><h3 id="创建数据库、删除数据库"><a href="#创建数据库、删除数据库" class="headerlink" title="创建数据库、删除数据库"></a>创建数据库、删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> database_names</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> &lt;databaseName&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysqladmin -u root -p <span class="keyword">create</span> database_names </span><br><span class="line">mysqladmin -u root -p <span class="keyword">drop</span> databaseName</span><br></pre></td></tr></table></figure><p>后者使用管理员权限创建数据库。删除时应当注意删除后所有的数据都将不在，所以需要一些权限去操作。</p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>使用use命令选择数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> databaseName</span><br></pre></td></tr></table></figure><p>mysql 中支持标准sql的数值类型，主要包括数值、日期和时间、字符串。<br><a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">mysql_data_types</a></p><p><strong>创建数据表：</strong></p><p><code>CREATE TABLE table_name (column_name column_type);</code><br>一般使用这样的语法来创建Mysql数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`runoob_tbl`</span>(</span><br><span class="line">   <span class="string">`runoob_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`runoob_title`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`runoob_author`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`submission_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`runoob_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>如果不想使用NULL可以设置为NOT NULL，这样建立NULL值时就会报错。</li><li>AUTO_INCREMENT设置自增属性，一般用于主键。</li><li>PRIMARY KEY关键字用于定义列为主键。可以使用多列来定义主键，列间以逗号分割</li><li>ENGINE=InnoDB DEFAULT CHARSET=utf8 前者设置引擎，后者设置编码</li></ul><p>⚠️注意：表名和字段名使用反引号而不是单引号</p><h3 id="数据库插入"><a href="#数据库插入" class="headerlink" title="数据库插入"></a>数据库插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>sql使用；作为分割语句的分隔符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name  (field1, field2,...fieldN)  <span class="keyword">VALUES</span>  (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;</span><br></pre></td></tr></table></figure><p>添加多列数据时使用逗号作为分割。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO runoob_tbl</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (0, "JAVA 教程", "RUNOOB.COM", '2016-05-06');</span><br></pre></td></tr></table></figure><p>如果每列都要添加数据可以不规定列。第一列主键如果不使用自增比较容易错乱，如果使用自增的话可以使用0或者NULL，这样添加数据可以自增。</p><h3 id="sql-select"><a href="#sql-select" class="headerlink" title="sql select"></a>sql select</h3><p>通过该语句可以查询数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li>可以查询多个表，使用逗号分割即可，where中可以设置查询条件。</li><li>可以设置LIMIT属性来设定返回的记录数量。</li><li>可以痛殴OFFSET来设置偏移量</li></ul><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><blockquote><p>和if语句的作用一样，可以通过AND和OR制定过个条件。出了select语句歪还可以用与delete和update语句</p><p>where：数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p><p>group by:对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p><p>having：用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p><p>执行顺序</p><p>select –&gt;where –&gt; group by–&gt; having–&gt;order by</p></blockquote><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>可以用来更新数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><blockquote><p>delete，drop，truncate 都有删除表的作用，区别在于：</p><p> 1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。<br> 2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。<br> 3、执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。</p></blockquote><h3 id="like-子句"><a href="#like-子句" class="headerlink" title="like 子句"></a>like 子句</h3><p>like子句通常用于where语句中，以进行模糊搜索,一般和%一起使用，其中%和正则表达式中的*一样，表示任意字符。</p><h3 id="union语句"><a href="#union语句" class="headerlink" title="union语句"></a>union语句</h3><p>union语句可以连接多个select语句的结果，整合为一个结果集返回。其是默认不含有重复数据的，如果使用union all指令可以得到全部的数据，包括重复的在内。</p><p>注意其中select语句可以是一个完整的包含where限制条的语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country, <span class="keyword">name</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country=<span class="string">'CN'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> country, app_name <span class="keyword">FROM</span> apps</span><br><span class="line"><span class="keyword">WHERE</span> country=<span class="string">'CN'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country;</span><br></pre></td></tr></table></figure><h3 id="mysql排序"><a href="#mysql排序" class="headerlink" title="mysql排序"></a>mysql排序</h3><p>使用mysql中的order by子句来设定哪个字段需要进行排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name1, table_name2...</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> field1 [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]], [field2...] [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]]</span><br></pre></td></tr></table></figure><p>可以使用多个字段来排序<br>使用ASC和DESC来设置升序或者降序排列，默认为升序<br>where和like指令依然可以使用</p><h3 id="Group-by语句"><a href="#Group-by语句" class="headerlink" title="Group by语句"></a>Group by语句</h3><p>根据一个或者多个列对于结果集进行分组<br>在分组的列上面我们可以使用count avg sum等函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, <span class="keyword">function</span>(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure><blockquote><p>可是使用coalesce来设置一个取代NULL的语法 coalesce(a, b, c）如果是NULL则依次往后顺。</p></blockquote><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>用于连接两个不同的表中的数据，有三种连接方式：<br>INNER JOIN，LEFT JOIN，RIGHT JOIN</p><p>区别在于，第一个相当于取两个表的交集，而剩下两个连接方式不会管另一个表中是否有对应的数据，只返回一个表中符合标准的所有值</p><p>Example:</p><p><a href="https://www.runoob.com/mysql/mysql-join.html" target="_blank" rel="noopener">join</a></p><p><img src="https://i.loli.net/2020/02/19/lgQB1FiIYCKc9eX.jpg" alt="Jietu20200219-150659@2x"></p><p><img src="https://i.loli.net/2020/02/19/Mq1i4ewaWnNm5JZ.jpg" alt="Jietu20200219-150825@2x"></p><h3 id="NULL值处理"><a href="#NULL值处理" class="headerlink" title="NULL值处理"></a>NULL值处理</h3><p>三大运算符进行NULL值的比较：IS NULL，IS NOT NULL，&lt;=&gt;</p><h2 id="mysql-regex"><a href="#mysql-regex" class="headerlink" title="mysql regex"></a>mysql regex</h2><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配开始位置，如果设置了Multiline属性，也可以匹配\n \r</td></tr><tr><td>$</td><td>匹配结束位置</td></tr><tr><td>.</td><td>匹配除了换行符以为的任何单个字符</td></tr><tr><td>[abc.. ]</td><td>字符集合，用于匹配其中包含的任何字符</td></tr><tr><td>[^abc ]</td><td>字符集合取非</td></tr><tr><td></td><td></td></tr><tr><td>*</td><td>匹配前面的子表达式零次或者多次</td></tr><tr><td>+</td><td>可以匹配前面的表达式一次或者多次</td></tr><tr><td>{n}</td><td>匹配确定的n次</td></tr><tr><td>{n, m}</td><td>匹配n-m次</td></tr></tbody></table><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>用于处理操作量大，复杂度高的数据。（个人认为是数据库操作语句的集合）</p><blockquote><p>mysql中只有使用innodb引擎才可以使用事务</p></blockquote><p>一般来说事务需要有四个条件：<strong>原子性，一致性，独立性，持久性</strong></p><ol><li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ol><h3 id="alter命令"><a href="#alter命令" class="headerlink" title="alter命令"></a>alter命令</h3><p>用于修改数据表名或者修改数据表字段</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><ul><li><input disabled="" type="checkbox"> index</li></ul><h3 id="temporary-table"><a href="#temporary-table" class="headerlink" title="temporary table"></a>temporary table</h3><p>临时表顾名思义就是临时创建出来的用于保存临时数据的表，在连接关闭后会自动删除并释放空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>mysql中也可以自定义函数，类似于大多数编程语言函数是一些语句的集合，用来将一些实现特定目的的语句组合起来来降低复杂度。但是注意，mysql中的函数注重返回值，一些语句是不能实现的。</p><p>函数只能返回一个值，不能够返回一个结果集。</p><p><strong>create</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名([参数列表]) <span class="keyword">returns</span> 数据类型</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">sql</span>语句;</span><br><span class="line"> return 值;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>example:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的仅有一条sql的函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> myselect2() <span class="keyword">returns</span> <span class="built_in">int</span> <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line"><span class="keyword">select</span> myselect2(); <span class="comment">-- 调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> myselect3() <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> c <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> cname=<span class="string">"python"</span> <span class="keyword">into</span> c;</span><br><span class="line">    return c;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">select</span> myselect3();</span><br><span class="line"><span class="comment">-- 带传参的函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> myselect5(<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">15</span>)) <span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> c <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> cname=<span class="keyword">name</span> <span class="keyword">into</span> c;</span><br><span class="line">    return c;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">select</span> myselect5(<span class="string">"python"</span>);</span><br></pre></td></tr></table></figure><p><strong>call</strong></p><p>select + function</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 无参调用</span></span><br><span class="line"><span class="keyword">select</span> myselect3();</span><br><span class="line"><span class="comment">-- 传参调用</span></span><br><span class="line"><span class="keyword">select</span> myselect5(<span class="string">"python"</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> <span class="keyword">id</span>=myselect5(<span class="string">"python"</span>);</span><br></pre></td></tr></table></figure><p><strong>delete</strong></p><p><code>drop + function_name</code></p><p><strong>查看函数</strong></p><ul><li>查看函数创建语句：show create function 函数名;</li><li>查看所有函数：show function status [like ‘pattern’];</li></ul><h2 id="mysql变量"><a href="#mysql变量" class="headerlink" title="mysql变量"></a>mysql变量</h2><p>mysql中一共有四种变量：会话变量、全局变量、局部变量和用户变量，前两个统称为系统变量。</p><p><strong>用户变量</strong><br>顾名思义是用户定义的变量，有两种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># two ways use SET</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">variable</span> = expr</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">variable</span> := expr</span><br><span class="line"></span><br><span class="line"><span class="comment"># only be able to use := in select</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">variable</span> := expr</span><br></pre></td></tr></table></figure><ol><li>未定义变量的初始值为 null（可不定义变量直接使用，不会报错）</li><li>变量名对大小写不敏感</li><li>变量不能在要求字面值的地方使用，比如 select 中的 limit 语句等。</li><li>调用用户变量的表达式的计算顺序实际上是未定义的，如 <code>SELECT @a = 0, @a := @a + 1;</code>，两列都可能是 0 。</li></ol><p><strong>会话变量</strong><br>会话变量为服务器为每个客户端连接维护的变量。在客户端连接时，使用相应全局变量的当前值对客户端的会话变量进行初始化。</p><p>顾名思义，会话变量的作用域就是一个会话 Session 咯。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> var_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">set</span> @session.var_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">set</span> var_name = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span>;</span><br><span class="line"><span class="comment"># 以上代码会把所有会话变量罗列出来，可通过 like 进行过滤</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">LIKE</span> <span class="string">"%var%"</span>;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong><br>全局变量会影响服务器整体操作。但是一旦重启，这些设置会被重置。注意要想更改全局变量，必须具有SUPER权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到很多大厂都有对于数据库掌握的要求，打算从mysql和Redis入手填充下数据库方面的知识栈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="datebase" scheme="http://lyhhhhhhhhhhh.github.io/tags/datebase/"/>
    
  </entry>
  
  <entry>
    <title>做点应该做的</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/11/%E5%81%9A%E7%82%B9%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/11/%E5%81%9A%E7%82%B9%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84/</id>
    <published>2020-02-11T03:22:07.000Z</published>
    <updated>2020-02-19T15:26:54.141Z</updated>
    
    <content type="html"><![CDATA[<p>进入社会大染缸前的必要准备</p><a id="more"></a><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><input disabled="" type="checkbox"> Notes</li></ul><ul><li>数据结构</li></ul><ul><li><input checked="" disabled="" type="checkbox"> 链表</li><li><input disabled="" type="checkbox"> 树</li><li><input disabled="" type="checkbox"> 栈和队列</li><li><input checked="" disabled="" type="checkbox"> 哈希表</li><li><input checked="" disabled="" type="checkbox"> 字符串</li><li><input disabled="" type="checkbox"> 数组与矩阵</li><li><input disabled="" type="checkbox"> 图</li><li><input disabled="" type="checkbox"> 位运算</li></ul><ul><li>算法</li></ul><ul><li><input disabled="" type="checkbox"> 双指针</li><li><input disabled="" type="checkbox"> 贪心思想</li><li><input checked="" disabled="" type="checkbox"> 二分查找</li><li><input checked="" disabled="" type="checkbox"> 分治</li><li><input disabled="" type="checkbox"> 搜索</li><li><input disabled="" type="checkbox"> 动态规划</li><li><input disabled="" type="checkbox"> 数学</li><li><input disabled="" type="checkbox"> sort</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><input disabled="" type="checkbox"> Notes</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><input disabled="" type="checkbox"> Notes</li></ul><h2 id="datebase"><a href="#datebase" class="headerlink" title="datebase"></a>datebase</h2><ul><li><input checked="" disabled="" type="checkbox"> mysql</li><li><input disabled="" type="checkbox"> redis</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入社会大染缸前的必要准备&lt;/p&gt;
    
    </summary>
    
    
      <category term="schedule" scheme="http://lyhhhhhhhhhhh.github.io/categories/schedule/"/>
    
    
      <category term="offer" scheme="http://lyhhhhhhhhhhh.github.io/tags/offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode Notes</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/10/leetcode-Notes/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/10/leetcode-Notes/</id>
    <published>2020-02-10T07:01:48.000Z</published>
    <updated>2020-02-25T03:21:11.212Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记</p><a id="more"></a><h2 id="5-最长回文串"><a href="#5-最长回文串" class="headerlink" title="5.最长回文串"></a>5.最长回文串</h2><p>题目描述：<br><img src="https://cdn.img.wenhairu.com/images/2020/02/10/m6tzN.jpg" alt="problem"></p><p>解法说明：</p><ol><li>暴力解法，按长度从高到低遍历字符串找到答案。</li><li>Manacher 算法（马拉车算法）</li></ol><h3 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h3><blockquote><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">参考资料</a></p></blockquote><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个<strong>字符串的最长回文子串的线性方法</strong>，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p><p>首先我们处理一个字符串的奇偶长度问题，选择在每个字符中间插入一个#，这样不论如何所有的字符长度都是奇数，而为了使其到达边界能够自动停止，我们可以在两端插入两个不相等的符号。<br><img src="https://pic.leetcode-cn.com/ad2b5e0da4a3a35b60f60c9a5a2be07a8074f9be0fe1597351eeff7dc460789a-image.png" alt="example"></p><p>对于这样分割后的字符串我们只需要计算每个元素（包括#在内）的中心扩展后的长度然后即可计算出回文串的起始位置和长度。<br><img src="https://pic.leetcode-cn.com/ae2c30d48d35faa7f3d0d8bc4fe18d0691f3d13dcfc5846ddce1bf7a002681f5-image.png" alt="example"><br>起始的位置为P的下标i减去P[i]除以2即为字符串的起始下标，而最长回文串长度为P[i]</p><p><strong>马拉车算法的关键就在于计算P[i]</strong><br>我们使用C来表示当前循环中确定的驻点，而R为该回文串的右边半径，即为该回文串在右边的边界。边界位置为C+R<br>对于在C确定的回文串以内的点的P值，其实际和关于C对称的点的P值一样。<br><img src="https://pic.leetcode-cn.com/29eb66280ca149c3bf5d9906e066b4a2b39d1bf8f9dd0533ca00479aca6f4f39-image.png" alt="example"><br>因为C+R以内是C确定的回文串范围，所以这个结论比较容易得到，但是有几种情况下，这个结论是不正确的。</p><ol><li><p>超出了R<br>i+p[i_mirrors] &gt; R，此时我们可以先将其扩展至R再依次往后扩展。</p></li><li><p>p[i_mirrors]遇到左边界<br>对于i使用正常的中心扩展即可。</p></li><li><p>i=R<br>对其赋值为0，然后使用正常的中心扩展。</p></li></ol><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。<br>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。<br><img src="https://pic.leetcode-cn.com/5fbe52880634a9d5fa60ad5e126e8c5c38c5a6eadd0c901a3495dc1307d46d6b-image.png" alt="example"></p><h2 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a>413.等差数列划分</h2><p>题目描述：<br><img src="https://cdn.img.wenhairu.com/images/2020/02/10/m6jJB.jpg" alt="题目描述"></p><p>求解思路：<br>使用动态规划进行求解，首先等差数列最至少应当由3个元素组成。<br>如果数组a是一个等差数列，且其之后的一个元素与a能组成等差数列的话，新的数组等差数列组数为<strong>sum(a)+len(a)-1</strong>，这个式子是我求解问题的核心思想。<br>那么我们从数组起始开始遍历，每次试图把当前数组的下一个元素加入目前的等差数列中，如果可以加入，则需要更新目前的遍历位置。</p><p>因为只遍历一次数组，所以时间复杂度为O(n), 空间复杂度应该为O(1)</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dif := <span class="number">0</span> <span class="comment">//公差</span></span><br><span class="line">count := <span class="number">0</span> <span class="comment">//等差数列计数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(A)<span class="number">-3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*A[i+<span class="number">1</span>] == (A[i] + A[i+<span class="number">2</span>]) &#123;</span><br><span class="line">dif = A[i+<span class="number">1</span>] - A[i]</span><br><span class="line">length := <span class="number">3</span> <span class="comment">//等差数列长度，起始为3</span></span><br><span class="line">count++ <span class="comment">//首先这个3个元素的起始数列应当算上</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> length+i &gt;= <span class="built_in">len</span>(A) &#123; <span class="comment">//计算到边界则直接返回</span></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> A[length+i]-A[length+i<span class="number">-1</span>] == dif &#123; <span class="comment">//如果可以加入等差数列则更新count值</span></span><br><span class="line">count += length - <span class="number">1</span></span><br><span class="line">length++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i = length + i - <span class="number">1</span> <span class="comment">//如果不能加入到数列中，则只需要将i定位至当前等差数列的最后一个即可</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="744-find-smallest-letter-greater-than-target"><a href="#744-find-smallest-letter-greater-than-target" class="headerlink" title="744.find-smallest-letter-greater-than-target"></a>744.find-smallest-letter-greater-than-target</h3><p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAF8t.jpg" alt="problem"></p><p>这个题本身没什么难的，使用二分查找很容易得到结果，但是我因为一些go语言特性的问题，花了不少功夫来解决问题。<br>贴代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreatestLetter</span><span class="params">(letters []<span class="keyword">byte</span>, target <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">offset := search(letters, target)</span><br><span class="line"><span class="keyword">if</span> offset &gt; <span class="keyword">int</span>(<span class="string">'z'</span>-target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">byte</span>(<span class="keyword">int</span>(target) + offset - <span class="number">26</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">byte</span>(<span class="keyword">int</span>(target) + offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(subLetters []<span class="keyword">byte</span>, target <span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(subLetters)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> length == <span class="number">1</span> &#123;</span><br><span class="line">res := <span class="keyword">int</span>(subLetters[<span class="number">0</span>]) - <span class="keyword">int</span>(target)</span><br><span class="line"><span class="comment">//一开始使用byte型运算之后转为int，结果出乎意料，因为byte溢出</span></span><br><span class="line"><span class="keyword">if</span> res &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid := length / <span class="number">2</span></span><br><span class="line">left := search(subLetters[:mid], target)</span><br><span class="line">right := search(subLetters[mid:], target)</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出在注释位置，此处一开始使用的是byte型直接计算，结果出现了溢出，导致结果十分离谱，以后注意，这个问题是ics时提到过的。</p><p>我就是个智障，上面的那道题我的做法是分治而不是二分查找，二分查找比较重要的条件在于<strong>一开始所给的就是一个有序的序列</strong>，然后我们才能进行二分查找。</p><p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mANGS.jpg" alt="problem"></p><p>求开方也可以使用二分查找来完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// guessNum := x</span></span><br><span class="line"><span class="comment">// for ;guessNum*guessNum &gt; x; &#123;</span></span><br><span class="line"><span class="comment">//     guessNum =guessNum/2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// for ;guessNum*guessNum &lt;= x; &#123;</span></span><br><span class="line"><span class="comment">//     guessNum++</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// return guessNum-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">low, high, mid := <span class="number">0</span>, x, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> low &lt; high<span class="number">-1</span> &#123;</span><br><span class="line">mid = (high-low)/<span class="number">2</span> + low</span><br><span class="line"><span class="keyword">if</span> mid*mid &gt; x &#123;</span><br><span class="line">high = mid</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (high + low) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="problem-34"><a href="#problem-34" class="headerlink" title="problem 34"></a>problem 34</h3><p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAY4C.jpg" alt="problem34"></p><p>选择使用二分查找法，找到两边的边界，如果中间值为目标值，选择从中间往两边拓展，一开始重新构建一个slice头尾确定为一个不存在与原给定slice中的数字是为了更好的做后面的拓展操作，这样边界值更好处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">numsNew := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">numsNew[<span class="number">1</span>+i] = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">numsNew[<span class="number">0</span>], numsNew[<span class="built_in">len</span>(nums)+<span class="number">1</span>] = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">low, high, mid := <span class="number">1</span>, <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">mid = low + (high-low)/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> numsNew[low] == numsNew[high] &amp;&amp; numsNew[low] == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;low - <span class="number">1</span>, high - <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> low &gt;= high &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target &gt; numsNew[mid] &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> target &lt; numsNew[mid] &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low, high = mid, mid</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> numsNew[low] == target &#123;</span><br><span class="line">low--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numsNew[high] == target &#123;</span><br><span class="line">high++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numsNew[low] != target &amp;&amp; numsNew[high] != target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;low, high - <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-153"><a href="#problem-153" class="headerlink" title="problem 153"></a>problem 153</h2><p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAfLs.jpg" alt="problem153"></p><p>算是比较熟练的掌握了二分查找法，这个题的关键在于条件要考虑仔细了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">low, high, mid := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">mid = (high-low)/<span class="number">2</span> + low</span><br><span class="line"><span class="keyword">if</span> (high - low) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[high] &gt; nums[low] &#123;</span><br><span class="line"><span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[high]</span><br><span class="line">&#125;<span class="comment">// when the slice length is 2, return the min directly.</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; nums[mid<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> nums[mid]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; nums[high] &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[low] &#123;</span><br><span class="line">high = mid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nums[low] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[high] &#123;</span><br><span class="line"><span class="keyword">return</span> nums[low]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[high]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAS1H.jpg" alt="problem95"></p><p>第一次一遍通过的题目，这个题一开始没有什么思路，后面想到可以使用递归求解，实际上属于一种分治的思想，依次选择划分递归调用左右两边的生成函数。<br>这道题对于我的难度大多在go语言本身上，声明nil时需要使用var语句 表明类型。</p><blockquote><p>卡特兰数</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">res := generate(<span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(begin, end <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> begin == end &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, &amp;TreeNode&#123;begin, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := begin; i &lt;= end; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == begin &#123;</span><br><span class="line"><span class="keyword">var</span> l *TreeNode = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> generate(begin+<span class="number">1</span>, end) &#123;</span><br><span class="line">temp := TreeNode&#123;i, l, r&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, &amp;temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == end &#123;</span><br><span class="line"><span class="keyword">var</span> r *TreeNode = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> generate(begin, end<span class="number">-1</span>) &#123;</span><br><span class="line">temp := TreeNode&#123;i, l, r&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, &amp;temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &gt; begin &amp;&amp; i &lt; end &#123;</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> generate(begin, i<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> generate(i+<span class="number">1</span>, end) &#123;</span><br><span class="line">temp := TreeNode&#123;i, l, r&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, &amp;temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAOQh.jpg" alt="problem241"></p><p>这个题我真的是个憨憨，花了大半个下午都没做对，一开始我选择以一个完整的算式为分割位置，这样处理既繁琐又不太对，因为字符串中的数字并不见得只有一个字符。后面参考了一下答案，得到了之后的结果，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diffWaysToCompute</span><span class="params">(input <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(input)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> input[i:i+<span class="number">1</span>] == <span class="string">"+"</span> || input[i:i+<span class="number">1</span>] == <span class="string">"-"</span> || input[i:i+<span class="number">1</span>] == <span class="string">"*"</span> &#123;</span><br><span class="line">left := diffWaysToCompute(input[<span class="number">0</span>:i])</span><br><span class="line">right := diffWaysToCompute(input[i+<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">for</span> _, lvalue := <span class="keyword">range</span> left &#123;</span><br><span class="line"><span class="keyword">for</span> _, rvalue := <span class="keyword">range</span> right &#123;</span><br><span class="line">temp := <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> input[i : i+<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">temp = lvalue + rvalue</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">temp = lvalue - rvalue</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">temp = lvalue * rvalue</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// a clever trick to handle with the string</span></span><br><span class="line">value, _ := strconv.Atoi(input)</span><br><span class="line">res = <span class="built_in">append</span>(res, value)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAXmD.jpg" alt="problem"></p><p>这道题虽然很简单但是，解法可以十分巧妙。假设链表一的长度为a+c,链表二的长度为a+c，其中c为公共部分长度，当两者不相交时为0.这样我们可以通过使拼接使得链表的长度都为a+b+c，这样如果两个链表没有焦点访谈则会同时等于nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    l1, l2 := headA, headB</span><br><span class="line">    <span class="keyword">for</span> ;l1 != l2; &#123;</span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            l1 = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            l2 = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAiEs.jpg" alt="pic"></p><p>题目很简单，用了两种方法解决，应当注意的一点是，对go语言的一些特性还是不熟悉，题解给出的代码十分简介，我写的总是很冗长。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">rhead, tail := recursion_reverseList(head)</span><br><span class="line">tail.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> rhead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion_reverseList</span><span class="params">(head *ListNode)</span> <span class="params">(rhead, tail *ListNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">tail = head</span><br><span class="line">rhead = head</span><br><span class="line"><span class="keyword">return</span> rhead, tail</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rhead, tail = recursion_reverseList(head.Next)</span><br><span class="line">tail.Next = head</span><br><span class="line">tail = head</span><br><span class="line"><span class="keyword">return</span> rhead, tail</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">prev,cur := &amp;ListNode&#123;&#125;,head</span><br><span class="line">prev = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span>&#123;</span><br><span class="line">cur.Next,prev,cur = prev,cur,cur.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAsgR.jpg" alt="pic"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">head := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">point := head</span><br><span class="line"><span class="keyword">for</span> (l1 != <span class="literal">nil</span>) || (l2 != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">point.Next = l2</span><br><span class="line"><span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">point.Next = l1</span><br><span class="line"><span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">point.Next, l1 = l1, l1.Next</span><br><span class="line">point = point.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">point.Next, l2 = l2, l2.Next</span><br><span class="line">point = point.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mA2rN.jpg" alt="83"></p><p>真的佛了，这破题也能做半天，细节太重要了，就第三行的两个语句的次序都会影响结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">cur := head</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.Val == cur.Next.Val &#123;</span><br><span class="line">cur.Next = cur.Next.Next</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/14/mAtRn.jpg" alt="19"></p><p>做题果然是熟能生巧的一件事情，做多了之后，链表的题也得心应手起来了，这题使用递归来计算深度，进行删除节点的判断，需要注意边界值的判断，即起始位置。</p><p>查看题解之后发现这道题也可以使用双指针来求解，只需要使第一个指针比后面那个提前走n步，保证间隔即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">depth := traversal(head, n)</span><br><span class="line"><span class="keyword">if</span> depth == n &#123;</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversal</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">depth := traversal(head.Next, n) + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> depth == n+<span class="number">1</span> &#123;</span><br><span class="line">head.Next = head.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/14/mAzbA.jpg" alt="pic"></p><p>题目不难，不过有一点值得注意，为了使类似空链表或者只有一个节点的链表更容易操作，我在原链表前面添加了一个-1节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *leetcodetool.ListNode)</span> *<span class="title">leetcodetool</span>.<span class="title">ListNode</span></span> &#123;</span><br><span class="line">cur := head</span><br><span class="line"><span class="keyword">var</span> pre = &amp;leetcodetool.ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">pre.Next, head = head, pre</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">pre.Next, cur.Next, cur.Next.Next = cur.Next, cur.Next.Next, cur</span><br><span class="line">cur, pre = cur.Next, cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mu9iD.jpg" alt="pic"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oddEvenList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">oddList, evenList := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;, &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">oddHead, evenHead := oddList, evenList</span><br><span class="line"></span><br><span class="line">count := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> count%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">oddList.Next = head</span><br><span class="line">oddList = oddList.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">evenList.Next = head</span><br><span class="line">evenList = evenList.Next</span><br><span class="line">&#125;</span><br><span class="line">head = head.Next</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">head, oddList.Next, evenList.Next = oddHead.Next, evenHead.Next, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mu1Ft.jpg" alt="pic725"></p><p>首先遍历链表计算长度，然后根据计算出来的长度来计算每个链表的长度，前length%k个为length/k+1，使用一个int slice储存，然后仔遍历一遍链表，按照存储的长度做划分即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitListToParts</span><span class="params">(root *ListNode, k <span class="keyword">int</span>)</span> []*<span class="title">ListNode</span></span> &#123;</span><br><span class="line">length := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> count := root; count != <span class="literal">nil</span>; count = count.Next &#123;</span><br><span class="line">length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> split &#123;</span><br><span class="line">split[i] = length / k</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length%k; i++ &#123;</span><br><span class="line">split[i]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := <span class="built_in">make</span>([]*ListNode, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, splitLength := <span class="keyword">range</span> split &#123;</span><br><span class="line">temp := &amp;ListNode&#123;<span class="number">-1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">        head := temp</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; splitLength; j++ &#123;</span><br><span class="line">temp.Next, root = root, root.Next</span><br><span class="line">temp = temp.Next</span><br><span class="line">&#125;</span><br><span class="line">temp.Next = <span class="literal">nil</span></span><br><span class="line">res = <span class="built_in">append</span>(res, head.Next)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mupnS.jpg" alt="pic234"></p><p>使用快慢指针来锁定链表后半段，慢指针每两次走一步，这样就可以确定中点位置，然后倒置后半段即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">slow, traversal := head, head</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> traversal != <span class="literal">nil</span> &amp;&amp; traversal.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">traversal = traversal.Next</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">if</span> count%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow, _ = invertList(slow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> slow != <span class="literal">nil</span> &amp;&amp; head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow.Val != head.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow, head = slow.Next, head.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertList</span><span class="params">(head *ListNode)</span> <span class="params">(invertHead, tail *ListNode)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head, head</span><br><span class="line">&#125;</span><br><span class="line">ihead, tail := invertList(head.Next)</span><br><span class="line">tail.Next, head.Next = head, <span class="literal">nil</span></span><br><span class="line">tail = tail.Next</span><br><span class="line"><span class="keyword">return</span> ihead, tail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>hashmap使用O(N)来存储数据，使用<strong>常数时间</strong>来查找数据</p><p><img src="https://i.loli.net/2020/02/17/vpWnYVXrJ1IKAN5.jpg" alt="Jietu20200217-220621@2x"></p><p>这道题因为要时间界为n，考虑到任何基于比较的排序算法的下界为nlogn，所以想到使用hash表来实现，查看了关于map的定义，发现其是hash的一种实现，所以通过map存储数组元素。然后来看有多少个连续的元素。<br>注意就是内部循环需要对遍历过的元素做标记，否则会超时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">m[value] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> m[value] &#123;</span><br><span class="line">length := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := value + <span class="number">1</span>; m[i]; i++ &#123;</span><br><span class="line">length++</span><br><span class="line">                m[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := value - <span class="number">1</span>; m[i]; i-- &#123;</span><br><span class="line">length++</span><br><span class="line">                m[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res &lt;= length &#123;</span><br><span class="line">res = length</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><img src="https://i.loli.net/2020/02/19/PTrDVy9bLY2Hvg5.jpg" alt="Jietu20200219-180808@2x"></p><p>使用数组长度为26的字符存储</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    store := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        store[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        store[t[i]-<span class="string">'a'</span>]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> store &#123;</span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/19/hIB4fET1gLWiNwA.jpg" alt="Jietu20200219-183807@2x"></p><p>用数组做的，题解里看到一个用map做的更简洁一些的版本，可以使用[]byte(s)将字符串转换为字符slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    store := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">52</span>)</span><br><span class="line">    sum,odd := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        index := <span class="keyword">int</span>(s[i])-<span class="string">'a'</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">            index += <span class="number">59</span> <span class="comment">// handle the situation of capital char</span></span><br><span class="line">        &#125;</span><br><span class="line">        store[index]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> store &#123;</span><br><span class="line">        <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            sum+=value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd = <span class="number">1</span></span><br><span class="line">            sum+=(value<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum+odd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/19/Ao4sSInZX5L9vft.jpg" alt="Jietu20200219-185229@2x"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y, _ := recursion(x)</span><br><span class="line"><span class="keyword">if</span> x == y &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">num := x % <span class="number">10</span></span><br><span class="line">sum, depth := recursion(x / <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; depth; i++ &#123;</span><br><span class="line">num = num * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num + sum, depth + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归太过繁琐了，可以直接通过迭代实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> ||(x%<span class="number">10</span>==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> revertedNumber <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> x &gt; revertedNumber&#123;</span><br><span class="line">revertedNumber = revertedNumber * <span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">x/=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> revertedNumber == x || revertedNumber /<span class="number">10</span> == x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/19/QdczrepGiDLCH9v.jpg" alt="Jietu20200219-231905@2x"></p><p>依次拓展字符串即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubstrings</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> chars = []<span class="keyword">byte</span>(s)</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> chars &#123;</span><br><span class="line">sum += count(chars, i, i)</span><br><span class="line">sum += count(chars, i, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(chars []<span class="keyword">byte</span>, begin, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> begin &gt;= <span class="number">0</span> &amp;&amp; end &lt;= <span class="built_in">len</span>(chars)<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> chars[begin] == chars[end] &#123;</span><br><span class="line">sum = sum + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">begin--</span><br><span class="line">end++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p><img src="https://i.loli.net/2020/02/20/563XwoPvamHiQ1Y.jpg" alt="Jietu20200220-000113@2x"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getdep(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getdep</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := getdep(root.Left)</span><br><span class="line">    right := getdep(root.Right)</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/d5gkVlGoEOHhDm8.jpg" alt="Jietu20200220-001452@2x"></p><p>使用上面的求高度的方法就能求解。</p><p><img src="https://i.loli.net/2020/02/20/lvKUAMzqFhxcyRp.jpg" alt="Jietu20200220-110652@2x"></p><p>值得注意的是一开始我把赋值语句分开写导致，left更改之后传递给right，代码死循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/FyOL1DbfY9RAt7S.jpg" alt="Jietu20200220-160533@2x"></p><p>递归合并即可，不过我使用新的节点和在t1上原地修改空间差距不大。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(t1 *TreeNode, t2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="literal">nil</span> &amp;&amp; t2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.Val = t1.Val+t2.Val</span><br><span class="line">    t1.Left = mergeTrees(t1.Left, t2.Left)</span><br><span class="line">    t1.Right = mergeTrees(t1.Right, t2.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/22/LGtfRqxwMS74ngi.jpg" alt="Jietu20200222-231012@2x"></p><p>这个题使用了回溯的思想，保存了前缀和，通过前缀和的差来计算路径长度。值得学习。</p><p>这个题我有两个地方出了错误，第一是map应当初始化一个m[0]=1进去，不然没有和第一项的比对；第二点是这里的路径只有从上至下，一开始我考虑了从下至上的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    m[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">    res := recursion(root, m, <span class="number">0</span>, sum)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">(root *TreeNode, m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, pathSum <span class="keyword">int</span>, sum <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curSum := pathSum + root.Val</span><br><span class="line">    res += m[curSum-sum]</span><br><span class="line"></span><br><span class="line">    m[curSum]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res += recursion(root.Left, m, curSum, sum) + recursion(root.Right,m, curSum, sum)</span><br><span class="line"></span><br><span class="line">    fmt.Println(res, curSum)</span><br><span class="line"></span><br><span class="line">    m[curSum]-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/22/clN9AvK2sFOCZDd.jpg" alt="Jietu20200222-231327@2x"></p><p>我并没有想出这么巧妙的递归实现。应当注意可以这样对两个方向进行单个的递归操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursion(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">(left *TreeNode, right *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span>)  || (left != <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left.Val != right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursion(left.Left, right.Right) &amp;&amp; recursion(left.Right, right.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/23/pWfgKMXTmd4EH2s.jpg" alt="Jietu20200223-113129@2x"></p><p>这道题按理说没啥难的，但是我用全局变量的时候，提交总是无法通过，关键是错误示例执行是可以通过的。一脸懵逼，这样以来代码就冗余不少，猜测是leetcode的全局变量的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, left_max := getdep(root.Left)</span><br><span class="line">    right, right_max := getdep(root.Right)</span><br><span class="line">    sum := left + right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left_max &gt;= sum &amp;&amp; left_max &gt;= right_max  &#123;</span><br><span class="line">        <span class="keyword">return</span> left_max</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> right_max &gt;= sum &amp;&amp; left_max &lt;= right_max &#123;</span><br><span class="line">        <span class="keyword">return</span> right_max</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getdep</span><span class="params">(root *TreeNode)</span> <span class="params">(depth, max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, left_max := getdep(root.Left)</span><br><span class="line">    right, right_max := getdep(root.Right)</span><br><span class="line">    sum := left + right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left_max &gt;= sum &amp;&amp; left_max &gt;= right_max  &#123;</span><br><span class="line">        max = left_max</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> right_max &gt;= sum &amp;&amp; left_max &lt;= right_max &#123;</span><br><span class="line">        max = right_max</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>, max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right+<span class="number">1</span>, max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/24/mGQCn.jpg" alt=""></p><p>说实话，使用slice实现队列比我想象中的要简单很多，我为每一层的节点单独开辟了一个slice，遍历完这一层之后将队列指针换为下一层的slice即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    depth :=  <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        sonNode := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _, value := <span class="keyword">range</span> queue&#123;</span><br><span class="line">            <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> value.Left == value.Right &#123;</span><br><span class="line">                <span class="keyword">return</span> depth+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            sonNode = <span class="built_in">append</span>(sonNode,value.Left)</span><br><span class="line">            sonNode = <span class="built_in">append</span>(sonNode,value.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        depth++</span><br><span class="line">        queue = sonNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/24/TtqDLrsY67QgPxG.jpg" alt="Jietu20200224-154347@2x"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftVal := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left==<span class="literal">nil</span> &amp;&amp; root.Left.Right==<span class="literal">nil</span> &#123;</span><br><span class="line">        leftVal = root.Left.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) + leftVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/24/mGRkA.jpg" alt="Uploading Jietu20200224-174528@2x.jpg… (6ab1cf5zd)"></p><p>真的要哭出来了，这个题我的思路一开始就是正确的，递归中odd表示该节点为根的子树奇数层（也就是包含该根结点）的和，意味着其父节点不可以计算在内，even也就是意味着父节点可以计算在内。提交了两次都出问题在even的计算上，even实际上一共有四种可能性，我最后因为没有考虑到两个even的和导致debug一下午（当然,其实我在摸鱼）</p><p>这个题看题解中说来，还挺有代表性的，运用了自底向上的动态规划，当然我做的时候没意识到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := recursion(root)</span><br><span class="line">    <span class="keyword">return</span> max(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">(root *TreeNode)</span> <span class="params">(odd, even <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftOdd, leftEven := recursion(root.Left)</span><br><span class="line">    rightOdd, rightEven := recursion(root.Right)</span><br><span class="line"></span><br><span class="line">    odd = leftEven + rightEven + root.Val</span><br><span class="line">    </span><br><span class="line">    even = max(leftEven, leftOdd) + max(rightEven, rightOdd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> odd, even</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/24/hQV3PMeycOqofgv.jpg" alt="Jietu20200224-191757@2x"></p><p>用了广搜，空间换时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSecondMinimumValue</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    res, min := <span class="number">-1</span>, root.Val</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        temp := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _, value := <span class="keyword">range</span> queue &#123;</span><br><span class="line">            <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> value.Val &gt; min &amp;&amp; (res == <span class="number">-1</span> || value.Val &lt; res) &#123;</span><br><span class="line">                    res = value.Val</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="built_in">append</span>(temp, value.Left)</span><br><span class="line">            temp = <span class="built_in">append</span>(temp, value.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        queue = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/25/FYPdyVCQlgbkEOn.jpg" alt="Jietu20200225-105817@2x"></p><p>比较基础的问题，使用迭代法完成先序遍历，一开始没有想出来，看了网上的思想然后通过go写出来。</p><p>这里牵涉到的问题主要是go标准库contains/List的使用，在这上面花了很多时间，稍后将其补充在博客里面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    stack := list.New()</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    stack.PushBack(root) <span class="comment">//push</span></span><br><span class="line">    <span class="keyword">for</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cur  := stack.Back()</span><br><span class="line">        curValue, _ := cur.Value.(*TreeNode)</span><br><span class="line">        stack.Remove(cur) <span class="comment">// pop</span></span><br><span class="line">        <span class="keyword">if</span> curValue != <span class="literal">nil</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, curValue.Val)</span><br><span class="line">            stack.PushBack(curValue.Right)</span><br><span class="line">            stack.PushBack(curValue.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><p><img src="https://i.loli.net/2020/02/20/xcukbpvf4sZdSRA.jpg" alt="Jietu20200220-183400@2x"></p><p>此题解法甚屌，我之前并不知道sql可以这样操作。之前看的太笼统，需要重新看一下类型部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> salary <span class="keyword">SET</span> sex = <span class="built_in">CHAR</span> ( <span class="keyword">ASCII</span>(sex) ^ <span class="keyword">ASCII</span>( <span class="string">'m'</span> ) ^ <span class="keyword">ASCII</span>( <span class="string">'f'</span> ) );</span><br><span class="line"><span class="comment"># 两箱等数异或为0，0异或任何数为任何数</span></span><br><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex = <span class="built_in">char</span>(<span class="keyword">ascii</span>(<span class="string">'m'</span>) + <span class="keyword">ascii</span>(<span class="string">'f'</span>) - <span class="keyword">ascii</span>(<span class="string">'sex'</span>))</span><br><span class="line"><span class="comment"># 这个方法更好理解一些</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/MFixYWujRsDfIvp.jpg" alt="Jietu20200220-185845@2x"></p><p>这个题没啥难的，重要的是我发现sql语句分开写比写成一行更有效率，不知道是不是leetcode的原因。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> cinema </span><br><span class="line"><span class="keyword">where</span> description != <span class="string">"boring"</span> </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">id</span> % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/7vfYjog2dxmwH3D.jpg" alt="Jietu20200220-190736@2x"></p><p>这个题有点门道，需要group by的使用，通过将其分类然后调用count函数，distinct关键字会使student不能重复。注意笔记中的执行顺序select –&gt;where –&gt; group by–&gt; having–&gt;order by</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> courses</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> student) &gt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/isAXy6vWo8VPYlx.jpg" alt="Jietu20200220-214303@2x"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email = p2.Email</span><br><span class="line">    <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br><span class="line"></span><br><span class="line"><span class="comment"># solution 2</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">id</span> </span><br><span class="line">        <span class="keyword">FROM</span> ( </span><br><span class="line">            <span class="keyword">SELECT</span> <span class="keyword">min</span>( <span class="keyword">id</span> ) <span class="keyword">AS</span> <span class="keyword">id</span> </span><br><span class="line">            <span class="keyword">FROM</span> Person</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> email</span><br><span class="line">        ) <span class="keyword">AS</span> m</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/ExdtpZNjvJH2smS.jpg" alt="Jietu20200220-215513@2x"></p><p>因为不管address表中是否含有地址都要进行显示，所以应该使用左外链接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.FirstName, a.LastName, b.City, b.State</span><br><span class="line"><span class="keyword">from</span> Person a <span class="keyword">left</span> <span class="keyword">join</span> Address b</span><br><span class="line"><span class="keyword">on</span> a.PersonId = b.PersonId;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/qWrjCe9pKDJkgGV.jpg" alt="Jietu20200220-221009@2x"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee a, Employee b</span><br><span class="line"><span class="keyword">where</span> a.ManagerId = b.Id <span class="keyword">and</span> a.Salary &gt; b.Salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    E1.NAME <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee E1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Employee E2</span><br><span class="line">    <span class="keyword">ON</span> E1.ManagerId = E2.Id</span><br><span class="line">    <span class="keyword">AND</span> E1.Salary &gt; E2.Salary;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/zw9TJQHgRfrScDN.jpg" alt="Jietu20200220-221907@2x"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> CustomerId</span><br><span class="line">    <span class="keyword">from</span> Orders</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># left join</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    C.Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Customers C</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders O</span><br><span class="line">    <span class="keyword">ON</span> C.Id = O.CustomerId</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    O.CustomerId <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/20/3UyTJ2OhtmLAE4j.jpg" alt="Jietu20200220-224922@2x"></p><p>这个题相对于之前的有一些难度，首先我们应当从Employee表中找出各部门工资最高的人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br></pre></td></tr></table></figure><p>然后再将两个表连接即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Department.name <span class="keyword">AS</span> <span class="string">'Department'</span>,</span><br><span class="line">    Employee.name <span class="keyword">AS</span> <span class="string">'Employee'</span>,</span><br><span class="line">    Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    Department <span class="keyword">ON</span> Employee.DepartmentId = Department.Id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (Employee.DepartmentId , Salary) <span class="keyword">IN</span></span><br><span class="line">    (   <span class="keyword">SELECT</span></span><br><span class="line">            DepartmentId, <span class="keyword">MAX</span>(Salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            Employee</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId</span><br><span class="line">) <span class="comment"># 锁定部门最高薪水的人</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/21/pS7KWsBgtVH2ADE.jpg" alt="Jietu20200221-123634@2x"></p><p>这道题还是有些技巧的，查找第二高的数据，我们可以使用两种方法：一个是使用子查找，首先找出第一高的，然后在查找小于第一高的；第二种是使用limit和offset，对数据做挑选。</p><p>这个题的第二个关键点在于没有数据时返回null。<br>⚠️<strong>需要注意的是在sql中空值和null并不相同。</strong><br>这时的处理就需要ifnull函数，ifnull(a, b)，如果a为空值则返回b</p><p>这里只写出第二种方法的代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>(</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Eeployee </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>), <span class="literal">null</span></span><br><span class="line">) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/21/dp786wYMy3vxmcX.jpg" alt="Jietu20200221-142547@2x"></p><p>这个题的关键在于构造函数，应当注意的一点在于，首先limit语句中不能计算，所以首先要对输入做处理才行。其次就是工资是不能重复的，所以需要使用distinct语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">set</span> N = N <span class="number">-1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">ifnull</span>(</span><br><span class="line">          (</span><br><span class="line">              <span class="keyword">select</span> <span class="keyword">distinct</span> Salary</span><br><span class="line">              <span class="keyword">from</span> Employee</span><br><span class="line">              <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">limit</span> N, <span class="number">1</span></span><br><span class="line">          ), <span class="literal">null</span></span><br><span class="line">      )</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/22/RjGfKZo1xaO5Srz.jpg" alt="Jietu20200222-150155@2x"></p><p>首先这个题目不太严谨，没有说明id是唯一的。做法之一是按照id进行计算，从三个表中找到需要的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> l3.Num</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Logs</span> l1, <span class="keyword">Logs</span> l2, <span class="keyword">Logs</span> l3</span><br><span class="line"><span class="keyword">where</span> l1.Id = l2.Id<span class="number">-1</span> <span class="keyword">and</span> l2.id = l3.id<span class="number">-1</span> <span class="keyword">and</span> l1.num=l2.num <span class="keyword">and</span> l2.num= l3.num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode刷题笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="leetcode" scheme="http://lyhhhhhhhhhhh.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>a tour of go</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/05/a-tour-of-go/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/05/a-tour-of-go/</id>
    <published>2020-02-05T11:52:46.000Z</published>
    <updated>2020-02-13T16:37:10.466Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about a tour of go.</p><a id="more"></a><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>每个Go程序都是由包组成的，程序从main包开始。</p><p>所以每个包中的最开始一个语句都应该是package xxx。</p><p>下面的程序导入了“fmt”和“math/rand”两个包，按照约定，包名应当与导入路径的最后一个元素一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"a num"</span>,rand.Intn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用的导入是分组进行的，也可以一个一个导入。</p><p>值得注意的是，rand包中的方法Intn是以I开头，go中约定以大写字母开头的是已经导出的，<strong>在导入一个包时，只可以使用已经导出的名字</strong>，未导出的名字不可以在该包外访问</p><blockquote><p>这应该类似go中的一种封装</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以没有参数（如main函数）或者有多个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其函数的声明形式也和rust有些类似，首先就是类型放在后面，返回值的形式也很类似</p></blockquote><p>如果多个形参的类型相同，可以只写最后一个。</p><p>函数可以返回<strong>任意数量</strong>的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span> )</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a,b := swap(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go的返回值可以命名，会被<em>视作定义在函数顶部的变量</em>，没有参数的return会返回已经命名的返回值</p><blockquote><p>返回值的命名应当有意义，因为可以作为文档生成。直接返回方式也应当运用在短函数中以防影响可读性</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum -x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var语句用于声明一个变量列表，和函数的参数列表一样，类型在最后。<br>var语句可以除像在包或者函数级别。<br>变量声明可以包含初始值，如果初始化值已经存在，可以忽略类型，这点和rust一致</p><p><strong>函数中</strong>，简明的赋值语句：=可以在<strong>类型明确</strong>的地方替代var</p><p><strong>函数外的每个语句都必须以关键字开始</strong>，因此：=不可以在函数外使用</p><p>go的基本类型和大多数语言一致，除了复数complex，除此之外变量声明也可以使用分组成一个语法块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"math/cmplx"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Tobe <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">2i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>没有声明初始值的变量会被自动赋为零值，数值类型为0，布尔类型为false，字符串为空字符串</p><p><strong>类型转换</strong>：表达式T（v）将值v转换为类型T<br>与C语言不同，Go在不同类型之间赋值必须进行显式的类型转换。</p><p>同rust一样，在未生命类型时go会进行对变量的类型推导</p><p>简明的声明方式不可以指定变量的类型。</p><p>常量的声明与变量类似，只是var语句换成const，而且不可以使用：=<br>一个未指定类型的常量由上下文来决定其类型。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Go只有一种循环结构<strong>for循环</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">    sum +=i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和其他语言可能有所不同，go的循环初始化、条件以及后置的更新语句可以不带括号，但是后面的花括号是必须的。</p><blockquote><p>初始化和后置语句是可选的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span> ; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的结构中也可以把括号去掉，因为在go中，while叫做for。省略循环条件可以实现无限循环。</p><p>if语句和rust中的也一致，即无需小括号大括号是必须的。<br>同for语言一样，if语句可以在条件表达式之前执行一个简单的语句，变量的作用域是if之内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swich-case"><a href="#swich-case" class="headerlink" title="swich-case"></a>swich-case</h3><p>对于Go而言switch语句整体和c相似，不过Go只运行特定的case而不是之后所有的case，除非以fallthrough语句结束，否则分支会自动停止。</p><p>Go的另一个重点在于swith的cace无需为常数而且也不必要取值为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(:<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">            fmt.Println(<span class="string">"macOs"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Linux"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"%s\n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句求值顺序为从上到下，没有条件的switch语句和switch true一样，这样可以把if-else语句写的更加美观。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span> :</span><br><span class="line">            fmt.Println(<span class="string">"good morning"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer</strong>: defer语句会将函数推迟到外层函数返回值执行，defer修饰的函数的参数会立即求值，但是知道外层函数返回时才会被调用。</p><p>defer修饰的语句会压入一个栈中，先进后出的形式进行调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言拥有指针，指针保存了内存地址。</p><p>类型<em>T是一个指向类型T的指针,指针的零值为nil<br>&amp;操作符可以取指针，而</em>操作符可以访问指针指向的值。<br>Go没有指针运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t *<span class="keyword">int</span></span><br><span class="line">v := <span class="number">42</span></span><br><span class="line">p := &amp;v</span><br><span class="line">*p = <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体（struct）就是一组字段（field）</p><p>结构体有两种访问方式</p><ol><li>点号访问</li><li>结构体指针访问，p为指向结构题的指针，则可以使用（*p).x访问其中元素，当然这样写有点麻烦，Go允许隐式的间接引用，即p.x</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    p := &amp;v</span><br><span class="line">    p.X = <span class="number">1e9</span> <span class="comment">//go语言可以使用科学计数法表示数</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>【n】T表示n个T类型元素的数组，其中数组的长度是固定的<br><code>var array [n]int</code></p><p>每个数组的大小都是固定的，go提供slice（切片）来对数组进行动态的访问。</p><p>[ ]T表示T类型的切片，切片需要指定上下界来获得对数组的一个半开区间的访问，它包括下界而不包括上界</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">6</span>]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = array[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片并不储存任何数据，他可以看作是数组的引用，当改变切片的值时，底层的数组元素也会被改变。</p><p>切片文法类似于没有声明数组长度的数组文法<br><code>[]T {}</code><br>会创建一个数组然后构建一个它的引用，此时该数组是匿名的。</p><p>切片的上下界具有默认值，上界默认为数组长度加一，下界为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[:]</span><br><span class="line"><span class="comment">//对于上述数组来说，这些切片是相同的</span></span><br></pre></td></tr></table></figure><p>切片有长度和容量两个属性，切片s的长度和容量可以通过len(s), cap(s)来访问<br>对于一个切片，我们可以通过重新切片来获得拓展其长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展其长度</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 舍弃前两个值</span></span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxK2o.jpg" alt="result"></p><p>切片的零值是nil，零值的切片没有底层数组且长度和容量为0。</p><p>切片可以使用内建函数make来实现，这也是创建动态数组的方法。make会创建出一个零值数组然后返回它的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)<span class="comment">//len(s)=cap(s)=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要指定容量则需要指定第三个参数</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)<span class="comment">// len(s2)=0, cap(s)=5</span></span><br></pre></td></tr></table></figure><p>切片可以包含任何类型甚至是其他切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">    board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, strings.Join(board[i], <span class="string">" "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用内建的append指令来使其动态增长，append的第一个参数是切片，之后是需要添加的元素，类似下面的使用方式<br><code>s = append(s, 2, 3, 4)</code></p><p>for循环的range形式可以遍历切片或者映射</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    fmt.Println(<span class="string">"value:%d, index:%d"</span>, v, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range每次返回两个值，第一个是当前的下标，第二个是对应值的副本。可以使用_来忽略某个返回值，如果只需要索引可以省略第二个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxDff.jpg" alt="interest"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//row := make([]uint8, dx)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">        row := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> row &#123;</span><br><span class="line">        row[j] = <span class="keyword">uint8</span>((i + j) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = row</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pic.Show(Pic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里注释掉的部分，如果构造内部slice放在循环体外则会所有的result都指向同一个slice，因为go在这里的等号赋值是浅拷贝，如果使用append就是深拷贝了。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键与值进行映射，映射的零值为nil，nil映射既没有键也不能添加键</p><p>映射的文法与结构类似不过需要有键名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x,y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex &#123;</span><br><span class="line">    <span class="string">"lala"</span> = Vertex&#123;</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"didi"</span> = Vertex&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果顶级类型只是一个类型名则可以省略</p><p>使用make可以初始化映射，然后通过操作来为映射插入或者修改值<br><code>m[key] = value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">"hello"</span>]=<span class="number">1</span> <span class="comment">//insert the key-value</span></span><br><span class="line">m[<span class="string">"hello"</span>]=<span class="number">2</span> <span class="comment">//modify the ke-value</span></span><br><span class="line"></span><br><span class="line">v = m[<span class="string">"hello"</span>] <span class="comment">//get the value of the given key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"hello"</span>) <span class="comment">//delete the key</span></span><br><span class="line"></span><br><span class="line">v, ok = m[<span class="string">"hello"</span>] <span class="comment">// find if the key exist, if it exists, the v will be the value ande ok is a true; if not, the v will be the zero of that type and ok is false</span></span><br></pre></td></tr></table></figure><p><strong>函数也是值，可以用作参数或者返回值</strong>，见下面示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。他可以访问并赋予其可以引用的变量的值，每个闭包都绑定了自己的变量。</p><p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxEHd.jpg" alt="demo"></p><p>使用闭包实现斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num  = [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &lt;= <span class="number">2</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span> num[count<span class="number">-2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">            temp := num[<span class="number">1</span>] + num[<span class="number">0</span>]</span><br><span class="line">            num[<span class="number">0</span>] = num[<span class="number">1</span>]</span><br><span class="line">            num[<span class="number">1</span>] = temp</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中没有类，但是可以为结构体定义方法。<br>方法是一类带有特殊的接收者参数的函数，接收者参数位于func关键字与方法名之间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.x + v.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法就只是一个带接收者参数的函数。</p><h3 id="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"><a href="#接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法" class="headerlink" title="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"></a>接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法</h3><p>可以为指针接收者定义方法，这意味着接收者的位置可以使用*T文法。</p><p>当使用指针的定义时可以对于接收者的数据进行修改，而如果直接传递接收者值时，只能修改其<strong>副本</strong>。<br>这个结论对于函数也一致，传递类型作为参数时，得到修改的始终是副本，只有指针才能修改类型的值。</p><p>而且如果函数的参数是类型指针，则只能使用指针传递。而在方法中，可以使用值进行传递，值在方法中既可以作为指针又可以作为值。<br><strong>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型是一组方法签名的组合</p><p>接口变量可以保存任何实现了这些方法的类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line">    <span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">    a = &amp;v</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应当注意其中注释的那部分，实现interface abser的是Vertex的指针所以不能使用v而是应当使用&amp;v</p><p>实现了一个接口定义的所有方法即为实现了接口，这样就无需使用implements等的显式的定义，这样的隐式定义解耦了接口的定义，接口就可以使用于任何包中无需要提前的准备。</p><p>接口也是值，也可以作为参数或者返回值。<br>在内部接口可以认为是值和类型的二元组，（value，type）<br>接口值保存了一个底层类型的具体值，当接口调用方法时，会调用底层类型的相应方法。</p><p>有些时候接口值保存的值为nil，这样有时候就需要我们使用一些方式在方法中优雅的解决这种情况<br>保存了nil的接口值并不为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(t.s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nil的接口值不保存任何具体值和类型，使用nil的接口值会产生一个runtime错误，因为并不知道需要调用哪个类型的底层方法。</p><p>没有定义任何方法的接口为空接口，<strong>空接口可以保存任何类型的值，一般用来处理未知类型的值</strong></p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言提供了访问接口底层值的方法。</p><p><code>v := i.(T)</code><br>该语句断言接口变量i含有类型T，并试图将T的值赋给v。如果i不含有类型T，这可能会触发一个panic</p><p>可以使用与映射类似的方式访问类型断言<br><code>v, ok := i.(T)</code></p><p>类型选择，类型选择是一种使用分支结构依次访问断言类型的方式，其结构与switch类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">//v的类型为T</span></span><br><span class="line">    <span class="keyword">case</span> S：</span><br><span class="line">    <span class="comment">//v的类型为S</span></span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    <span class="comment">//v的类型与i的接口类型一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fmt包中的Stringer包是最常用的包，它包含了一个解释自己的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go使用error来表示错误，同String类似，error也是一个内建的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error <span class="keyword">string</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fmt包在进行输出的时候也会满足error接口。<br>当使用error时应当注意判断是否为nil，此时表示为成功，否则为失败。</p><h2 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h2><p>io包中有一个Reader接口使用比较广泛，可以从数据流的末尾读取数据。</p><p>Reader接口有一个read方法，读取数据填充切片并返回一个读取的字节数和一个错误值<br><code>func (T) Read(b []byte) (n int, err error)</code><br>如果读取到文件末尾则返回一个io.EOF错误。</p><p>有种常见的模式是使用一个Reader接口包装另一个Reader接口，然后通过某种方法来修改其中数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reader rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := reader.r.Read(b)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> b[i] &gt;= <span class="string">'A'</span> &amp;&amp; b[i] &lt;<span class="string">'N'</span> :</span><br><span class="line">            b[i] += <span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i]&gt;=<span class="string">'N'</span> &amp;&amp; b[i] &lt;=<span class="string">'Z'</span>:</span><br><span class="line">            b[i] -=<span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i] &gt;= <span class="string">'a'</span> &amp;&amp; b[i] &lt;<span class="string">'n'</span> :</span><br><span class="line">            b[i] += <span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i]&gt;=<span class="string">'n'</span> &amp;&amp; b[i] &lt;=<span class="string">'z'</span>:</span><br><span class="line">            b[i] -=<span class="number">13</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</span><br><span class="line">    r := rot13Reader&#123;s&#125;</span><br><span class="line">    io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go协程（goroutine）"><a href="#go协程（goroutine）" class="headerlink" title="go协程（goroutine）"></a>go协程（goroutine）</h2><p>goroutine是go运行时管理的轻量级线程。</p><p><code>go f(x, y, z)</code><br>会在新的线程中执行f，而对于f、x、y、z的求值则在当前的线程内</p><p>goroutine是在同一个地址空间，因此使用共享内存是需要同步，可以使用sync包，也有其他的方式实现同步。</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是带有类型的管道，可以通过它来发送或者接收值，信道操作符为&lt;-</p><p>和映射切片一样，信道在使用之前必须创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">v := <span class="number">2</span></span><br><span class="line">ch &lt;- v</span><br><span class="line"></span><br><span class="line">r := &lt;-ch <span class="comment">//&lt;-为数据流动方向</span></span><br></pre></td></tr></table></figure><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(v []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">        sum += v[i]</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    value := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(value[:<span class="built_in">len</span>(value)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(value[<span class="built_in">len</span>(value)/<span class="number">2</span>:], c)</span><br><span class="line"></span><br><span class="line">    x, y := &lt;-c, &lt;-c</span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过向make函数添加参数来实现带缓冲区的信道</p><p>当传递的内容超过缓冲区大小程序将无法正常执行</p><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><p><strong>发送者</strong>可以使用close来关闭一个信道，只有发送者可以关闭，而且如果向关闭了的信道发送消息会导致panic。<br>可以使用for-range循环来不断从信道中读内容，当信道关闭时结束循环。</p><p>可以使用两个接收量的传递语句来判断信道是否关闭。<br><code>i, ok := &lt;- ch</code><br>如果ok为false就表明信道已经关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fabonacci</span> <span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y <span class="comment">// 值得注意，用这个方式就没必要像之前用的那么麻烦。没必要使用中间变量temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fabonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select 语句使一个 Go 程可以等待多个通信操作。</p><p>select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fabonacci</span><span class="params">( c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fabonacci()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当select的其他分支没有准备好时，default分支就会执行。</p><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>Go标准库中提供的sync.Mutex类型实现了lock和unlock两个方法<br>我们可以使用defer方法将unlock指令推迟来实现互斥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about a tour of go.&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="golang" scheme="http://lyhhhhhhhhhhh.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>博客md图片托管</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/02/05/%E5%8D%9A%E5%AE%A2md%E5%9B%BE%E7%89%87%E6%89%98%E7%AE%A1/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/02/05/%E5%8D%9A%E5%AE%A2md%E5%9B%BE%E7%89%87%E6%89%98%E7%AE%A1/</id>
    <published>2020-02-05T07:43:39.000Z</published>
    <updated>2020-02-13T16:36:41.311Z</updated>
    
    <content type="html"><![CDATA[<p>用github和hexo搭建的博客，有时候markdown里想索引图片，发现博客文件夹中的文件结构和GitHub仓库中的完全不一样，所以难以确定索引路径，之后找到了三种方式：</p><a id="more"></a><ol><li>用github建个仓库专门存放图片</li><li>可以在hexo配置文件_config.yml里的post_asset_folder选项设置为true，这样你每次新建一个md文件，就会自动创建一个同名的文件夹用来放资源，索引路径为/assets/文件名</li><li>使用图片托管网站，imgur或者别的都行，imgur需要科学上网，我用的是 <a href="https://img.wenhairu.com/" target="_blank" rel="noopener">公众图库</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用github和hexo搭建的博客，有时候markdown里想索引图片，发现博客文件夹中的文件结构和GitHub仓库中的完全不一样，所以难以确定索引路径，之后找到了三种方式：&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://lyhhhhhhhhhhh.github.io/categories/blog/"/>
    
    
      <category term="心得" scheme="http://lyhhhhhhhhhhh.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行与shell脚本编程大全</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/01/28/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/01/28/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/</id>
    <published>2020-01-28T08:18:29.000Z</published>
    <updated>2020-02-13T16:37:38.102Z</updated>
    
    <content type="html"><![CDATA[<p>Linux命令行与shell脚本编程大全学习笔记</p><a id="more"></a><h2 id="基本的shell指令"><a href="#基本的shell指令" class="headerlink" title="基本的shell指令"></a>基本的shell指令</h2><p>tail指令可以检查指令的最后几行，一个有趣的特性是可以使用-f参数，使得其可以在其他进程中使用该指令保持活动状态。<br>用以监视文件的变化</p><h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><p><strong>探查进程</strong>：<br>我们一般使用ps指令来探查进程的情况。<br>但是ps实际上十分难以使用，因为它有十分复杂的参数以及多个版本。</p><p>ps的缺点之一是只能显示特定时间的进程情况，如果想要实时监测应当使用top指令</p><p>如果想结束进程可以使用kill或者killall指令，这两个指令主要是传递信号给进程，进程主要使用信号来传递信息。<br>这两个指令的不同之处为第二个指令不使用进程号而使用进程名来结束所有复合条件的进程。</p><p>处理数据文件：<br>sort指令：对于文件进行排序。</p><p>grep指令：查找某行数据。egrep, fgrep是类似的版本，功能各有不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep t file1</span><br><span class="line">grep -v t file1 <span class="comment">#反向查询</span></span><br><span class="line">grep -n t file1 <span class="comment">#显示行数</span></span><br><span class="line">grep -c t file1 <span class="comment">#-c只返回匹配的行数，而不返回具体行</span></span><br><span class="line">grep -e t -e f file1 <span class="comment">#-e使用多个匹配模式</span></span><br></pre></td></tr></table></figure><p>压缩命令：tar</p><p>一行中指定一系列命令，可以通过在每个命令之间加入一个分号实现，但是如果想使用进程列表，则需要在前后加上括号，这样就会产生一个子shell用于执行指令。</p><p><code>ps;ls;echo $BASH_SUBSHELL</code><br>最后打印出来的变量值为1，其代表为子shell的层数。</p><p>可以使用命令后的一个&amp;号来转入后台运行指令，后台的指令可以使用jobs来查看。</p><p>转入后台还可以使用协程执行，即coproc命令，它还可以使用命令的扩展语法指定后台作业的名字。<br><code>coproc My_job { sleep 2; }</code><br>应当注意其中空格都必须存在不能省略。</p><h2 id="内建指令"><a href="#内建指令" class="headerlink" title="内建指令"></a>内建指令</h2><p>可以使用type和which找到外部命令的位置。<br>外部命令的执行时，会创建出来一个子进程，这样的过程叫做forking。这样的过程必定要消耗一定的资源。</p><p>与之相反的是内建指令就不需要使用子进程来实现，可以使用type指令查看是否为内建指令。</p><p>shell也有很多种类型：交互式，非交互式<br>交互式一般指在登陆shell中通过输入bash等指令打开的shell。<br>非交互式一般就是指脚本文件使用的shell。<br>登陆shell会使用/etc/profile文件来设置启动。<br>用户自定义的本地启动文件在用户文件夹下的rc等文件中。</p><h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>Linux通过用户账户来进行权限的管理。使用UID进行区分。<br>可以在/etc/passwd中看到所有的用户以及相应的UID，其中有很多是为服务提供的账户，并不显示密码，密码另外储存在/etc/shadow文件中，只用特定的程序才能够访问，如登陆程序。</p><p>ls命令中，权限展示的第一个指文件类型，后面的每三个字符代表一类用户对于该文件的权限，依次是文件属主权限、属组成员权限、其他用户权限。<br>可以通过umask命令设置默认的文件权限。其中得到的是掩码</p><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h2 id="Linux基本编辑器"><a href="#Linux基本编辑器" class="headerlink" title="Linux基本编辑器"></a>Linux基本编辑器</h2><h2 id="基本shell编程"><a href="#基本shell编程" class="headerlink" title="基本shell编程"></a>基本shell编程</h2><p>命令替换：有两种方式可以从命令中提取信息，并将其赋给变量。</p><ol><li>反引号字符</li><li>$（）格式</li></ol><p>进行数学计算，可以通过命令替换使用expr指令完成操作，也可以是使用中括号【】。bash中只能使用整数运算，但是zsh（如mac中的shell）可以进行浮点数的相关运算。<br>在bash中进行浮点数运算可以使用bc。其中scale表示小数位数，默认为0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！ /bin/bash</span></span><br><span class="line">var1=`<span class="built_in">echo</span> <span class="string">"scale=4; 3.44 / 5"</span> | bc`</span><br><span class="line"></span><br><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expressions</span><br><span class="line">EOF )</span><br><span class="line"><span class="comment"># 可以使用这样的方式通过重定向完成大量计算过程。</span></span><br></pre></td></tr></table></figure><h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><p>表示指令执行状态。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>正常退出</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不适合的shell命令</td></tr><tr><td>126</td><td>命令不可执行</td></tr><tr><td>127</td><td>没找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与Linux信号x相关的严重错误</td></tr><tr><td>130</td><td>通过ctrl+c终止的命令</td></tr><tr><td>255</td><td>正常范围之外的退出状态码</td></tr></tbody></table><p>一般来讲，shell脚本会以脚本的最后一个命令的退出状态码退出。<br>可以通过exit n指定命令的退出码为n<br>应当注意的是，<strong>退出状态码最大为255</strong></p><h2 id="字段分隔符（IFS）"><a href="#字段分隔符（IFS）" class="headerlink" title="字段分隔符（IFS）"></a>字段分隔符（IFS）</h2><p>一般来讲，默认的字段分隔符为空格、制表符、换行符, 可以通过指定IFS来设置分隔符。<br><code>IFS=$&#39;\n&#39;</code></p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>使用getopt解析命令行：<br><code>getopt optstring paramerters</code><br>关键部分在optstring，在其中列出要在脚本中使用的每个命令行选项字母。如果该选项需要参数则使用冒号：。然后getopt就会根据你提供的optstring来解析参数中的命令行参数。可以使用-q来忽略错误消息。</p><p>在脚本中使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -- <span class="variable">$&#123;getopt -q ab:cd "$*"&#125;</span></span><br></pre></td></tr></table></figure><p>set指令又一个选项是–，作用是使用参数来代替原本的命令行选项。应当注意的是，getopt并不擅长处理带空格和引号的参数值。</p><p><strong>使用更高级的getopts</strong>：<br>命令格式为：<code>getopts optstring variable</code><br>其中optstring和上面的类似，可以在命令行选项前面加上：使得忽视错误信息。<br>和上面的不同，getopts每次只处理一个命令行选项，其使用两个环境变量，一个OPYARG保存选项的参数值，而OPTIND保存参数列表中正在处理的参数的位置。</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>可以使用exec命令完成对于文件重定向的实现。<br>该命令可以创建文件描述符，并对其进行相应的重定向操作。<br>将描述符重定向至&amp;-以实现对其的关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt; test17file</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is a test line of data"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure><p>记录消息可以使用tee，该命令类似一个T型通道，将输入分发至指定文件和标准输出。</p><ul><li><input disabled="" type="checkbox"> 临时文件</li></ul><h2 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>脚本可以使用trap命令来捕捉信号，trap的命令格式为：<br><code>trap commands signals</code><br>command位置列出命令，后面跟着需要处理的信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">"echo Goodbye..."</span> EXIT</span><br><span class="line"><span class="comment"># 捕捉退出状态，同样有捕捉ctrl-c的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' Sorry! I have trapped the ctrl-c' "</span> SIGINT</span><br><span class="line"><span class="comment"># 捕捉ctrl+c信号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> -- SIGINT</span><br><span class="line"><span class="comment"># 删除之前设置的捕捉信号</span></span><br></pre></td></tr></table></figure><h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>只需要在命令后面加一个&amp;即可。<br>可以使用nohup指令将shell脚本和终端分离，其输入输出在hohup文件中</p><p>使用bg或者fg命令重启后台的脚本</p><p>使用nice和renice来设置命令的优先级，越高优先级越低。</p><h3 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h3><p>可以使用at来定时执行文件，而at的输出十分不方便，通过email进行stdout和stderr。</p><p>亦可以使用cron时间表来实现。</p><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>函数输出，可以使用echo输出，见实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func1 &#123;</span><br><span class="line"> <span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value</span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`func1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the new value is: <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure><p>这里有一个值得一提的小技巧，注意这里使用了read的一个选项来进行命令行提示，如果这里使用echo则read读取时会将其一起读取至shell变量中。</p><p>参数传递：shell会将函数作为小型的脚本处理，这意味着我们可以使用类似脚本处理参数的方式处理参数</p><h3 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h3><p>使用库函数等的关键在于sounce命令，其在当前shell的上下文中执行命令，不会创建新的shell，因此可以使用其中定义的函数。<br>其也有一个简单的别名（alias）称作点操作符</p><p>可以在shell中直接定义函数<br>或者将其写入bashrc中每次建立shell都会加载。</p><p>使用<strong>shtool库函数</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvfoP.jpg" alt="shtool"></p><h2 id="图形化脚本编程"><a href="#图形化脚本编程" class="headerlink" title="图形化脚本编程"></a>图形化脚本编程</h2><p>说起来就是使用文字构建出类似的命令行界面。<br>echo -e允许echo指令输出转义字符。</p><p>可以使用select命令比较简单的生成菜单。命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">PS3=promt</span><br><span class="line"><span class="comment"># 环境变量PS3显示提示。</span></span><br></pre></td></tr></table></figure><p>可以使用dialog包来进行对话框创建。</p><p><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvYJh.jpg" alt="dialog"></p><h2 id="sed、gawk处理文本"><a href="#sed、gawk处理文本" class="headerlink" title="sed、gawk处理文本"></a>sed、gawk处理文本</h2><p>sed是流文本处理工具，和vim等交互式文本处理不同</p><table><thead><tr><th>常用选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>按照脚本执行</td></tr><tr><td>-f</td><td>从文件中读取命令</td></tr><tr><td>-n</td><td>静默模式，不会输出至stdout</td></tr></tbody></table><h3 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h3><p><code>sed &#39;s/test/trail/&#39; data.txt</code><br>s命令是替换命令，会将data文件中每行默认的第一个test替换为trail。<br>在最后一个斜杠之后还可以加上别的选项</p><ol><li>数字代表替换第几处</li><li>g：表示替换所有匹配的位置</li><li>p：同时打印原来的文本</li><li>w file：表示输出至file</li></ol><p>sed中可以使用感叹号作为命令中字符串的分隔符</p><p>如果想将命令作用于特定的行中，不针对所有行，则需要使用行寻址。可以使用两种方式：</p><p>1.数字方式行寻址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'2s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># 应用于第二行</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">'2,4s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># 2-4</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">'2,$s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># the lines behind No.2</span></span><br></pre></td></tr></table></figure><p>2.文本方式<br>/pattern/command 按照pattern进行匹配，对匹配成功的行进行操作，其中模式可以使用正则表达式。</p><h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><p>删除命令为d，可以使用上文提到的两种寻址方式来选择删除的行。<br>应当注意模式匹配时需要有开始和结束，不然会出现意外情况。</p><h3 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h3><p>插入（i），附加（a），使用寻址来指定操作的行<br>插入会在该行前面，而附加会添加至该行之后。</p><h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>修改命令为c，允许修改整行数据 。通上述的命令一样需要指定新的行内容。</p><h3 id="转换指令y"><a href="#转换指令y" class="headerlink" title="转换指令y"></a>转换指令y</h3><p>唯一可以操作单个字符的指令。命令格式为：<br><code>[address]y/inchars/outchars/</code></p><p>转换指令会对inchars和outchars的值做一对一映射，如果两个字符串的长度不同则会产生一条错误信息。</p><p>因此y指令会对文本中所有符合的匹配的数据做映射替换。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>= p两个命令，前者用于打印行号，后者用于打印。同时可以结合-n选项，禁止其他输出，来输出特定匹配选项。</p><p>l列出行，可以将不可打印的ascii码等字符打印出来。</p><p>r，w：读写指令，可以完成数据流和文件的交互操作。</p><h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><p>就目前为止我们学习的sed命令都是只处理数据行的一行，我们可以使用下面三个命令来处理多行数据：</p><ol><li>N：将数据流中下一行加进来形成一个多行组</li><li>D：删除多行组中的一行</li><li>P：打印多行组中的一行</li></ol><p><strong>next命令</strong>：单行模式中使用小写n来表示next命令，单行模式中使用n命令会继续执行之后的命令而不是将命令从头到尾再执行一遍。<br>而多行模式有所不同，它会将下面的一行加入到当前的匹配模式中。</p><p><strong>gawk</strong><br>gawk提供一个类编程环境来修改和重新组织文件中的数据<br>gawk是awk的gnu版本，它提供了一种新的编程语言而不是简单的编辑器命令</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-F fs</td><td>指定行中的字段分隔符</td></tr><tr><td>-f file</td><td>从指定的文件中读取程序</td></tr><tr><td>-v var=value</td><td>定义一个变量和默认值</td></tr><tr><td>-mf N</td><td>定义要处理文件中的最大字段数</td></tr><tr><td>-mr N</td><td>指定数据文件中的最大数据行数</td></tr><tr><td>-W keyword</td><td>指定兼容模式或者警告等级</td></tr></tbody></table><p>gawk会自动的为文本文件中的数据分配为变量，其中：</p><ol><li>$0 表示整个文本行</li><li>$1 表示第一个数据字段</li><li>$n 表示第n个数据字段</li></ol><p>可以通过BEGIN来指定程序在读取数据前运行脚本内容，类似的也有END</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一般Linux支持两种正则表达式类型：BRE（基本），ERE（拓展）</p><p><strong>锚字符</strong>：默认情况下，正则表达式可以匹配整行的内容，如果想锁定在行首或者行尾匹配，则需要锚字符锁定位置</p><p>锁定在行首：^,通过使用该字符可以使其匹配锁定在行首，需要放在模式最前面<br>锁定在行尾：$，需要放在模式的最后面</p><p><strong>点号字符</strong>：代表换行符以外任意一个字符。<br><strong>字符组</strong>：中括号将需要匹配的一个数据组放在其中。可以在字符组中使用^符号表示匹配除了字符组给出的字符的模式</p><p><strong>特殊字符组：</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvFzu.jpg" alt="特殊字符组示例"></p><p><strong>星号</strong>：字符后面放置星号表示该字符出现0次或者多次，可以和字符组组合起来使用</p><h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>以下为ERE模式的正则表达式部分，sed只支持BRE而gawk支持大部分ERE因此比sed要慢一些</p><p><strong>问号（ ？）</strong>：类似于星号，但是问号只表示出现0或者1次，仅此而已<br><strong>加号（ + ）</strong>：是星号的另一个模式，表示出现一次或者多次，但是至少一次。<br><strong>花括号（{})</strong>：表示允许可重复正则表达式的上限。m为准确出现m次；m，n为至少m次，至多n次<br>默认情况下gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval选项才可以。</p><p><strong>管道符号（｜）</strong>：使用or方式指定多个模式<br><strong>表达式分组（（））</strong>：正则表达式模式可以使用圆括号进行分组，该组会被视为一个标准字符，可以一样给该组使用特殊字符。</p><h2 id="zsh简介"><a href="#zsh简介" class="headerlink" title="zsh简介"></a>zsh简介</h2><p>zsh是一个开源的shell，其最值得称道的是具有加载命令模块的功能，即可以通过这种方式添加内建指令。</p><p>zsh是shell中可定制性最强的，可以通过不同的选项定制需要的shell</p><h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><p>通过zmodload管理zsh的模块。</p><p>没有任何参数的zmodload指令显示已经加载了的模块，如果需要安装则直接在后面跟上模块名，没有任何输出则表示已经加载完成。删除则是使用-u选项。</p><blockquote><p>通常会将zmodload指令放在zshrc文件中，这样每次打开可以自动加载需要的内容。<br>实测发现加载模块的命令不是一直有效的，退出后则重置所以需要写入zshrc文件中</p></blockquote><p>可以使用<strong>man zshmodules</strong>命令查看各个模块的内容</p><p>zsh提过更加全面的数学操作，其可以使用浮点数运算。<br>有两种方式：let命令或者双圆括号</p><ol><li><code>let values=&quot; 4 * 1.8 &quot;</code></li><li><code>values=$(( 4 * 1.8 ))</code></li></ol><p>如果一开始没有指定变量的类型，就会导致一些出乎意料的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">value=10</span><br><span class="line">value2=$(( <span class="variable">$value</span> / 3 ))</span><br><span class="line"><span class="comment"># value2=3</span></span><br><span class="line"></span><br><span class="line">value=10.</span><br><span class="line">value2=$(( <span class="variable">$value</span> / 3 ))</span><br><span class="line"><span class="comment"># value2=3.33333333</span></span><br></pre></td></tr></table></figure><p>zsh中数学函数可以通过加载mathfunc库实现，加载之后就可以使用整个数学函数库。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>shell的学习到这里就差不多了，这本书我感觉更像是一本工具书，过年期间有些东西看的也不是很细。</p><ul><li><input disabled="" type="checkbox"> sed，gawk进阶部分</li><li><input disabled="" type="checkbox"> exec重定向</li></ul><p>以上的部分没有怎么看，之后有用到在回来看一下。<br>个人认为shell还是得多写，同一个功能在shell中可能有很多的选择可以实现，这本书就作为一本🔧书常备着就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux命令行与shell脚本编程大全学习笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="shell" scheme="http://lyhhhhhhhhhhh.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell learning</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/01/23/Shell-learning/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/01/23/Shell-learning/</id>
    <published>2020-01-23T04:04:05.000Z</published>
    <updated>2020-02-13T16:37:54.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title="shell学习笔记"></a>shell学习笔记</h1><blockquote><p><a href="https://www.runoob.com/linux/linux-shell-passing-arguments.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>shell本身是用户访问内核的桥梁，所谓的shell学习，实际上是学习shell脚本。</p><p>和大多数脚本语言一样，shell只需要一个编辑器和一个解释器就可以了，常见的shell解释器种类众多，有sh、bash、zsh等，我们本次学习bash脚本。</p><a id="more"></a><p>第一个shell脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure><p>其中第一行告诉系统使用什么解释器来解释shell脚本。</p><p>运行shell的方法：</p><ol><li>作为可执行程序</li><li>作为命令解释器的参数</li></ol><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>定义变量时不需要加美元符号，如：<br><code>my_name=&quot;lyhhhhh&quot;</code></p><p>命名规则：</p><ol><li>只能使用英文，不能以数字开头</li><li>中间不可以有空格，可以使用下划线</li><li>不能使用标点</li><li>注意不能使用保留关键字</li></ol><p>使用一个定义过的变量，只需要变量名加美元符号即可，而变量名外面的花括号是可选的，添加是为了方便区分界限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">'lyhhhhh'</span></span><br><span class="line"><span class="comment">#the ways below are both valid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br></pre></td></tr></table></figure><p>可以使用readonly命令将变量声明为只读变量<br>也可以使用unset命令将变量删除，之后就无法使用，unset命令不能使用在readonly变量上</p><p><strong>变量的类型：</strong></p><ol><li>局部变量： 局部变量在脚本中定义，只在当前shell实例中有效</li><li>环境变量： 属于系统定义的变量，所有的程序和shell都可以访问</li><li>shell变量： 是shell程序设置的特殊变量，一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行</li></ol><h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>字符串是shell中最经常使用的类型，实际上在shell中除了字符串和数字也没啥可以用的了。</p><p>字符串分为单引号和双引号两种，两者的区别在于单引号字符串的内容即为引号中的内容，如果里面有对变量的引用是无效的。<br>而双引号中可以存在转义字符和变量等可以解释的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeting_2=<span class="string">'hello, '</span><span class="variable">$your_name</span><span class="string">' !'</span></span><br><span class="line">greeting_3=<span class="string">'hello, $&#123;your_name&#125; !'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, <span class="variable">$&#123;your_name&#125;</span> !</span><br></pre></td></tr></table></figure><p><strong>shell中的字符串存在一些可以使用的操作：</strong></p><ol><li>获取字符串长度：在字符串前添加#</li><li>提取子字符串：${str:begin_index:num} 形如前式，其中beginindex为起始索引（起始为0），num为字符数量。</li><li>查找子字符串：见下面例子，注意使用的是反引号而不是单引号</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">'hello, world'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#output: 4, calculate the length of the string</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:3&#125;</span> <span class="comment">#output: ell, substring</span></span><br><span class="line"><span class="built_in">echo</span> `exper index <span class="string">"<span class="variable">$string</span>"</span> ol`</span><br><span class="line"><span class="comment"># 输出o和l在字符串中的位置，那个先出现就输出哪个，注意是反引号而不是单引号。</span></span><br></pre></td></tr></table></figure><h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>bash支持一维数组而不支持多维数组，类似于c语言，数组元素下标从0开始，可以是表达式，但是需要值合法。</p><p>shell中使用括号表示数组，使用空格将数组元素分开。<br>也可以单个定义数组各个元素，下标可以不连续。</p><p>获取数组长度与获取字符串长度类似，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"><span class="comment"># get the num of the array</span></span><br><span class="line">length=<span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="comment"># same as the way given above</span></span><br><span class="line"></span><br><span class="line">length=<span class="variable">$&#123;#array[n]&#125;</span></span><br><span class="line"><span class="comment"># get the length of the array[n]</span></span><br></pre></td></tr></table></figure><h3 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h3><p>单行注释通过#来实现。<br>多行注释可以使用每行都添加#或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p>其中！可以被其他标志代替。</p><h2 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h2><p>在执行脚本时我们可以通过命令行为脚本附加参数，调用这些参数的规则如$n，n=0表示的是脚本文件名，1、2、3···以此类推为第一第二个参数</p><p>另外还有几个特殊的参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>将所有参数合并到一个字符输出</td></tr><tr><td>$$</td><td>脚本当前运行进程的id</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的id</td></tr><tr><td>$@</td><td>与第二个类似，不过是以多个字符串组合的形式</td></tr><tr><td>$-</td><td>显示shell使用的当前选项，和set命令相同</td></tr><tr><td>$?</td><td>现实最后命令的退出状态，0为没有错误</td></tr></tbody></table><p>$*和$@区别：只有在双括号中才能显现出来，例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>output:<br>1 2 3</p><p>1<br>2<br>3</p><h2 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h2><p>shell和其他语言一样支持多种运算符，包括：</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><p>后两者比较有趣，后面会详细介绍</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算只能对于数字，不能适用于字符串，除非字符串全部由数字构成。</p><p>原生的bash不支持简单的数学运算，需要通过其他的命令来实现，比如awk和expr，其中expr最常用，expr是一款表达式计算工具，可以完成表达式确知操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the sum of two nums: <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure><p>应当注意的是，表达式中的运算符和数字之间应当有空格，这和我们大多数的习惯不同。</p><p>常用的算数运算符和C语言类似，即加减乘除、取余等</p><p><strong>注意</strong>：乘号前面需要加\转义</p><h3 id="shell中-的使用方式"><a href="#shell中-的使用方式" class="headerlink" title="shell中[]的使用方式"></a>shell中[]的使用方式</h3><p><strong>[]在shell中作为测试语句说明</strong><br>比如算术比较、文件属性比较、字符串比较等</p><p>使用算术比较举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>值得注意的是，【】和比较的元素之间需要使用空格隔开。除了使用==、！=等C语言类似的算术比较之外，我们还可以使用-eq这样的比较运算符。例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"var=0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var1</span> -eq 0 -a <span class="variable">$var2</span> -gt 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>常用的运算符如下：</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-gt</td><td>greater than</td></tr><tr><td>-lt</td><td>less than</td></tr><tr><td>-ge</td><td>greater and equal</td></tr><tr><td>-lt</td><td>less and equal</td></tr><tr><td>-ne</td><td>not equal</td></tr><tr><td>-a, -o</td><td>and or（用于结合多个判断操作）</td></tr></tbody></table><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>同c等类似，逻辑运算无非就是 ｜｜ 和 &amp;&amp;<br>需要注意的是，一旦使用逻辑运算，最好使用双中括号，不然可能出现错误，这在字符串运算中也是类似的。</p><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>常用运算符：</p><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td>=</td><td>判断运算符是否相等，返回true或者false</td></tr><tr><td>！=</td><td>判断运算符是否不等</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0为true</td></tr><tr><td>-n</td><td>功能同上，返回值相反。</td></tr><tr><td>$</td><td>检测是否为空，不为空则true</td></tr></tbody></table><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>用于测试Unix文件属性</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>-r、-w、-x</td><td>测试文件是否可读可写可执行</td></tr><tr><td>-c、-b</td><td>测试是否为字符或者块设备文件</td></tr><tr><td>-d</td><td>测试是否为目录</td></tr><tr><td>-e</td><td>测试文件（目录）是否存在</td></tr><tr><td>-s</td><td>测试是否为空，不为空返回true</td></tr></tbody></table><h2 id="shell中的printf"><a href="#shell中的printf" class="headerlink" title="shell中的printf"></a>shell中的printf</h2><p>和c语言基本一致，除了不需要括号以外，应当注意的是当参数比规格化字符串多时，会按照该格式将多出的参数全部输出</p><p><code>printf &quot;%s %s %s\n&quot; a b c d e f g h i j</code></p><p>输出为：<br>a b c<br>d e f<br>g h i<br>j</p><p>转义字符等和c语言一致</p><h2 id="shell-test"><a href="#shell-test" class="headerlink" title="shell test"></a>shell test</h2><p>test指令实际上和上文中提到的[]功能一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># they are same</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$a</span> == <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line">result=$[a+b]</span><br><span class="line"><span class="comment">#the[], is used to calculate the result.</span></span><br></pre></td></tr></table></figure><p>应当注意后面的情况，此时中括号用于计算结果。</p><h2 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h2><p>shell中不能存在没有指令的分支，如果该分支无事可做则不写出来.</p><h3 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a>if-else分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition; <span class="keyword">then</span> <span class="built_in">command</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上式中两种写法均可。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>shell中提供的for循环是for-in循环<br>变量值存在in列表中，for循环则执行一次所有内容。</p><p>shell中还有类似c语言的循环格式，形似下面给出的代码段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));<span class="keyword">do</span></span><br><span class="line">    command1;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>值得注意的是，一般来讲shell中变量的调用是要使用$的，但是在for循环中并不需要。如果对于变量的更改是在函数体中，则需要加美元符号</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello, input is: <span class="variable">$FILM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中使用了shell let指令，用于执行一个或者多个表达式，不需要使用美元符号。</p><blockquote><p>let 是shell中用于计算的表达式不需要时使用美元符号，如果表达式中存在空格或者其他字符则需要引用起来。</p></blockquote><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> value <span class="keyword">in</span></span><br><span class="line">val1)</span><br><span class="line">    command1</span><br><span class="line">    ;;</span><br><span class="line">val2)</span><br><span class="line">    command2</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>linux shell中可以定义函数，然后在脚本中可以调用。</p><p>函数形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] func_name ()</span><br><span class="line">&#123;</span><br><span class="line">    command1</span><br><span class="line"></span><br><span class="line">    [ <span class="built_in">return</span> int; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中【】表示可选项，即函数可以不使用function定义或者没有返回值。<br>函数的返回值可以使用$?调用<br><strong>注意</strong>：由于shell执行顺序是依次执行的，因此函数定义必须在使用之前。而且$?只对上一条指令负责。</p><p>函数参数传递形式和shell脚本一样，然后通过美元符号加数字调用。</p><p>函数与指令的执行结果可以作为条件语句使用，<strong>要注意的是，和c语言不同该，0在shell中是true，其他为false</strong></p><h2 id="shell文件重定向"><a href="#shell文件重定向" class="headerlink" title="shell文件重定向"></a>shell文件重定向</h2><p>重定向指令列表：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向之file</td></tr><tr><td>command &lt; file</td><td>将输入重定向至file</td></tr><tr><td>command &gt;&gt; file</td><td>将输出追加至file</td></tr><tr><td>n &gt; file</td><td>将文件描述符为n的文件重定向至file</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为n的文件追加到file</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件m和n合并</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件m与n合并</td></tr><tr><td>&lt;&lt;tag</td><td>将开始标记和结束标记之间等我内容作为输入</td></tr></tbody></table><p><code>command1 &lt; infile &gt; outfile</code><br>此命令将命令的输入输出全部替换了</p><p><strong>⚠️注意：0通常是标准输入，1是标准输出，2是标准错误输出</strong></p><p><code>command &gt; file 2&gt;&amp;1</code><br>可以将stdout和stderr都重定向至file</p><p>Here Document<br>是一种特殊的重定向方式，用于将输入重定向到一个交互式脚本或者程序中。<br>基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt; tag</span><br><span class="line">    document</span><br><span class="line">tag</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>结尾的tag应当顶格写，前后都不能有任何字符</li><li>开始的tag前后的空格会被忽略。</li></ul><p>如果执行某指令不希望有任何输出可以将输出重定向至/dev/null，这是一个特殊文件，重定向至它的所有内容都会被丢弃。</p><h2 id="shell外部调用"><a href="#shell外部调用" class="headerlink" title="shell外部调用"></a>shell外部调用</h2><p>shell中也可以包含外部脚本，这样就可以封装一些常用的公用脚本作为独立文件。<br>常用的调用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. filename</span><br><span class="line"><span class="comment"># otherwise</span></span><br><span class="line"><span class="built_in">source</span> filename</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>被调用的文件可以不需要可执行权限</li><li>path中不包含当前路径则需要写出。/filename</li></ol><blockquote><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell学习笔记&quot;&gt;&lt;a href=&quot;#shell学习笔记&quot; class=&quot;headerlink&quot; title=&quot;shell学习笔记&quot;&gt;&lt;/a&gt;shell学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-shell-passing-arguments.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;shell简介&quot;&gt;&lt;a href=&quot;#shell简介&quot; class=&quot;headerlink&quot; title=&quot;shell简介&quot;&gt;&lt;/a&gt;shell简介&lt;/h2&gt;&lt;p&gt;shell本身是用户访问内核的桥梁，所谓的shell学习，实际上是学习shell脚本。&lt;/p&gt;
&lt;p&gt;和大多数脚本语言一样，shell只需要一个编辑器和一个解释器就可以了，常见的shell解释器种类众多，有sh、bash、zsh等，我们本次学习bash脚本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding" scheme="http://lyhhhhhhhhhhh.github.io/categories/coding/"/>
    
    
      <category term="shell" scheme="http://lyhhhhhhhhhhh.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>My first blog</title>
    <link href="http://lyhhhhhhhhhhh.github.io/2020/01/23/My-first-blog/"/>
    <id>http://lyhhhhhhhhhhh.github.io/2020/01/23/My-first-blog/</id>
    <published>2020-01-22T16:13:24.000Z</published>
    <updated>2020-02-13T16:37:49.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>费了不少功夫才把这个博客搭好</p><p>虽然大部分是按照前人走过的路来搞得，但是也需要自己去摸索一些东西</p><p>很早就想有这样一个平台来记录自己的学习过程了，想通过这样一点一滴的记录看到自己的成长</p><p>这样才有动力去向着996的生活进发，hhhhhhhhhh</p><p>加油，奥力给！！！</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一篇博客&quot;&gt;&lt;a href=&quot;#第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;第一篇博客&quot;&gt;&lt;/a&gt;第一篇博客&lt;/h1&gt;&lt;p&gt;费了不少功夫才把这个博客搭好&lt;/p&gt;
&lt;p&gt;虽然大部分是按照前人走过的路来搞得，但是也需要自己去摸索一些东西&lt;/p&gt;
&lt;p&gt;很早就想有这样一个平台来记录自己的学习过程了，想通过这样一点一滴的记录看到自己的成长&lt;/p&gt;
&lt;p&gt;这样才有动力去向着996的生活进发，hhhhhhhhhh&lt;/p&gt;
&lt;p&gt;加油，奥力给！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://lyhhhhhhhhhhh.github.io/categories/blog/"/>
    
    
      <category term="心得" scheme="http://lyhhhhhhhhhhh.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
</feed>
