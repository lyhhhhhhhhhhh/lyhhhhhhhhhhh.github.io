<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>a tour of go</title>
    <url>/2020/02/05/a-tour-of-go/</url>
    <content><![CDATA[<p>Notes about a tour of go.</p>
<a id="more"></a>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>每个Go程序都是由包组成的，程序从main包开始。</p>
<p>所以每个包中的最开始一个语句都应该是package xxx。</p>
<p>下面的程序导入了“fmt”和“math/rand”两个包，按照约定，包名应当与导入路径的最后一个元素一致</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"a num"</span>,rand.Intn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用的导入是分组进行的，也可以一个一个导入。</p>
<p>值得注意的是，rand包中的方法Intn是以I开头，go中约定以大写字母开头的是已经导出的，<strong>在导入一个包时，只可以使用已经导出的名字</strong>，未导出的名字不可以在该包外访问</p>
<blockquote>
<p>这应该类似go中的一种封装</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以没有参数（如main函数）或者有多个参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其函数的声明形式也和rust有些类似，首先就是类型放在后面，返回值的形式也很类似</p>
</blockquote>
<p>如果多个形参的类型相同，可以只写最后一个。</p>
<p>函数可以返回<strong>任意数量</strong>的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span> )</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a,b := swap(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go的返回值可以命名，会被<em>视作定义在函数顶部的变量</em>，没有参数的return会返回已经命名的返回值</p>
<blockquote>
<p>返回值的命名应当有意义，因为可以作为文档生成。直接返回方式也应当运用在短函数中以防影响可读性</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum -x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var语句用于声明一个变量列表，和函数的参数列表一样，类型在最后。<br>var语句可以除像在包或者函数级别。<br>变量声明可以包含初始值，如果初始化值已经存在，可以忽略类型，这点和rust一致</p>
<p><strong>函数中</strong>，简明的赋值语句：=可以在<strong>类型明确</strong>的地方替代var</p>
<p><strong>函数外的每个语句都必须以关键字开始</strong>，因此：=不可以在函数外使用</p>
<p>go的基本类型和大多数语言一致，除了复数complex，除此之外变量声明也可以使用分组成一个语法块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"math/cmplx"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Tobe <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    z <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">2i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>没有声明初始值的变量会被自动赋为零值，数值类型为0，布尔类型为false，字符串为空字符串</p>
<p><strong>类型转换</strong>：表达式T（v）将值v转换为类型T<br>与C语言不同，Go在不同类型之间赋值必须进行显式的类型转换。</p>
<p>同rust一样，在未生命类型时go会进行对变量的类型推导</p>
<p>简明的声明方式不可以指定变量的类型。</p>
<p>常量的声明与变量类似，只是var语句换成const，而且不可以使用：=<br>一个未指定类型的常量由上下文来决定其类型。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Go只有一种循环结构<strong>for循环</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ &#123;</span><br><span class="line">    sum +=i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他语言可能有所不同，go的循环初始化、条件以及后置的更新语句可以不带括号，但是后面的花括号是必须的。</p>
<blockquote>
<p>初始化和后置语句是可选的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span> ; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的结构中也可以把括号去掉，因为在go中，while叫做for。省略循环条件可以实现无限循环。</p>
<p>if语句和rust中的也一致，即无需小括号大括号是必须的。<br>同for语言一样，if语句可以在条件表达式之前执行一个简单的语句，变量的作用域是if之内</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swich-case"><a href="#swich-case" class="headerlink" title="swich-case"></a>swich-case</h3><p>对于Go而言switch语句整体和c相似，不过Go只运行特定的case而不是之后所有的case，除非以fallthrough语句结束，否则分支会自动停止。</p>
<p>Go的另一个重点在于swith的cace无需为常数而且也不必要取值为整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(:<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">            fmt.Println(<span class="string">"macOs"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Linux"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"%s\n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句求值顺序为从上到下，没有条件的switch语句和switch true一样，这样可以把if-else语句写的更加美观。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span> :</span><br><span class="line">            fmt.Println(<span class="string">"good morning"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>defer</strong>: defer语句会将函数推迟到外层函数返回值执行，defer修饰的函数的参数会立即求值，但是知道外层函数返回时才会被调用。</p>
<p>defer修饰的语句会压入一个栈中，先进后出的形式进行调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言拥有指针，指针保存了内存地址。</p>
<p>类型<em>T是一个指向类型T的指针,指针的零值为nil<br>&amp;操作符可以取指针，而</em>操作符可以访问指针指向的值。<br>Go没有指针运算</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t *<span class="keyword">int</span></span><br><span class="line">v := <span class="number">42</span></span><br><span class="line">p := &amp;v</span><br><span class="line">*p = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体（struct）就是一组字段（field）</p>
<p>结构体有两种访问方式</p>
<ol>
<li>点号访问</li>
<li>结构体指针访问，p为指向结构题的指针，则可以使用（*p).x访问其中元素，当然这样写有点麻烦，Go允许隐式的间接引用，即p.x</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    p := &amp;v</span><br><span class="line">    p.X = <span class="number">1e9</span> <span class="comment">//go语言可以使用科学计数法表示数</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>【n】T表示n个T类型元素的数组，其中数组的长度是固定的<br><code>var array [n]int</code></p>
<p>每个数组的大小都是固定的，go提供slice（切片）来对数组进行动态的访问。</p>
<p>[ ]T表示T类型的切片，切片需要指定上下界来获得对数组的一个半开区间的访问，它包括下界而不包括上界</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">6</span>]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = array[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片并不储存任何数据，他可以看作是数组的引用，当改变切片的值时，底层的数组元素也会被改变。</p>
<p>切片文法类似于没有声明数组长度的数组文法<br><code>[]T {}</code><br>会创建一个数组然后构建一个它的引用，此时该数组是匿名的。</p>
<p>切片的上下界具有默认值，上界默认为数组长度加一，下界为0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[:]</span><br><span class="line"><span class="comment">//对于上述数组来说，这些切片是相同的</span></span><br></pre></td></tr></table></figure>

<p>切片有长度和容量两个属性，切片s的长度和容量可以通过len(s), cap(s)来访问<br>对于一个切片，我们可以通过重新切片来获得拓展其长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展其长度</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 舍弃前两个值</span></span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxK2o.jpg" alt="result"></p>
<p>切片的零值是nil，零值的切片没有底层数组且长度和容量为0。</p>
<p>切片可以使用内建函数make来实现，这也是创建动态数组的方法。make会创建出一个零值数组然后返回它的切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)<span class="comment">//len(s)=cap(s)=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要指定容量则需要指定第三个参数</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)<span class="comment">// len(s2)=0, cap(s)=5</span></span><br></pre></td></tr></table></figure>

<p>切片可以包含任何类型甚至是其他切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">    board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, strings.Join(board[i], <span class="string">" "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用内建的append指令来使其动态增长，append的第一个参数是切片，之后是需要添加的元素，类似下面的使用方式<br><code>s = append(s, 2, 3, 4)</code></p>
<p>for循环的range形式可以遍历切片或者映射</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    fmt.Println(<span class="string">"value:%d, index:%d"</span>, v, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range每次返回两个值，第一个是当前的下标，第二个是对应值的副本。可以使用_来忽略某个返回值，如果只需要索引可以省略第二个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxDff.jpg" alt="interest"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//row := make([]uint8, dx)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">        row := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> row &#123;</span><br><span class="line">        row[j] = <span class="keyword">uint8</span>((i + j) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = row</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pic.Show(Pic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里注释掉的部分，如果构造内部slice放在循环体外则会所有的result都指向同一个slice，因为go在这里的等号赋值是浅拷贝，如果使用append就是深拷贝了。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键与值进行映射，映射的零值为nil，nil映射既没有键也不能添加键</p>
<p>映射的文法与结构类似不过需要有键名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x,y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex &#123;</span><br><span class="line">    <span class="string">"lala"</span> = Vertex&#123;</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"didi"</span> = Vertex&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意如果顶级类型只是一个类型名则可以省略</p>
<p>使用make可以初始化映射，然后通过操作来为映射插入或者修改值<br><code>m[key] = value</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="string">"hello"</span>]=<span class="number">1</span> <span class="comment">//insert the key-value</span></span><br><span class="line">m[<span class="string">"hello"</span>]=<span class="number">2</span> <span class="comment">//modify the ke-value</span></span><br><span class="line"></span><br><span class="line">v = m[<span class="string">"hello"</span>] <span class="comment">//get the value of the given key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"hello"</span>) <span class="comment">//delete the key</span></span><br><span class="line"></span><br><span class="line">v, ok = m[<span class="string">"hello"</span>] <span class="comment">// find if the key exist, if it exists, the v will be the value ande ok is a true; if not, the v will be the zero of that type and ok is false</span></span><br></pre></td></tr></table></figure>

<p><strong>函数也是值，可以用作参数或者返回值</strong>，见下面示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。他可以访问并赋予其可以引用的变量的值，每个闭包都绑定了自己的变量。</p>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxEHd.jpg" alt="demo"></p>
<p>使用闭包实现斐波那契数列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num  = [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &lt;= <span class="number">2</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span> num[count<span class="number">-2</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">            temp := num[<span class="number">1</span>] + num[<span class="number">0</span>]</span><br><span class="line">            num[<span class="number">0</span>] = num[<span class="number">1</span>]</span><br><span class="line">            num[<span class="number">1</span>] = temp</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中没有类，但是可以为结构体定义方法。<br>方法是一类带有特殊的接收者参数的函数，接收者参数位于func关键字与方法名之间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.x + v.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法就只是一个带接收者参数的函数。</p>
<h3 id="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"><a href="#接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法" class="headerlink" title="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"></a>接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法</h3><p>可以为指针接收者定义方法，这意味着接收者的位置可以使用*T文法。</p>
<p>当使用指针的定义时可以对于接收者的数据进行修改，而如果直接传递接收者值时，只能修改其<strong>副本</strong>。<br>这个结论对于函数也一致，传递类型作为参数时，得到修改的始终是副本，只有指针才能修改类型的值。</p>
<p>而且如果函数的参数是类型指针，则只能使用指针传递。而在方法中，可以使用值进行传递，值在方法中既可以作为指针又可以作为值。<br><strong>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型是一组方法签名的组合</p>
<p>接口变量可以保存任何实现了这些方法的类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a Abser</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">    a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line">    <span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">    a = &amp;v</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应当注意其中注释的那部分，实现interface abser的是Vertex的指针所以不能使用v而是应当使用&amp;v</p>
<p>实现了一个接口定义的所有方法即为实现了接口，这样就无需使用implements等的显式的定义，这样的隐式定义解耦了接口的定义，接口就可以使用于任何包中无需要提前的准备。</p>
<p>接口也是值，也可以作为参数或者返回值。<br>在内部接口可以认为是值和类型的二元组，（value，type）<br>接口值保存了一个底层类型的具体值，当接口调用方法时，会调用底层类型的相应方法。</p>
<p>有些时候接口值保存的值为nil，这样有时候就需要我们使用一些方式在方法中优雅的解决这种情况<br>保存了nil的接口值并不为nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(t.s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nil的接口值不保存任何具体值和类型，使用nil的接口值会产生一个runtime错误，因为并不知道需要调用哪个类型的底层方法。</p>
<p>没有定义任何方法的接口为空接口，<strong>空接口可以保存任何类型的值，一般用来处理未知类型的值</strong></p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言提供了访问接口底层值的方法。</p>
<p><code>v := i.(T)</code><br>该语句断言接口变量i含有类型T，并试图将T的值赋给v。如果i不含有类型T，这可能会触发一个panic</p>
<p>可以使用与映射类似的方式访问类型断言<br><code>v, ok := i.(T)</code></p>
<p>类型选择，类型选择是一种使用分支结构依次访问断言类型的方式，其结构与switch类似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">//v的类型为T</span></span><br><span class="line">    <span class="keyword">case</span> S：</span><br><span class="line">    <span class="comment">//v的类型为S</span></span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    <span class="comment">//v的类型与i的接口类型一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fmt包中的Stringer包是最常用的包，它包含了一个解释自己的字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go使用error来表示错误，同String类似，error也是一个内建的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error <span class="keyword">string</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fmt包在进行输出的时候也会满足error接口。<br>当使用error时应当注意判断是否为nil，此时表示为成功，否则为失败。</p>
<h2 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h2><p>io包中有一个Reader接口使用比较广泛，可以从数据流的末尾读取数据。</p>
<p>Reader接口有一个read方法，读取数据填充切片并返回一个读取的字节数和一个错误值<br><code>func (T) Read(b []byte) (n int, err error)</code><br>如果读取到文件末尾则返回一个io.EOF错误。</p>
<p>有种常见的模式是使用一个Reader接口包装另一个Reader接口，然后通过某种方法来修改其中数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reader rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    n, err := reader.r.Read(b)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> b[i] &gt;= <span class="string">'A'</span> &amp;&amp; b[i] &lt;<span class="string">'N'</span> :</span><br><span class="line">            b[i] += <span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i]&gt;=<span class="string">'N'</span> &amp;&amp; b[i] &lt;=<span class="string">'Z'</span>:</span><br><span class="line">            b[i] -=<span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i] &gt;= <span class="string">'a'</span> &amp;&amp; b[i] &lt;<span class="string">'n'</span> :</span><br><span class="line">            b[i] += <span class="number">13</span></span><br><span class="line">        <span class="keyword">case</span> b[i]&gt;=<span class="string">'n'</span> &amp;&amp; b[i] &lt;=<span class="string">'z'</span>:</span><br><span class="line">            b[i] -=<span class="number">13</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</span><br><span class="line">    r := rot13Reader&#123;s&#125;</span><br><span class="line">    io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="go协程（goroutine）"><a href="#go协程（goroutine）" class="headerlink" title="go协程（goroutine）"></a>go协程（goroutine）</h2><p>goroutine是go运行时管理的轻量级线程。</p>
<p><code>go f(x, y, z)</code><br>会在新的线程中执行f，而对于f、x、y、z的求值则在当前的线程内</p>
<p>goroutine是在同一个地址空间，因此使用共享内存是需要同步，可以使用sync包，也有其他的方式实现同步。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是带有类型的管道，可以通过它来发送或者接收值，信道操作符为&lt;-</p>
<p>和映射切片一样，信道在使用之前必须创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">v := <span class="number">2</span></span><br><span class="line">ch &lt;- v</span><br><span class="line"></span><br><span class="line">r := &lt;-ch <span class="comment">//&lt;-为数据流动方向</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(v []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">        sum += v[i]</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    value := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(value[:<span class="built_in">len</span>(value)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(value[<span class="built_in">len</span>(value)/<span class="number">2</span>:], c)</span><br><span class="line"></span><br><span class="line">    x, y := &lt;-c, &lt;-c</span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过向make函数添加参数来实现带缓冲区的信道</p>
<p>当传递的内容超过缓冲区大小程序将无法正常执行</p>
<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<p><strong>发送者</strong>可以使用close来关闭一个信道，只有发送者可以关闭，而且如果向关闭了的信道发送消息会导致panic。<br>可以使用for-range循环来不断从信道中读内容，当信道关闭时结束循环。</p>
<p>可以使用两个接收量的传递语句来判断信道是否关闭。<br><code>i, ok := &lt;- ch</code><br>如果ok为false就表明信道已经关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fabonacci</span> <span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y <span class="comment">// 值得注意，用这个方式就没必要像之前用的那么麻烦。没必要使用中间变量temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fabonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select 语句使一个 Go 程可以等待多个通信操作。</p>
<p>select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fabonacci</span><span class="params">( c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;- quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fabonacci()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当select的其他分支没有准备好时，default分支就会执行。</p>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>Go标准库中提供的sync.Mutex类型实现了lock和unlock两个方法<br>我们可以使用defer方法将unlock指令推迟来实现互斥。</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>博客md图片托管</title>
    <url>/2020/02/05/%E5%8D%9A%E5%AE%A2md%E5%9B%BE%E7%89%87%E6%89%98%E7%AE%A1/</url>
    <content><![CDATA[<p>用github和hexo搭建的博客，有时候markdown里想索引图片，发现博客文件夹中的文件结构和GitHub仓库中的完全不一样，所以难以确定索引路径，之后找到了三种方式：</p>
<a id="more"></a>
<ol>
<li>用github建个仓库专门存放图片</li>
<li>可以在hexo配置文件_config.yml里的post_asset_folder选项设置为true，这样你每次新建一个md文件，就会自动创建一个同名的文件夹用来放资源，索引路径为/assets/文件名</li>
<li>使用图片托管网站，imgur或者别的都行，imgur需要科学上网，我用的是 <a href="https://img.wenhairu.com/" target="_blank" rel="noopener">公众图库</a></li>
</ol>
]]></content>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行与shell脚本编程大全</title>
    <url>/2020/01/28/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>Linux命令行与shell脚本编程大全学习笔记</p>
<a id="more"></a>

<h2 id="基本的shell指令"><a href="#基本的shell指令" class="headerlink" title="基本的shell指令"></a>基本的shell指令</h2><p>tail指令可以检查指令的最后几行，一个有趣的特性是可以使用-f参数，使得其可以在其他进程中使用该指令保持活动状态。<br>用以监视文件的变化</p>
<h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><p><strong>探查进程</strong>：<br>我们一般使用ps指令来探查进程的情况。<br>但是ps实际上十分难以使用，因为它有十分复杂的参数以及多个版本。</p>
<p>ps的缺点之一是只能显示特定时间的进程情况，如果想要实时监测应当使用top指令</p>
<p>如果想结束进程可以使用kill或者killall指令，这两个指令主要是传递信号给进程，进程主要使用信号来传递信息。<br>这两个指令的不同之处为第二个指令不使用进程号而使用进程名来结束所有复合条件的进程。</p>
<p>处理数据文件：<br>sort指令：对于文件进行排序。</p>
<p>grep指令：查找某行数据。egrep, fgrep是类似的版本，功能各有不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep t file1</span><br><span class="line">grep -v t file1 <span class="comment">#反向查询</span></span><br><span class="line">grep -n t file1 <span class="comment">#显示行数</span></span><br><span class="line">grep -c t file1 <span class="comment">#-c只返回匹配的行数，而不返回具体行</span></span><br><span class="line">grep -e t -e f file1 <span class="comment">#-e使用多个匹配模式</span></span><br></pre></td></tr></table></figure>

<p>压缩命令：tar</p>
<p>一行中指定一系列命令，可以通过在每个命令之间加入一个分号实现，但是如果想使用进程列表，则需要在前后加上括号，这样就会产生一个子shell用于执行指令。</p>
<p><code>ps;ls;echo $BASH_SUBSHELL</code><br>最后打印出来的变量值为1，其代表为子shell的层数。</p>
<p>可以使用命令后的一个&amp;号来转入后台运行指令，后台的指令可以使用jobs来查看。</p>
<p>转入后台还可以使用协程执行，即coproc命令，它还可以使用命令的扩展语法指定后台作业的名字。<br><code>coproc My_job { sleep 2; }</code><br>应当注意其中空格都必须存在不能省略。</p>
<h2 id="内建指令"><a href="#内建指令" class="headerlink" title="内建指令"></a>内建指令</h2><p>可以使用type和which找到外部命令的位置。<br>外部命令的执行时，会创建出来一个子进程，这样的过程叫做forking。这样的过程必定要消耗一定的资源。</p>
<p>与之相反的是内建指令就不需要使用子进程来实现，可以使用type指令查看是否为内建指令。</p>
<p>shell也有很多种类型：交互式，非交互式<br>交互式一般指在登陆shell中通过输入bash等指令打开的shell。<br>非交互式一般就是指脚本文件使用的shell。<br>登陆shell会使用/etc/profile文件来设置启动。<br>用户自定义的本地启动文件在用户文件夹下的rc等文件中。</p>
<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>Linux通过用户账户来进行权限的管理。使用UID进行区分。<br>可以在/etc/passwd中看到所有的用户以及相应的UID，其中有很多是为服务提供的账户，并不显示密码，密码另外储存在/etc/shadow文件中，只用特定的程序才能够访问，如登陆程序。</p>
<p>ls命令中，权限展示的第一个指文件类型，后面的每三个字符代表一类用户对于该文件的权限，依次是文件属主权限、属组成员权限、其他用户权限。<br>可以通过umask命令设置默认的文件权限。其中得到的是掩码</p>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h2 id="Linux基本编辑器"><a href="#Linux基本编辑器" class="headerlink" title="Linux基本编辑器"></a>Linux基本编辑器</h2><h2 id="基本shell编程"><a href="#基本shell编程" class="headerlink" title="基本shell编程"></a>基本shell编程</h2><p>命令替换：有两种方式可以从命令中提取信息，并将其赋给变量。</p>
<ol>
<li>反引号字符</li>
<li>$（）格式</li>
</ol>
<p>进行数学计算，可以通过命令替换使用expr指令完成操作，也可以是使用中括号【】。bash中只能使用整数运算，但是zsh（如mac中的shell）可以进行浮点数的相关运算。<br>在bash中进行浮点数运算可以使用bc。其中scale表示小数位数，默认为0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！ /bin/bash</span></span><br><span class="line">var1=`<span class="built_in">echo</span> <span class="string">"scale=4; 3.44 / 5"</span> | bc`</span><br><span class="line"></span><br><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expressions</span><br><span class="line">EOF )</span><br><span class="line"><span class="comment"># 可以使用这样的方式通过重定向完成大量计算过程。</span></span><br></pre></td></tr></table></figure>

<h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><p>表示指令执行状态。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>正常退出</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过ctrl+c终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody></table>
<p>一般来讲，shell脚本会以脚本的最后一个命令的退出状态码退出。<br>可以通过exit n指定命令的退出码为n<br>应当注意的是，<strong>退出状态码最大为255</strong></p>
<h2 id="字段分隔符（IFS）"><a href="#字段分隔符（IFS）" class="headerlink" title="字段分隔符（IFS）"></a>字段分隔符（IFS）</h2><p>一般来讲，默认的字段分隔符为空格、制表符、换行符, 可以通过指定IFS来设置分隔符。<br><code>IFS=$&#39;\n&#39;</code></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>使用getopt解析命令行：<br><code>getopt optstring paramerters</code><br>关键部分在optstring，在其中列出要在脚本中使用的每个命令行选项字母。如果该选项需要参数则使用冒号：。然后getopt就会根据你提供的optstring来解析参数中的命令行参数。可以使用-q来忽略错误消息。</p>
<p>在脚本中使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -- <span class="variable">$&#123;getopt -q ab:cd "$*"&#125;</span></span><br></pre></td></tr></table></figure>

<p>set指令又一个选项是–，作用是使用参数来代替原本的命令行选项。应当注意的是，getopt并不擅长处理带空格和引号的参数值。</p>
<p><strong>使用更高级的getopts</strong>：<br>命令格式为：<code>getopts optstring variable</code><br>其中optstring和上面的类似，可以在命令行选项前面加上：使得忽视错误信息。<br>和上面的不同，getopts每次只处理一个命令行选项，其使用两个环境变量，一个OPYARG保存选项的参数值，而OPTIND保存参数列表中正在处理的参数的位置。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>可以使用exec命令完成对于文件重定向的实现。<br>该命令可以创建文件描述符，并对其进行相应的重定向操作。<br>将描述符重定向至&amp;-以实现对其的关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt; test17file</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is a test line of data"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure>

<p>记录消息可以使用tee，该命令类似一个T型通道，将输入分发至指定文件和标准输出。</p>
<ul>
<li><input disabled="" type="checkbox"> 临时文件</li>
</ul>
<h2 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>脚本可以使用trap命令来捕捉信号，trap的命令格式为：<br><code>trap commands signals</code><br>command位置列出命令，后面跟着需要处理的信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">"echo Goodbye..."</span> EXIT</span><br><span class="line"><span class="comment"># 捕捉退出状态，同样有捕捉ctrl-c的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' Sorry! I have trapped the ctrl-c' "</span> SIGINT</span><br><span class="line"><span class="comment"># 捕捉ctrl+c信号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> -- SIGINT</span><br><span class="line"><span class="comment"># 删除之前设置的捕捉信号</span></span><br></pre></td></tr></table></figure>

<h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>只需要在命令后面加一个&amp;即可。<br>可以使用nohup指令将shell脚本和终端分离，其输入输出在hohup文件中</p>
<p>使用bg或者fg命令重启后台的脚本</p>
<p>使用nice和renice来设置命令的优先级，越高优先级越低。</p>
<h3 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h3><p>可以使用at来定时执行文件，而at的输出十分不方便，通过email进行stdout和stderr。</p>
<p>亦可以使用cron时间表来实现。</p>
<h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>函数输出，可以使用echo输出，见实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func1 &#123;</span><br><span class="line"> <span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value</span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`func1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the new value is: <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure>

<p>这里有一个值得一提的小技巧，注意这里使用了read的一个选项来进行命令行提示，如果这里使用echo则read读取时会将其一起读取至shell变量中。</p>
<p>参数传递：shell会将函数作为小型的脚本处理，这意味着我们可以使用类似脚本处理参数的方式处理参数</p>
<h3 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h3><p>使用库函数等的关键在于sounce命令，其在当前shell的上下文中执行命令，不会创建新的shell，因此可以使用其中定义的函数。<br>其也有一个简单的别名（alias）称作点操作符</p>
<p>可以在shell中直接定义函数<br>或者将其写入bashrc中每次建立shell都会加载。</p>
<p>使用<strong>shtool库函数</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvfoP.jpg" alt="shtool"></p>
<h2 id="图形化脚本编程"><a href="#图形化脚本编程" class="headerlink" title="图形化脚本编程"></a>图形化脚本编程</h2><p>说起来就是使用文字构建出类似的命令行界面。<br>echo -e允许echo指令输出转义字符。</p>
<p>可以使用select命令比较简单的生成菜单。命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">PS3=promt</span><br><span class="line"><span class="comment"># 环境变量PS3显示提示。</span></span><br></pre></td></tr></table></figure>

<p>可以使用dialog包来进行对话框创建。</p>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvYJh.jpg" alt="dialog"></p>
<h2 id="sed、gawk处理文本"><a href="#sed、gawk处理文本" class="headerlink" title="sed、gawk处理文本"></a>sed、gawk处理文本</h2><p>sed是流文本处理工具，和vim等交互式文本处理不同</p>
<table>
<thead>
<tr>
<th>常用选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>按照脚本执行</td>
</tr>
<tr>
<td>-f</td>
<td>从文件中读取命令</td>
</tr>
<tr>
<td>-n</td>
<td>静默模式，不会输出至stdout</td>
</tr>
</tbody></table>
<h3 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h3><p><code>sed &#39;s/test/trail/&#39; data.txt</code><br>s命令是替换命令，会将data文件中每行默认的第一个test替换为trail。<br>在最后一个斜杠之后还可以加上别的选项</p>
<ol>
<li>数字代表替换第几处</li>
<li>g：表示替换所有匹配的位置</li>
<li>p：同时打印原来的文本</li>
<li>w file：表示输出至file</li>
</ol>
<p>sed中可以使用感叹号作为命令中字符串的分隔符</p>
<p>如果想将命令作用于特定的行中，不针对所有行，则需要使用行寻址。可以使用两种方式：</p>
<p>1.数字方式行寻址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'2s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># 应用于第二行</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">'2,4s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># 2-4</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">'2,$s/dog/cat/'</span> data.txt</span><br><span class="line"><span class="comment"># the lines behind No.2</span></span><br></pre></td></tr></table></figure>

<p>2.文本方式<br>/pattern/command 按照pattern进行匹配，对匹配成功的行进行操作，其中模式可以使用正则表达式。</p>
<h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><p>删除命令为d，可以使用上文提到的两种寻址方式来选择删除的行。<br>应当注意模式匹配时需要有开始和结束，不然会出现意外情况。</p>
<h3 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h3><p>插入（i），附加（a），使用寻址来指定操作的行<br>插入会在该行前面，而附加会添加至该行之后。</p>
<h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>修改命令为c，允许修改整行数据 。通上述的命令一样需要指定新的行内容。</p>
<h3 id="转换指令y"><a href="#转换指令y" class="headerlink" title="转换指令y"></a>转换指令y</h3><p>唯一可以操作单个字符的指令。命令格式为：<br><code>[address]y/inchars/outchars/</code></p>
<p>转换指令会对inchars和outchars的值做一对一映射，如果两个字符串的长度不同则会产生一条错误信息。</p>
<p>因此y指令会对文本中所有符合的匹配的数据做映射替换。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>= p两个命令，前者用于打印行号，后者用于打印。同时可以结合-n选项，禁止其他输出，来输出特定匹配选项。</p>
<p>l列出行，可以将不可打印的ascii码等字符打印出来。</p>
<p>r，w：读写指令，可以完成数据流和文件的交互操作。</p>
<h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><p>就目前为止我们学习的sed命令都是只处理数据行的一行，我们可以使用下面三个命令来处理多行数据：</p>
<ol>
<li>N：将数据流中下一行加进来形成一个多行组</li>
<li>D：删除多行组中的一行</li>
<li>P：打印多行组中的一行</li>
</ol>
<p><strong>next命令</strong>：单行模式中使用小写n来表示next命令，单行模式中使用n命令会继续执行之后的命令而不是将命令从头到尾再执行一遍。<br>而多行模式有所不同，它会将下面的一行加入到当前的匹配模式中。</p>
<p><strong>gawk</strong><br>gawk提供一个类编程环境来修改和重新组织文件中的数据<br>gawk是awk的gnu版本，它提供了一种新的编程语言而不是简单的编辑器命令</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-F fs</td>
<td>指定行中的字段分隔符</td>
</tr>
<tr>
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr>
<td>-v var=value</td>
<td>定义一个变量和默认值</td>
</tr>
<tr>
<td>-mf N</td>
<td>定义要处理文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr>
<td>-W keyword</td>
<td>指定兼容模式或者警告等级</td>
</tr>
</tbody></table>
<p>gawk会自动的为文本文件中的数据分配为变量，其中：</p>
<ol>
<li>$0 表示整个文本行</li>
<li>$1 表示第一个数据字段</li>
<li>$n 表示第n个数据字段</li>
</ol>
<p>可以通过BEGIN来指定程序在读取数据前运行脚本内容，类似的也有END</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一般Linux支持两种正则表达式类型：BRE（基本），ERE（拓展）</p>
<p><strong>锚字符</strong>：默认情况下，正则表达式可以匹配整行的内容，如果想锁定在行首或者行尾匹配，则需要锚字符锁定位置</p>
<p>锁定在行首：^,通过使用该字符可以使其匹配锁定在行首，需要放在模式最前面<br>锁定在行尾：$，需要放在模式的最后面</p>
<p><strong>点号字符</strong>：代表换行符以外任意一个字符。<br><strong>字符组</strong>：中括号将需要匹配的一个数据组放在其中。可以在字符组中使用^符号表示匹配除了字符组给出的字符的模式</p>
<p><strong>特殊字符组：</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvFzu.jpg" alt="特殊字符组示例"></p>
<p><strong>星号</strong>：字符后面放置星号表示该字符出现0次或者多次，可以和字符组组合起来使用</p>
<h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>以下为ERE模式的正则表达式部分，sed只支持BRE而gawk支持大部分ERE因此比sed要慢一些</p>
<p><strong>问号（ ？）</strong>：类似于星号，但是问号只表示出现0或者1次，仅此而已<br><strong>加号（ + ）</strong>：是星号的另一个模式，表示出现一次或者多次，但是至少一次。<br><strong>花括号（{})</strong>：表示允许可重复正则表达式的上限。m为准确出现m次；m，n为至少m次，至多n次<br>默认情况下gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval选项才可以。</p>
<p><strong>管道符号（｜）</strong>：使用or方式指定多个模式<br><strong>表达式分组（（））</strong>：正则表达式模式可以使用圆括号进行分组，该组会被视为一个标准字符，可以一样给该组使用特殊字符。</p>
<h2 id="zsh简介"><a href="#zsh简介" class="headerlink" title="zsh简介"></a>zsh简介</h2><p>zsh是一个开源的shell，其最值得称道的是具有加载命令模块的功能，即可以通过这种方式添加内建指令。</p>
<p>zsh是shell中可定制性最强的，可以通过不同的选项定制需要的shell</p>
<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><p>通过zmodload管理zsh的模块。</p>
<p>没有任何参数的zmodload指令显示已经加载了的模块，如果需要安装则直接在后面跟上模块名，没有任何输出则表示已经加载完成。删除则是使用-u选项。</p>
<blockquote>
<p>通常会将zmodload指令放在zshrc文件中，这样每次打开可以自动加载需要的内容。<br>实测发现加载模块的命令不是一直有效的，退出后则重置所以需要写入zshrc文件中</p>
</blockquote>
<p>可以使用<strong>man zshmodules</strong>命令查看各个模块的内容</p>
<p>zsh提过更加全面的数学操作，其可以使用浮点数运算。<br>有两种方式：let命令或者双圆括号</p>
<ol>
<li><code>let values=&quot; 4 * 1.8 &quot;</code></li>
<li><code>values=$(( 4 * 1.8 ))</code></li>
</ol>
<p>如果一开始没有指定变量的类型，就会导致一些出乎意料的效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">value=10</span><br><span class="line">value2=$(( <span class="variable">$value</span> / 3 ))</span><br><span class="line"><span class="comment"># value2=3</span></span><br><span class="line"></span><br><span class="line">value=10.</span><br><span class="line">value2=$(( <span class="variable">$value</span> / 3 ))</span><br><span class="line"><span class="comment"># value2=3.33333333</span></span><br></pre></td></tr></table></figure>

<p>zsh中数学函数可以通过加载mathfunc库实现，加载之后就可以使用整个数学函数库。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>shell的学习到这里就差不多了，这本书我感觉更像是一本工具书，过年期间有些东西看的也不是很细。</p>
<ul>
<li><input disabled="" type="checkbox"> sed，gawk进阶部分</li>
<li><input disabled="" type="checkbox"> exec重定向</li>
</ul>
<p>以上的部分没有怎么看，之后有用到在回来看一下。<br>个人认为shell还是得多写，同一个功能在shell中可能有很多的选择可以实现，这本书就作为一本🔧书常备着就好了。</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell learning</title>
    <url>/2020/01/23/Shell-learning/</url>
    <content><![CDATA[<h1 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title="shell学习笔记"></a>shell学习笔记</h1><blockquote>
<p><a href="https://www.runoob.com/linux/linux-shell-passing-arguments.html" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>shell本身是用户访问内核的桥梁，所谓的shell学习，实际上是学习shell脚本。</p>
<p>和大多数脚本语言一样，shell只需要一个编辑器和一个解释器就可以了，常见的shell解释器种类众多，有sh、bash、zsh等，我们本次学习bash脚本。</p>
<a id="more"></a>

<p>第一个shell脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure>

<p>其中第一行告诉系统使用什么解释器来解释shell脚本。</p>
<p>运行shell的方法：</p>
<ol>
<li>作为可执行程序</li>
<li>作为命令解释器的参数</li>
</ol>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>定义变量时不需要加美元符号，如：<br><code>my_name=&quot;lyhhhhh&quot;</code></p>
<p>命名规则：</p>
<ol>
<li>只能使用英文，不能以数字开头</li>
<li>中间不可以有空格，可以使用下划线</li>
<li>不能使用标点</li>
<li>注意不能使用保留关键字</li>
</ol>
<p>使用一个定义过的变量，只需要变量名加美元符号即可，而变量名外面的花括号是可选的，添加是为了方便区分界限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_name=<span class="string">'lyhhhhh'</span></span><br><span class="line"><span class="comment">#the ways below are both valid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以使用readonly命令将变量声明为只读变量<br>也可以使用unset命令将变量删除，之后就无法使用，unset命令不能使用在readonly变量上</p>
<p><strong>变量的类型：</strong></p>
<ol>
<li>局部变量： 局部变量在脚本中定义，只在当前shell实例中有效</li>
<li>环境变量： 属于系统定义的变量，所有的程序和shell都可以访问</li>
<li>shell变量： 是shell程序设置的特殊变量，一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>字符串是shell中最经常使用的类型，实际上在shell中除了字符串和数字也没啥可以用的了。</p>
<p>字符串分为单引号和双引号两种，两者的区别在于单引号字符串的内容即为引号中的内容，如果里面有对变量的引用是无效的。<br>而双引号中可以存在转义字符和变量等可以解释的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">greeting_2=<span class="string">'hello, '</span><span class="variable">$your_name</span><span class="string">' !'</span></span><br><span class="line">greeting_3=<span class="string">'hello, $&#123;your_name&#125; !'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, <span class="variable">$&#123;your_name&#125;</span> !</span><br></pre></td></tr></table></figure>

<p><strong>shell中的字符串存在一些可以使用的操作：</strong></p>
<ol>
<li>获取字符串长度：在字符串前添加#</li>
<li>提取子字符串：${str:begin_index:num} 形如前式，其中beginindex为起始索引（起始为0），num为字符数量。</li>
<li>查找子字符串：见下面例子，注意使用的是反引号而不是单引号</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">'hello, world'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#output: 4, calculate the length of the string</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:3&#125;</span> <span class="comment">#output: ell, substring</span></span><br><span class="line"><span class="built_in">echo</span> `exper index <span class="string">"<span class="variable">$string</span>"</span> ol`</span><br><span class="line"><span class="comment"># 输出o和l在字符串中的位置，那个先出现就输出哪个，注意是反引号而不是单引号。</span></span><br></pre></td></tr></table></figure>

<h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>bash支持一维数组而不支持多维数组，类似于c语言，数组元素下标从0开始，可以是表达式，但是需要值合法。</p>
<p>shell中使用括号表示数组，使用空格将数组元素分开。<br>也可以单个定义数组各个元素，下标可以不连续。</p>
<p>获取数组长度与获取字符串长度类似，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"><span class="comment"># get the num of the array</span></span><br><span class="line">length=<span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="comment"># same as the way given above</span></span><br><span class="line"></span><br><span class="line">length=<span class="variable">$&#123;#array[n]&#125;</span></span><br><span class="line"><span class="comment"># get the length of the array[n]</span></span><br></pre></td></tr></table></figure>

<h3 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h3><p>单行注释通过#来实现。<br>多行注释可以使用每行都添加#或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<p>其中！可以被其他标志代替。</p>
<h2 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h2><p>在执行脚本时我们可以通过命令行为脚本附加参数，调用这些参数的规则如$n，n=0表示的是脚本文件名，1、2、3···以此类推为第一第二个参数</p>
<p>另外还有几个特殊的参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>将所有参数合并到一个字符输出</td>
</tr>
<tr>
<td>$$</td>
<td>脚本当前运行进程的id</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的id</td>
</tr>
<tr>
<td>$@</td>
<td>与第二个类似，不过是以多个字符串组合的形式</td>
</tr>
<tr>
<td>$-</td>
<td>显示shell使用的当前选项，和set命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>现实最后命令的退出状态，0为没有错误</td>
</tr>
</tbody></table>
<p>$*和$@区别：只有在双括号中才能显现出来，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>output:<br>1 2 3</p>
<p>1<br>2<br>3</p>
<h2 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h2><p>shell和其他语言一样支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>后两者比较有趣，后面会详细介绍</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算只能对于数字，不能适用于字符串，除非字符串全部由数字构成。</p>
<p>原生的bash不支持简单的数学运算，需要通过其他的命令来实现，比如awk和expr，其中expr最常用，expr是一款表达式计算工具，可以完成表达式确知操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the sum of two nums: <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure>

<p>应当注意的是，表达式中的运算符和数字之间应当有空格，这和我们大多数的习惯不同。</p>
<p>常用的算数运算符和C语言类似，即加减乘除、取余等</p>
<p><strong>注意</strong>：乘号前面需要加\转义</p>
<h3 id="shell中-的使用方式"><a href="#shell中-的使用方式" class="headerlink" title="shell中[]的使用方式"></a>shell中[]的使用方式</h3><p><strong>[]在shell中作为测试语句说明</strong><br>比如算术比较、文件属性比较、字符串比较等</p>
<p>使用算术比较举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，【】和比较的元素之间需要使用空格隔开。除了使用==、！=等C语言类似的算术比较之外，我们还可以使用-eq这样的比较运算符。例如，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"var=0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var1</span> -eq 0 -a <span class="variable">$var2</span> -gt 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>常用的运算符如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-gt</td>
<td>greater than</td>
</tr>
<tr>
<td>-lt</td>
<td>less than</td>
</tr>
<tr>
<td>-ge</td>
<td>greater and equal</td>
</tr>
<tr>
<td>-lt</td>
<td>less and equal</td>
</tr>
<tr>
<td>-ne</td>
<td>not equal</td>
</tr>
<tr>
<td>-a, -o</td>
<td>and or（用于结合多个判断操作）</td>
</tr>
</tbody></table>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>同c等类似，逻辑运算无非就是 ｜｜ 和 &amp;&amp;<br>需要注意的是，一旦使用逻辑运算，最好使用双中括号，不然可能出现错误，这在字符串运算中也是类似的。</p>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>判断运算符是否相等，返回true或者false</td>
</tr>
<tr>
<td>！=</td>
<td>判断运算符是否不等</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0为true</td>
</tr>
<tr>
<td>-n</td>
<td>功能同上，返回值相反。</td>
</tr>
<tr>
<td>$</td>
<td>检测是否为空，不为空则true</td>
</tr>
</tbody></table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>用于测试Unix文件属性</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r、-w、-x</td>
<td>测试文件是否可读可写可执行</td>
</tr>
<tr>
<td>-c、-b</td>
<td>测试是否为字符或者块设备文件</td>
</tr>
<tr>
<td>-d</td>
<td>测试是否为目录</td>
</tr>
<tr>
<td>-e</td>
<td>测试文件（目录）是否存在</td>
</tr>
<tr>
<td>-s</td>
<td>测试是否为空，不为空返回true</td>
</tr>
</tbody></table>
<h2 id="shell中的printf"><a href="#shell中的printf" class="headerlink" title="shell中的printf"></a>shell中的printf</h2><p>和c语言基本一致，除了不需要括号以外，应当注意的是当参数比规格化字符串多时，会按照该格式将多出的参数全部输出</p>
<p><code>printf &quot;%s %s %s\n&quot; a b c d e f g h i j</code></p>
<p>输出为：<br>a b c<br>d e f<br>g h i<br>j</p>
<p>转义字符等和c语言一致</p>
<h2 id="shell-test"><a href="#shell-test" class="headerlink" title="shell test"></a>shell test</h2><p>test指令实际上和上文中提到的[]功能一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># they are same</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$a</span> == <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line">result=$[a+b]</span><br><span class="line"><span class="comment">#the[], is used to calculate the result.</span></span><br></pre></td></tr></table></figure>

<p>应当注意后面的情况，此时中括号用于计算结果。</p>
<h2 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h2><p>shell中不能存在没有指令的分支，如果该分支无事可做则不写出来.</p>
<h3 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a>if-else分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition; <span class="keyword">then</span> <span class="built_in">command</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>上式中两种写法均可。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>shell中提供的for循环是for-in循环<br>变量值存在in列表中，for循环则执行一次所有内容。</p>
<p>shell中还有类似c语言的循环格式，形似下面给出的代码段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));<span class="keyword">do</span></span><br><span class="line">    command1;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，一般来讲shell中变量的调用是要使用$的，但是在for循环中并不需要。如果对于变量的更改是在函数体中，则需要加美元符号</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello, input is: <span class="variable">$FILM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>其中使用了shell let指令，用于执行一个或者多个表达式，不需要使用美元符号。</p>
<blockquote>
<p>let 是shell中用于计算的表达式不需要时使用美元符号，如果表达式中存在空格或者其他字符则需要引用起来。</p>
</blockquote>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> value <span class="keyword">in</span></span><br><span class="line">val1)</span><br><span class="line">    command1</span><br><span class="line">    ;;</span><br><span class="line">val2)</span><br><span class="line">    command2</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>linux shell中可以定义函数，然后在脚本中可以调用。</p>
<p>函数形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] func_name ()</span><br><span class="line">&#123;</span><br><span class="line">    command1</span><br><span class="line"></span><br><span class="line">    [ <span class="built_in">return</span> int; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中【】表示可选项，即函数可以不使用function定义或者没有返回值。<br>函数的返回值可以使用$?调用<br><strong>注意</strong>：由于shell执行顺序是依次执行的，因此函数定义必须在使用之前。而且$?只对上一条指令负责。</p>
<p>函数参数传递形式和shell脚本一样，然后通过美元符号加数字调用。</p>
<p>函数与指令的执行结果可以作为条件语句使用，<strong>要注意的是，和c语言不同该，0在shell中是true，其他为false</strong></p>
<h2 id="shell文件重定向"><a href="#shell文件重定向" class="headerlink" title="shell文件重定向"></a>shell文件重定向</h2><p>重定向指令列表：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将输出重定向之file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向至file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出追加至file</td>
</tr>
<tr>
<td>n &gt; file</td>
<td>将文件描述符为n的文件重定向至file</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td>将文件描述符为n的文件追加到file</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件m和n合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件m与n合并</td>
</tr>
<tr>
<td>&lt;&lt;tag</td>
<td>将开始标记和结束标记之间等我内容作为输入</td>
</tr>
</tbody></table>
<p><code>command1 &lt; infile &gt; outfile</code><br>此命令将命令的输入输出全部替换了</p>
<p><strong>⚠️注意：0通常是标准输入，1是标准输出，2是标准错误输出</strong></p>
<p><code>command &gt; file 2&gt;&amp;1</code><br>可以将stdout和stderr都重定向至file</p>
<p>Here Document<br>是一种特殊的重定向方式，用于将输入重定向到一个交互式脚本或者程序中。<br>基本格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt; tag</span><br><span class="line">    document</span><br><span class="line">tag</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>结尾的tag应当顶格写，前后都不能有任何字符</li>
<li>开始的tag前后的空格会被忽略。</li>
</ul>
<p>如果执行某指令不希望有任何输出可以将输出重定向至/dev/null，这是一个特殊文件，重定向至它的所有内容都会被丢弃。</p>
<h2 id="shell外部调用"><a href="#shell外部调用" class="headerlink" title="shell外部调用"></a>shell外部调用</h2><p>shell中也可以包含外部脚本，这样就可以封装一些常用的公用脚本作为独立文件。<br>常用的调用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. filename</span><br><span class="line"><span class="comment"># otherwise</span></span><br><span class="line"><span class="built_in">source</span> filename</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>被调用的文件可以不需要可执行权限</li>
<li>path中不包含当前路径则需要写出。/filename</li>
</ol>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog</title>
    <url>/2020/01/23/My-first-blog/</url>
    <content><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>费了不少功夫才把这个博客搭好</p>
<p>虽然大部分是按照前人走过的路来搞得，但是也需要自己去摸索一些东西</p>
<p>很早就想有这样一个平台来记录自己的学习过程了，想通过这样一点一滴的记录看到自己的成长</p>
<p>这样才有动力去向着996的生活进发，hhhhhhhhhh</p>
<p>加油，奥力给！！！</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
