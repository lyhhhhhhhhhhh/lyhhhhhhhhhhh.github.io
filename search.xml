<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux命令行与shell脚本编程大全</title>
    <url>/2020/01/28/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Linux命令行与shell脚本编程"><a href="#Linux命令行与shell脚本编程" class="headerlink" title="Linux命令行与shell脚本编程"></a>Linux命令行与shell脚本编程</h1><a id="more"></a>

<h2 id="基本的shell指令"><a href="#基本的shell指令" class="headerlink" title="基本的shell指令"></a>基本的shell指令</h2><p>tail指令可以检查指令的最后几行，一个有趣的特性是可以使用-f参数，使得其可以在其他进程中使用该指令保持活动状态。<br>用以监视文件的变化</p>
<h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><p><strong>探查进程</strong>：<br>我们一般使用ps指令来探查进程的情况。<br>但是ps实际上十分难以使用，因为它有十分复杂的参数以及多个版本。</p>
<p>ps的缺点之一是只能显示特定时间的进程情况，如果想要实时监测应当使用top指令</p>
<p>如果想结束进程可以使用kill或者killall指令，这两个指令主要是传递信号给进程，进程主要使用信号来传递信息。<br>这两个指令的不同之处为第二个指令不使用进程号而使用进程名来结束所有复合条件的进程。</p>
<p>处理数据文件：<br>sort指令：对于文件进行排序。</p>
<p>grep指令：查找某行数据。egrep, fgrep是类似的版本，功能各有不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep t file1</span><br><span class="line">grep -v t file1 <span class="comment">#反向查询</span></span><br><span class="line">grep -n t file1 <span class="comment">#显示行数</span></span><br><span class="line">grep -c t file1 <span class="comment">#-c只返回匹配的行数，而不返回具体行</span></span><br><span class="line">grep -e t -e f file1 <span class="comment">#-e使用多个匹配模式</span></span><br></pre></td></tr></table></figure>

<p>压缩命令：tar</p>
<p>一行中指定一系列命令，可以通过在每个命令之间加入一个分号实现，但是如果想使用进程列表，则需要在前后加上括号，这样就会产生一个子shell用于执行指令。</p>
<p><code>ps;ls;echo $BASH_SUBSHELL</code><br>最后打印出来的变量值为1，其代表为子shell的层数。</p>
<p>可以使用命令后的一个&amp;号来转入后台运行指令，后台的指令可以使用jobs来查看。</p>
<p>转入后台还可以使用协程执行，即coproc命令，它还可以使用命令的扩展语法指定后台作业的名字。<br><code>coproc My_job { sleep 2; }</code><br>应当注意其中空格都必须存在不能省略。</p>
<h2 id="内建指令"><a href="#内建指令" class="headerlink" title="内建指令"></a>内建指令</h2><p>可以使用type和which找到外部命令的位置。<br>外部命令的执行时，会创建出来一个子进程，这样的过程叫做forking。这样的过程必定要消耗一定的资源。</p>
<p>与之相反的是内建指令就不需要使用子进程来实现，可以使用type指令查看是否为内建指令。</p>
<p>shell也有很多种类型：交互式，非交互式<br>交互式一般指在登陆shell中通过输入bash等指令打开的shell。<br>非交互式一般就是指脚本文件使用的shell。<br>登陆shell会使用/etc/profile文件来设置启动。<br>用户自定义的本地启动文件在用户文件夹下的rc等文件中。</p>
<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>Linux通过用户账户来进行权限的管理。使用UID进行区分。<br>可以在/etc/passwd中看到所有的用户以及相应的UID，其中有很多是为服务提供的账户，并不显示密码，密码另外储存在/etc/shadow文件中，只用特定的程序才能够访问，如登陆程序。</p>
<p>ls命令中，权限展示的第一个指文件类型，后面的每三个字符代表一类用户对于该文件的权限，依次是文件属主权限、属组成员权限、其他用户权限。<br>可以通过umask命令设置默认的文件权限。其中得到的是掩码</p>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h2 id="Linux基本编辑器"><a href="#Linux基本编辑器" class="headerlink" title="Linux基本编辑器"></a>Linux基本编辑器</h2><h2 id="基本shell编程"><a href="#基本shell编程" class="headerlink" title="基本shell编程"></a>基本shell编程</h2><p>命令替换：有两种方式可以从命令中提取信息，并将其赋给变量。</p>
<ol>
<li>反引号字符</li>
<li>$（）格式</li>
</ol>
<p>进行数学计算，可以通过命令替换使用expr指令完成操作，也可以是使用中括号【】。bash中只能使用整数运算，但是zsh（如mac中的shell）可以进行浮点数的相关运算。<br>在bash中进行浮点数运算可以使用bc。其中scale表示小数位数，默认为0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！ /bin/bash</span></span><br><span class="line">var1=`<span class="built_in">echo</span> <span class="string">"scale=4; 3.44 / 5"</span> | bc`</span><br><span class="line"></span><br><span class="line">variable=$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expressions</span><br><span class="line">EOF )</span><br><span class="line"><span class="comment"># 可以使用这样的方式通过重定向完成大量计算过程。</span></span><br></pre></td></tr></table></figure>

<h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><p>表示指令执行状态。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>正常退出</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过ctrl+c终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody></table>
<p>一般来讲，shell脚本会以脚本的最后一个命令的退出状态码退出。<br>可以通过exit n指定命令的退出码为n<br>应当注意的是，<strong>退出状态码最大为255</strong></p>
<h2 id="字段分隔符（IFS）"><a href="#字段分隔符（IFS）" class="headerlink" title="字段分隔符（IFS）"></a>字段分隔符（IFS）</h2><p>一般来讲，默认的字段分隔符为空格、制表符、换行符, 可以通过指定IFS来设置分隔符。<br><code>IFS=$&#39;\n&#39;</code></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>使用getopt解析命令行：<br><code>getopt optstring paramerters</code><br>关键部分在optstring，在其中列出要在脚本中使用的每个命令行选项字母。如果该选项需要参数则使用冒号：。然后getopt就会根据你提供的optstring来解析参数中的命令行参数。可以使用-q来忽略错误消息。</p>
<p>在脚本中使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -- <span class="variable">$&#123;getopt -q ab:cd "$*"&#125;</span></span><br></pre></td></tr></table></figure>

<p>set指令又一个选项是–，作用是使用参数来代替原本的命令行选项。应当注意的是，getopt并不擅长处理带空格和引号的参数值。</p>
<p><strong>使用更高级的getopts</strong>：<br>命令格式为：<code>getopts optstring variable</code><br>其中optstring和上面的类似，可以在命令行选项前面加上：使得忽视错误信息。<br>和上面的不同，getopts每次只处理一个命令行选项，其使用两个环境变量，一个OPYARG保存选项的参数值，而OPTIND保存参数列表中正在处理的参数的位置。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>可以使用exec命令完成对于文件重定向的实现。<br>该命令可以创建文件描述符，并对其进行相应的重定向操作。<br>将描述符重定向至&amp;-以实现对其的关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt; test17file</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This is a test line of data"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure>

<p>记录消息可以使用tee，该命令类似一个T型通道，将输入分发至指定文件和标准输出。</p>
<ul>
<li><input disabled="" type="checkbox"> 临时文件</li>
</ul>
<h2 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>脚本可以使用trap命令来捕捉信号，trap的命令格式为：<br><code>trap commands signals</code><br>command位置列出命令，后面跟着需要处理的信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">"echo Goodbye..."</span> EXIT</span><br><span class="line"><span class="comment"># 捕捉退出状态，同样有捕捉ctrl-c的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo ' Sorry! I have trapped the ctrl-c' "</span> SIGINT</span><br><span class="line"><span class="comment"># 捕捉ctrl+c信号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> -- SIGINT</span><br><span class="line"><span class="comment"># 删除之前设置的捕捉信号</span></span><br></pre></td></tr></table></figure>

<h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>只需要在命令后面加一个&amp;即可。<br>可以使用nohup指令将shell脚本和终端分离，其输入输出在hohup文件中</p>
<p>使用bg或者fg命令重启后台的脚本</p>
<p>使用nice和renice来设置命令的优先级，越高优先级越低。</p>
<h3 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h3><p>可以使用at来定时执行文件，而at的输出十分不方便，通过email进行stdout和stderr。</p>
<p>亦可以使用cron时间表来实现。</p>
<h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>函数输出，可以使用echo输出，见实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func1 &#123;</span><br><span class="line"> <span class="built_in">read</span> -p <span class="string">"Enter a value: "</span> value</span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result=`func1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the new value is: <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure>

<p>这里有一个值得一提的小技巧，注意这里使用了read的一个选项来进行命令行提示，如果这里使用echo则read读取时会将其一起读取至shell变量中。</p>
<p>参数传递：shell会将函数作为小型的脚本处理，这意味着我们可以使用类似脚本处理参数的方式处理参数</p>
<h3 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h3><p>使用库函数等的关键在于sounce命令，其在当前shell的上下文中执行命令，不会创建新的shell，因此可以使用其中定义的函数。<br>其也有一个简单的别名（alias）称作点操作符</p>
<p>可以在shell中直接定义函数<br>或者将其写入bashrc中每次建立shell都会加载。</p>
<p>使用<strong>shtool库函数</strong></p>
<p><img src="/assets/Jietu20200202-161711@2x.jpg" alt="Jietu20200202-161711@2x"></p>
<h2 id="图形化脚本编程"><a href="#图形化脚本编程" class="headerlink" title="图形化脚本编程"></a>图形化脚本编程</h2><p>说起来就是使用文字构建出类似的命令行界面。<br>echo -e允许echo指令输出转义字符。</p>
<p>可以使用select命令比较简单的生成菜单。命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">PS3=promt</span><br><span class="line"><span class="comment"># 环境变量PS3显示提示。</span></span><br></pre></td></tr></table></figure>

<p>可以使用</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell learning</title>
    <url>/2020/01/23/Shell-learning/</url>
    <content><![CDATA[<h1 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title="shell学习笔记"></a>shell学习笔记</h1><blockquote>
<p><a href="https://www.runoob.com/linux/linux-shell-passing-arguments.html" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>shell本身是用户访问内核的桥梁，所谓的shell学习，实际上是学习shell脚本。</p>
<p>和大多数脚本语言一样，shell只需要一个编辑器和一个解释器就可以了，常见的shell解释器种类众多，有sh、bash、zsh等，我们本次学习bash脚本。</p>
<a id="more"></a>

<p>第一个shell脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello, world!"</span></span><br></pre></td></tr></table></figure>

<p>其中第一行告诉系统使用什么解释器来解释shell脚本。</p>
<p>运行shell的方法：</p>
<ol>
<li>作为可执行程序</li>
<li>作为命令解释器的参数</li>
</ol>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>定义变量时不需要加美元符号，如：<br><code>my_name=&quot;lyhhhhh&quot;</code></p>
<p>命名规则：</p>
<ol>
<li>只能使用英文，不能以数字开头</li>
<li>中间不可以有空格，可以使用下划线</li>
<li>不能使用标点</li>
<li>注意不能使用保留关键字</li>
</ol>
<p>使用一个定义过的变量，只需要变量名加美元符号即可，而变量名外面的花括号是可选的，添加是为了方便区分界限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my_name=<span class="string">'lyhhhhh'</span></span><br><span class="line"><span class="comment">#the ways below are both valid</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以使用readonly命令将变量声明为只读变量<br>也可以使用unset命令将变量删除，之后就无法使用，unset命令不能使用在readonly变量上</p>
<p><strong>变量的类型：</strong></p>
<ol>
<li>局部变量： 局部变量在脚本中定义，只在当前shell实例中有效</li>
<li>环境变量： 属于系统定义的变量，所有的程序和shell都可以访问</li>
<li>shell变量： 是shell程序设置的特殊变量，一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>字符串是shell中最经常使用的类型，实际上在shell中除了字符串和数字也没啥可以用的了。</p>
<p>字符串分为单引号和双引号两种，两者的区别在于单引号字符串的内容即为引号中的内容，如果里面有对变量的引用是无效的。<br>而双引号中可以存在转义字符和变量等可以解释的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">greeting_2=<span class="string">'hello, '</span><span class="variable">$your_name</span><span class="string">' !'</span></span><br><span class="line">greeting_3=<span class="string">'hello, $&#123;your_name&#125; !'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, <span class="variable">$&#123;your_name&#125;</span> !</span><br></pre></td></tr></table></figure>

<p><strong>shell中的字符串存在一些可以使用的操作：</strong></p>
<ol>
<li>获取字符串长度：在字符串前添加#</li>
<li>提取子字符串：${str:begin_index:num} 形如前式，其中beginindex为起始索引（起始为0），num为字符数量。</li>
<li>查找子字符串：见下面例子，注意使用的是反引号而不是单引号</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">'hello, world'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#output: 4, calculate the length of the string</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:3&#125;</span> <span class="comment">#output: ell, substring</span></span><br><span class="line"><span class="built_in">echo</span> `exper index <span class="string">"<span class="variable">$string</span>"</span> ol`</span><br><span class="line"><span class="comment"># 输出o和l在字符串中的位置，那个先出现就输出哪个，注意是反引号而不是单引号。</span></span><br></pre></td></tr></table></figure>

<h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>bash支持一维数组而不支持多维数组，类似于c语言，数组元素下标从0开始，可以是表达式，但是需要值合法。</p>
<p>shell中使用括号表示数组，使用空格将数组元素分开。<br>也可以单个定义数组各个元素，下标可以不连续。</p>
<p>获取数组长度与获取字符串长度类似，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"><span class="comment"># get the num of the array</span></span><br><span class="line">length=<span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="comment"># same as the way given above</span></span><br><span class="line"></span><br><span class="line">length=<span class="variable">$&#123;#array[n]&#125;</span></span><br><span class="line"><span class="comment"># get the length of the array[n]</span></span><br></pre></td></tr></table></figure>

<h3 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h3><p>单行注释通过#来实现。<br>多行注释可以使用每行都添加#或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<p>其中！可以被其他标志代替。</p>
<h2 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h2><p>在执行脚本时我们可以通过命令行为脚本附加参数，调用这些参数的规则如$n，n=0表示的是脚本文件名，1、2、3···以此类推为第一第二个参数</p>
<p>另外还有几个特殊的参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>将所有参数合并到一个字符输出</td>
</tr>
<tr>
<td>$$</td>
<td>脚本当前运行进程的id</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的id</td>
</tr>
<tr>
<td>$@</td>
<td>与第二个类似，不过是以多个字符串组合的形式</td>
</tr>
<tr>
<td>$-</td>
<td>显示shell使用的当前选项，和set命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>现实最后命令的退出状态，0为没有错误</td>
</tr>
</tbody></table>
<p>$*和$@区别：只有在双括号中才能显现出来，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>output:<br>1 2 3</p>
<p>1<br>2<br>3</p>
<h2 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h2><p>shell和其他语言一样支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>后两者比较有趣，后面会详细介绍</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算只能对于数字，不能适用于字符串，除非字符串全部由数字构成。</p>
<p>原生的bash不支持简单的数学运算，需要通过其他的命令来实现，比如awk和expr，其中expr最常用，expr是一款表达式计算工具，可以完成表达式确知操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"the sum of two nums: <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure>

<p>应当注意的是，表达式中的运算符和数字之间应当有空格，这和我们大多数的习惯不同。</p>
<p>常用的算数运算符和C语言类似，即加减乘除、取余等</p>
<p><strong>注意</strong>：乘号前面需要加\转义</p>
<h3 id="shell中-的使用方式"><a href="#shell中-的使用方式" class="headerlink" title="shell中[]的使用方式"></a>shell中[]的使用方式</h3><p><strong>[]在shell中作为测试语句说明</strong><br>比如算术比较、文件属性比较、字符串比较等</p>
<p>使用算术比较举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"equal"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，【】和比较的元素之间需要使用空格隔开。除了使用==、！=等C语言类似的算术比较之外，我们还可以使用-eq这样的比较运算符。例如，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"var=0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$var1</span> -eq 0 -a <span class="variable">$var2</span> -gt 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>常用的运算符如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-gt</td>
<td>greater than</td>
</tr>
<tr>
<td>-lt</td>
<td>less than</td>
</tr>
<tr>
<td>-ge</td>
<td>greater and equal</td>
</tr>
<tr>
<td>-lt</td>
<td>less and equal</td>
</tr>
<tr>
<td>-ne</td>
<td>not equal</td>
</tr>
<tr>
<td>-a, -o</td>
<td>and or（用于结合多个判断操作）</td>
</tr>
</tbody></table>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>同c等类似，逻辑运算无非就是 ｜｜ 和 &amp;&amp;<br>需要注意的是，一旦使用逻辑运算，最好使用双中括号，不然可能出现错误，这在字符串运算中也是类似的。</p>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>判断运算符是否相等，返回true或者false</td>
</tr>
<tr>
<td>！=</td>
<td>判断运算符是否不等</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0为true</td>
</tr>
<tr>
<td>-n</td>
<td>功能同上，返回值相反。</td>
</tr>
<tr>
<td>$</td>
<td>检测是否为空，不为空则true</td>
</tr>
</tbody></table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>用于测试Unix文件属性</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r、-w、-x</td>
<td>测试文件是否可读可写可执行</td>
</tr>
<tr>
<td>-c、-b</td>
<td>测试是否为字符或者块设备文件</td>
</tr>
<tr>
<td>-d</td>
<td>测试是否为目录</td>
</tr>
<tr>
<td>-e</td>
<td>测试文件（目录）是否存在</td>
</tr>
<tr>
<td>-s</td>
<td>测试是否为空，不为空返回true</td>
</tr>
</tbody></table>
<h2 id="shell中的printf"><a href="#shell中的printf" class="headerlink" title="shell中的printf"></a>shell中的printf</h2><p>和c语言基本一致，除了不需要括号以外，应当注意的是当参数比规格化字符串多时，会按照该格式将多出的参数全部输出</p>
<p><code>printf &quot;%s %s %s\n&quot; a b c d e f g h i j</code></p>
<p>输出为：<br>a b c<br>d e f<br>g h i<br>j</p>
<p>转义字符等和c语言一致</p>
<h2 id="shell-test"><a href="#shell-test" class="headerlink" title="shell test"></a>shell test</h2><p>test指令实际上和上文中提到的[]功能一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># they are same</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$a</span> == <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line">result=$[a+b]</span><br><span class="line"><span class="comment">#the[], is used to calculate the result.</span></span><br></pre></td></tr></table></figure>

<p>应当注意后面的情况，此时中括号用于计算结果。</p>
<h2 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h2><p>shell中不能存在没有指令的分支，如果该分支无事可做则不写出来.</p>
<h3 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a>if-else分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition; <span class="keyword">then</span> <span class="built_in">command</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>上式中两种写法均可。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>shell中提供的for循环是for-in循环<br>变量值存在in列表中，for循环则执行一次所有内容。</p>
<p>shell中还有类似c语言的循环格式，形似下面给出的代码段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=1;i&lt;=5;i++));<span class="keyword">do</span></span><br><span class="line">    command1;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，一般来讲shell中变量的调用是要使用$的，但是在for循环中并不需要。如果对于变量的更改是在函数体中，则需要加美元符号</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello, input is: <span class="variable">$FILM</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>其中使用了shell let指令，用于执行一个或者多个表达式，不需要使用美元符号。</p>
<blockquote>
<p>let 是shell中用于计算的表达式不需要时使用美元符号，如果表达式中存在空格或者其他字符则需要引用起来。</p>
</blockquote>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> value <span class="keyword">in</span></span><br><span class="line">val1)</span><br><span class="line">    command1</span><br><span class="line">    ;;</span><br><span class="line">val2)</span><br><span class="line">    command2</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>linux shell中可以定义函数，然后在脚本中可以调用。</p>
<p>函数形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] func_name ()</span><br><span class="line">&#123;</span><br><span class="line">    command1</span><br><span class="line"></span><br><span class="line">    [ <span class="built_in">return</span> int; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中【】表示可选项，即函数可以不使用function定义或者没有返回值。<br>函数的返回值可以使用$?调用<br><strong>注意</strong>：由于shell执行顺序是依次执行的，因此函数定义必须在使用之前。而且$?只对上一条指令负责。</p>
<p>函数参数传递形式和shell脚本一样，然后通过美元符号加数字调用。</p>
<p>函数与指令的执行结果可以作为条件语句使用，<strong>要注意的是，和c语言不同该，0在shell中是true，其他为false</strong></p>
<h2 id="shell文件重定向"><a href="#shell文件重定向" class="headerlink" title="shell文件重定向"></a>shell文件重定向</h2><p>重定向指令列表：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将输出重定向之file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向至file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出追加至file</td>
</tr>
<tr>
<td>n &gt; file</td>
<td>将文件描述符为n的文件重定向至file</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td>将文件描述符为n的文件追加到file</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件m和n合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件m与n合并</td>
</tr>
<tr>
<td>&lt;&lt;tag</td>
<td>将开始标记和结束标记之间等我内容作为输入</td>
</tr>
</tbody></table>
<p><code>command1 &lt; infile &gt; outfile</code><br>此命令将命令的输入输出全部替换了</p>
<p><strong>⚠️注意：0通常是标准输入，1是标准输出，2是标准错误输出</strong></p>
<p><code>command &gt; file 2&gt;&amp;1</code><br>可以将stdout和stderr都重定向至file</p>
<p>Here Document<br>是一种特殊的重定向方式，用于将输入重定向到一个交互式脚本或者程序中。<br>基本格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt; tag</span><br><span class="line">    document</span><br><span class="line">tag</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>结尾的tag应当顶格写，前后都不能有任何字符</li>
<li>开始的tag前后的空格会被忽略。</li>
</ul>
<p>如果执行某指令不希望有任何输出可以将输出重定向至/dev/null，这是一个特殊文件，重定向至它的所有内容都会被丢弃。</p>
<h2 id="shell外部调用"><a href="#shell外部调用" class="headerlink" title="shell外部调用"></a>shell外部调用</h2><p>shell中也可以包含外部脚本，这样就可以封装一些常用的公用脚本作为独立文件。<br>常用的调用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. filename</span><br><span class="line"><span class="comment"># otherwise</span></span><br><span class="line"><span class="built_in">source</span> filename</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>被调用的文件可以不需要可执行权限</li>
<li>path中不包含当前路径则需要写出。/filename</li>
</ol>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog</title>
    <url>/2020/01/23/My-first-blog/</url>
    <content><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>费了不少功夫才把这个博客搭好</p>
<p>虽然大部分是按照前人走过的路来搞得，但是也需要自己去摸索一些东西</p>
<p>很早就想有这样一个平台来记录自己的学习过程了，想通过这样一点一滴的记录看到自己的成长</p>
<p>这样才有动力去向着996的生活进发，hhhhhhhhhh</p>
<p>加油，奥力给！！！</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
