<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql</title>
    <url>/blog/2020/04/03/Mysql/</url>
    <content><![CDATA[<p>之前Mysql学的属实拉胯，面向工作学一下😂</p>
<a id="more"></a>

<h1 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h1><p>数据库：是一个以某种有组织形式存储的数据集合。（database）</p>
<blockquote>
<p>我们平常使用的数据库软件实际上应当叫做DBMS（数据库管理系统）。数据库是通过DBMS来创建和操作的容器。</p>
</blockquote>
<p>表：一种结构化的文件，可以用来存储某种特定类型的数据。</p>
<p>模式：关于数据库和表的布局及特性的信息。</p>
<p>列：表由列组成，列中存储着表中某部分信息。每个列都有特定的数据类型。</p>
<p>行：数据库中的数据是按行存储的，行是表中的一个记录。</p>
<p>主键：表中的每一行都有一个唯一标识自己的一列。因此主键是数据库中的一列或者一组列，其值可以唯一区分表中的每个行。</p>
<p>作为主键的条件：</p>
<ol>
<li>任意两行都不存在相等的主键值</li>
<li>每一行都必须有一个主键值（不可以为NULL）</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>登陆：<code>mysql -u root -qpassword</code></p>
<h2 id="show语句：用于显示信息。"><a href="#show语句：用于显示信息。" class="headerlink" title="show语句：用于显示信息。"></a>show语句：用于显示信息。</h2><pre><code class="mysql">show databases;
show tables;
show columns from table_name;
show status;</code></pre>
<blockquote>
<p>Mysql 不区分空格和大小写</p>
</blockquote>
<h2 id="select语句：用于选择。"><a href="#select语句：用于选择。" class="headerlink" title="select语句：用于选择。"></a>select语句：用于选择。</h2><p>可以加上<code>distinct</code>关键词使得只返回不同值。limit关键字用于限制结果数量，并且可以设置起始位置，<strong>第一行标号为0</strong>。</p>
<blockquote>
<p>列名和表名都可以通过  .  运算符来限定位置。</p>
</blockquote>
<pre><code class="mysql">select distinct id from table limit 5    ;</code></pre>
<h2 id="order-by语句：用于排序。"><a href="#order-by语句：用于排序。" class="headerlink" title="order by语句：用于排序。"></a>order by语句：用于排序。</h2><p>可以对多个列进行排序，只需要通过逗号分开即可。</p>
<p>通过inc，desc关键字指定排序顺序（默认为升序）。</p>
<blockquote>
<p>字典序的排序过程需要设置。</p>
</blockquote>
<p>⚠️order by字句应当是select语句中的最后一条子句。</p>
<h2 id="where语句：过滤数据"><a href="#where语句：过滤数据" class="headerlink" title="where语句：过滤数据"></a>where语句：过滤数据</h2><p>数据根据where给出的条件进行过滤。一般跟在表名（from语句之后给出），位于order by之前。</p>
<ul>
<li><p>可使用操作符：</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200405112407972.png" alt="image-20200405112407972"></p>
</li>
</ul>
<pre><code class="mysql">select a, b from tableA where cond between 1 and 2;
</code></pre>
<ul>
<li><p>空值检查NULL：</p>
<p>NULL和0、空格等不同，在mysql中其属于一个特殊的值。</p>
<p>对于它的操作符我们使用<strong>ISNULL</strong>。</p>
</li>
</ul>
<p><strong>组合过滤</strong>：</p>
<p>可以通过and和or来进行类似编程中的操作。</p>
<blockquote>
<p>And  or 计算次序问题：</p>
<p>mysql优先处理and操作，因此必要时我们需要使用（）来指定运算顺序。</p>
</blockquote>
<p>也可以使用in操作符来指定范围，范围中的每个条件都可以进行匹配。</p>
<p>⚠️注意in后面给出的不是范围取值而是清单。in操作的速度比or更快。</p>
<p>not操作符：否定后面的关键字。</p>
<h2 id="like语句：用通配符进行过滤操作"><a href="#like语句：用通配符进行过滤操作" class="headerlink" title="like语句：用通配符进行过滤操作"></a>like语句：用通配符进行过滤操作</h2><p>常用通配符：</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%</td>
<td align="left">任何字符出现任何次数（包括0次）</td>
</tr>
<tr>
<td align="left">_</td>
<td align="left">任何字符出现一次</td>
</tr>
</tbody></table>
<p>通配符需要很长的操作时间，如果可以不用，尽量不要使用。</p>
<p><strong>通配符置于搜索模式的开始处，效率最低</strong></p>
<h2 id="regexp：使用正则表达式"><a href="#regexp：使用正则表达式" class="headerlink" title="regexp：使用正则表达式"></a>regexp：使用正则表达式</h2><blockquote>
<p>mysql中的正则表达式只是正则表达式语言中的一个子集。</p>
</blockquote>
<p><em>正则表达式匹配时一般不区分大小写，可以使用binary关键字</em></p>
<table>
<thead>
<tr>
<th>表达式符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>｜</td>
<td>正则表达式中的or</td>
</tr>
<tr>
<td>[]</td>
<td>表示匹配列表中字符的任意一个，也可以使用类似[0-9]的规则</td>
</tr>
<tr>
<td>\\</td>
<td>转义特殊字符，也可以引用具有特殊含义的字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>字符集</td>
<td>预先定义好的字符，见表9-2</td>
</tr>
<tr>
<td>重复元字符</td>
<td>表示前一个匹配规则的重复次数，见下表2</td>
</tr>
<tr>
<td>定位元字符</td>
<td>表示匹配的指定位置，见表9-4</td>
</tr>
</tbody></table>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406101943699.png" alt="image-20200406101943699"></p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406102245913.png" alt="image-20200406102245913"></p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406102420943.png" alt="image-20200406102420943"></p>
<p>⚠️  ^有两种用法：</p>
<ol>
<li>用于集合[]中表示否定集合中元素</li>
<li>用于外面则表示定位，在开头进行匹配</li>
</ol>
<blockquote>
<p>简单的正则表达式测试方法：</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406102837052.png" alt="image-20200406102837052"></p>
</blockquote>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><ul>
<li><p>拼接字段：Concat函数</p>
<p>通过指定多个串将其拼成一个串</p>
</li>
<li><p>Rtrim：删除数据右边的多余空格</p>
</li>
<li><p>as：为新的列指定别名</p>
</li>
<li><p>算数操作：</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406172138333.png" alt="image-20200406172138333"></p>
</li>
</ul>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><blockquote>
<p>函数相较于SQL语言来讲可移植性较差，因为每个DBMS都可能有别的不支持的函数，因此在写的过程中应当加好注释。</p>
</blockquote>
<ul>
<li><p>文本处理函数：</p>
<ol>
<li>Upper：将文本转换为大写</li>
<li>Left：返回串左边的字符</li>
<li>Length：返回串的长度</li>
<li>Locate：找出一个子串</li>
<li>Lower：转换成小写</li>
<li>LTrim：去掉串左边的空格</li>
<li>Right：返回串右边的字符</li>
<li>RTrim：去掉串右边的空格</li>
<li>Substring：返回子串的字符</li>
<li>Soundex：返回串的soundex值，该值是一个描述语音的算法，通过该函数我们可以实现对串进行发音的比较</li>
</ol>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406180526527.png" alt="image-20200406180526527"></p>
</li>
<li><p>时间和日期处理函数：</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406180619816.png" alt="image-20200406180619816"></p>
<p><strong>mysql日期格式</strong>：yyyy-mm-dd，这样的格式不容易出现二义性</p>
</li>
<li><p>数值处理函数：</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406220037588.png" alt="image-20200406220037588"></p>
</li>
</ul>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>mysql提供一些函数供我们对于数据库表中的列进行统计。</p>
<p><img src="/lyhhhhhhhhh/lyhhhhh_blog.git/2020/04/03/Mysql/image-20200406220458418.png" alt="image-20200406220458418"></p>
<blockquote>
<p>sum函数忽略值为NULL的行</p>
</blockquote>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>在mysql中我们可以使用group by对数据进行分组，参考下面的例子</p>
<pre><code class="mysql">select vend_id, count(*) as num_prods
from products
group by vend_id;
# 这个mysql语句中我们的count操作对于按vend_id划分出的组而不是整个表</code></pre>
<p>对于group by我们应该知道：</p>
<ol>
<li>group by可以包含任意数量的列，因此我们可以对分组做嵌套。</li>
<li>如果在group by中嵌套了分组，数据将在最后规定的分组上汇总。</li>
<li>如果分组列中有NULL值，则其作为一个单独的分组给出，如果有多个NULL值，则将它们分为一组</li>
<li>group by语句必须在where子句之后，order by语句之前。</li>
</ol>
<h3 id="使用having过滤分组"><a href="#使用having过滤分组" class="headerlink" title="使用having过滤分组"></a>使用having过滤分组</h3><p>having类似于where，但是where不含有组的概念，只能使用having对组进行操作。</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>Mysql4.1及以上允许使用子查询，即嵌套在其他查询中的查询。</p>
<p>子查询可以用于提供新的表供外层查询检索信息，也可以用于select字段中的进行计算</p>
<blockquote>
<p>直接建立一个嵌套的查询是困难的，因此我们应当从内层向外层逐步建立嵌套查询。</p>
<p>并且每次都进行测试，这样可以省去后面如果出错了的大量时间</p>
</blockquote>
<h2 id="连接表"><a href="#连接表" class="headerlink" title="连接表"></a>连接表</h2>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>recent tasks</title>
    <url>/blog/2020/04/02/recent-tasks/</url>
    <content><![CDATA[<h1 id="Recent-Plan"><a href="#Recent-Plan" class="headerlink" title="Recent Plan"></a>Recent Plan</h1><ul>
<li><input disabled type="checkbox"> 深入了解计算机系统</li>
<li><input disabled type="checkbox"> Mysql</li>
<li><input disabled type="checkbox"> the way to go</li>
</ul>
]]></content>
      <categories>
        <category>plan</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解IPC</title>
    <url>/blog/2020/03/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3IPC/</url>
    <content><![CDATA[<p>IPC指进程间通信，常见的有管道、命令管道、信号量、共享内存、消息队列、socket</p>
<p>下面我们就来详细说说各个方法的具体实现。</p>
<a id="more"></a>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是进程间通信的主要手段之一，而管道实际上就是一个<strong>只存在于内存中的虚拟文件</strong>。</p>
<p>对它的操作需要两个已经打开了的文件描述符，分别代表管道的读写两端。</p>
<p>管道只能用于父子进程之间。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>管道实际上是一段内核的缓冲区，一般为4k左右的大小，并且设计为环形以便能够循环利用。</p>
<ul>
<li>如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道的读端读数据，那么文件内的所有内容被读完后再次read就会返回0，就像读到文件结尾。</li>
<li>如果有指向管道写端的文件描述符没有关闭（管道写段的引用计数大于0），而持有管道写端的进程没有向管道内写入数据，假如这时有进程从管道读端读数据，那么读完管道内剩余的数据后就会阻塞等待，直到有数据可读才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭，此时有进程通过写端文件描述符向管道内写数据时，则该进程就会收到SIGPIPE信号，并异常终止。</li>
<li>如果有指向管道读端的文件描述符没有关闭（管道读端的引用计数大于0），而持有管道读端的进程没有从管道内读数据，假如此时有进程通过管道写段写数据，那么管道被写满后就会被阻塞，直到管道内有空位置后才写入数据并返回。</li>
</ul>
<p><img src="https://i.loli.net/2020/03/19/TicOxe7bGlXCyf3.jpg" alt="Jietu20200319-104028@2x"></p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>在linux中，管道的实现并没有专门的数据结构，而是借助了文件系统和虚拟的VFS节点实现的。</p>
<p>两个进程会各打开一个文件结构同时指向这个虚拟的文件节点，而这个inode会指向内核缓冲区中的一段物理页</p>
<p>如下图有两个 file 数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。</p>
<p>这样以来就可以通过普通的文件操作来进行pipe这一个特殊的操作。</p>
<p><img src="https://i.loli.net/2020/03/19/xO1nuBldkWaepvh.jpg" alt="Jietu20200319-105159@2x"></p>
<p>而在实际的读写操作中，我们还需要等待队列、信号量、锁等机制控制同步。</p>
<pre><code class="c">/**
 *    struct pipe_buffer - a linux kernel pipe buffer
 *    @page: the page containing the data for the pipe buffer
 *    @offset: offset of data inside the @page
 *    @len: length of data inside the @page
 *    @ops: operations associated with this buffer. See @pipe_buf_operations.
 *    @flags: pipe buffer flags. See above.
 *    @private: private data owned by the ops.
 **/
struct pipe_buffer {
    struct page *page;
    unsigned int offset, len;
    const struct pipe_buf_operations *ops;
    unsigned int flags;
    unsigned long private;
};


/**
 *    struct pipe_inode_info - a linux kernel pipe
 *    @mutex: mutex protecting the whole thing
 *    @wait: reader/writer wait point in case of empty/full pipe
 *    @nrbufs: the number of non-empty pipe buffers in this pipe
 *    @buffers: total number of buffers (should be a power of 2)
 *    @curbuf: the current pipe buffer entry
 *    @tmp_page: cached released page
 *    @readers: number of current readers of this pipe
 *    @writers: number of current writers of this pipe
 *    @files: number of struct file referring this pipe (protected by -&gt;i_lock)
 *    @waiting_writers: number of writers blocked waiting for room
 *    @r_counter: reader counter
 *    @w_counter: writer counter
 *    @fasync_readers: reader side fasync
 *    @fasync_writers: writer side fasync
 *    @bufs: the circular array of pipe buffers
 *    @user: the user who created this pipe
 **/
struct pipe_inode_info {
    struct mutex mutex;
    wait_queue_head_t wait;
    unsigned int nrbufs, curbuf, buffers;
    unsigned int readers;
    unsigned int writers;
    unsigned int files;
    unsigned int waiting_writers;
    unsigned int r_counter;
    unsigned int w_counter;
    struct page *tmp_page;
    struct fasync_struct *fasync_readers;
    struct fasync_struct *fasync_writers;
    struct pipe_buffer *bufs;
    struct user_struct *user;
};</code></pre>
<p><strong>pipe是半双工的</strong><br>因为其是一个环形的结构，其中需要维持len、offset等信息，修改时势必要加锁，所以只能半双工通信。</p>
<p><a href="https://segmentfault.com/q/1010000014814117/a-1020000014828268" target="_blank" rel="noopener">https://segmentfault.com/q/1010000014814117/a-1020000014828268</a></p>
<blockquote>
<p>半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。</p>
</blockquote>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>管道又一个明显的缺点就是只能父子进程之间进行通信，为了解决这个问题，我们可以使用命名管道。</p>
<ol>
<li>FIFO是文件系统中的一个具体的文件，是存在一个文件名和其绑定的，因此可以实现两个任意进程之间的通信，而匿名管道对于文件系统是透明的。</li>
<li>FIFO是一个设备文件，在文件系统中以文件名的形式存在，因此即使进程与创建FIFO的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。</li>
</ol>
<pre><code class="c">#include &lt;sys/stat.h&gt;
int  mknod(const  char*  path, mode_t mod,  dev_t dev);
int  mkfifo(const  char* path,  mode_t  mod);</code></pre>
<p>上面两个函数都可以创建一个命名管道，前两个参数是指路径和存取权限，而第一个函数中的最后一个参数指的是设备类型，只有创建设备文件的时候才有。</p>
<p>命名管道创建完成后就可以使用，其使用方法与管道一样，区别在于：命名管道使用之前需要使用open()打开。这是因为：命名管道是设备文件，它是存储在硬盘上的，而管道是存在内存中的特殊文件。<br>⚠️但是需要注意的是，命名管道调用open()打开有可能会阻塞，但是如果以读写方式（O_RDWR）打开则一定不会阻塞；以只读（O_RDONLY）方式打开时，调用open()的函数会被阻塞直到有数据可读；如果以只写方式（O_WRONLY）打开时同样也会被阻塞，知道有以读方式打开该管道。</p>
<p>因此，命名管道可以被扩展成c/s模式。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>可以参考我之前的博文————消息队列扫盲。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/blog/2020/03/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>编译原理虎书阅读笔记，另上课笔记</p>
<a id="more"></a>



<h1 id="编译概论"><a href="#编译概论" class="headerlink" title="编译概论"></a>编译概论</h1><h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><p>前端+优化器+后端，其中以IR（中间表示）来传递信息</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>在编译器能够将表达式转换为可执行的目标代码之前，它必须理解表达式的形式和内容，或者<em>语法和语义</em>。</p>
<p>其判断代码是否是良构的，如果是有效的则以编译器的IR形式构建一个代码表示。反之返回一个错误信息。</p>
<p>前端中有两趟独立的处理，分别称为<strong>词法分析器</strong>和<strong>语法分析器</strong>。</p>
<ol>
<li><p>词法分析器</p>
<blockquote>
<p>编译器中的一趟，将字符构成的串转换为单词构成的流。</p>
</blockquote>
<p>按照输入语言的语法规则，匹配已分类单词的流，然后对其进行推导。</p>
</li>
<li><p>语法分析器<br>语法正确的句子可能是无意义的。</p>
<p>编译器可以通过构建数学模型来检查程序中的不一致之处。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>data structure and algorithm</title>
    <url>/blog/2020/03/06/data-structure-and-algorithm/</url>
    <content><![CDATA[<p>Data Structure and Algorithm Notes</p>
<a id="more"></a>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="base-sort"><a href="#base-sort" class="headerlink" title="base sort"></a>base sort</h3><p>选择排序</p>
<pre><code class="go">func sortArray(nums []int) []int {
    length := len(nums)
    for i := range nums {
        min := i
        for j:= i+1; j&lt; length; j++ {
            if nums[min] &gt; nums[j] {
                min = j
            }
        }
        nums[i], nums[min] = nums[min], nums[i]
    }
    return nums
}</code></pre>
<p>插入排序</p>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><pre><code class="go">func sortArray(nums []int) []int {
    if len(nums) &lt;= 1 {
        return nums
    }
    mid := partition(nums)
    sortArray(nums[:mid])
    sortArray(nums[mid+1:])
    return nums
}

func partition(nums []int) int {
    begin, end := 0, len(nums)-2
    target := nums[end+1]
    for ; ; begin, end = begin+1, end-1 {
        for nums[begin] &lt; target {
            begin++
        }
        for end != 0 &amp;&amp; nums[end] &gt; target {
            end--
        }
        if begin &gt;= end {
            break
        }
        nums[begin], nums[end] = nums[end], nums[begin]
    }
    nums[begin], nums[len(nums)-1] = nums[len(nums)-1], nums[begin]
    return begin
}</code></pre>
<p>具有三数取中预处理的快速排序</p>
<pre><code class="go">func sortArray(nums []int) []int {
    if len(nums) &lt;= 1 {
        return nums
    }
    mid := partition(nums)
    sortArray(nums[:mid])
    sortArray(nums[mid+1:])
    return nums
}

func partition(nums []int) int {
    pretreatment(nums)
    begin, end := 0, len(nums)-2
    target := nums[end+1]
    for ; ; begin, end = begin+1, end-1 {
        for nums[begin] &lt; target {
            begin++
        }
        for end != 0 &amp;&amp; nums[end] &gt; target {
            end--
        }
        if begin &gt;= end {
            break
        }
        nums[begin], nums[end] = nums[end], nums[begin]
    }
    nums[begin], nums[len(nums)-1] = nums[len(nums)-1], nums[begin]
    return begin
}

func pretreatment(nums []int) {
    begin, mid, end := 0, len(nums)/2, len(nums)-1
    if nums[begin] &gt; nums[end] {
        nums[begin], nums[end] = nums[end], nums[begin]
    }
    if nums[begin] &gt; nums[mid] {
        nums[begin], nums[mid] = nums[mid], nums[begin]
    }
    if nums[end] &gt; nums[mid] {
        nums[mid], nums[end] = nums[end], nums[mid]
    }
}</code></pre>
<h3 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h3><p>归并排序最引人瞩目的一点是对于什么输入都可以保证nlogn，但是付出的代价就是需要n的空间复杂度。</p>
<p>归并还有一个特点就是顺序的访问数据，因此对于链表的排序或者高性能计算机上，归并更加合适，因为顺序访问数据更快。</p>
<p>归并排序也可以通过原地排序实现，可以将另一个数组倒置在之前的数组之后。然后进行移位归并。</p>
<blockquote>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
<pre><code class="go">func sortArray(nums []int) []int {
    if len(nums) &lt;= 1 {
        return nums
    }
    mid := len(nums) / 2
    left := sortArray(nums[:mid])
    right := sortArray(nums[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    lenLeft, lenRight := len(left), len(right)
    res := make([]int, lenLeft+lenRight)
    for i, j, k := 0, 0, 0; k &lt; lenLeft+lenRight; k++ {
        if i == lenLeft {
            copy(res[k:], right[j:])
            break
        }
        if j == lenRight {
            copy(res[k:], left[i:])
            break
        }
        if left[i] &lt; right[j] {
            res[k] = left[i]
            i++
        } else {
            res[k] = right[j]
            j++
        }
    }
    return res
}</code></pre>
<h4 id="改进策略"><a href="#改进策略" class="headerlink" title="改进策略"></a>改进策略</h4><ol>
<li><p>递归算法都可以通过将小文件通过插入排序等实现，这样减小递归的开销。</p>
</li>
<li><p>通过使两个有序数组放在另一个全局数组中形成bitonic排序来进行原地的归并排序。</p>
</li>
</ol>
<blockquote>
<p>看一下双调排序。</p>
</blockquote>
<h3 id="优先队列和堆排序"><a href="#优先队列和堆排序" class="headerlink" title="优先队列和堆排序"></a>优先队列和堆排序</h3><p>优先队列是一种数据结构，其数据项中带有关键字，支持两种基本操作：向优先队列中插入一个新的数据项，删除优先队列中关键字最大的数据项。</p>
<p>优先队列是一种抽象的数据结构，我们可以有多种方式实现它，问题在于我们想得到的是插入和删除最大两个操作同时可以线性或者同时以logn完成。</p>
<ol>
<li>可以使用序列（数组或者链表）来实现。</li>
<li>用堆实现。<br>堆生成的最坏情况为nlgn</li>
</ol>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ol>
<li>连续的插入构建堆，然后再连续的删除最大值（并不是最理想的情况）</li>
<li>在原数组上原地构建堆，数组自右向左依次做下沉操作<br>其相当于将当前节点的作为子堆的根结点，其两个子堆都已经是堆序的。<br>然后交换第一个元素和最后的元素。直到排序完成。</li>
</ol>
<p>应当注意的是，这种构造堆的方式是<strong>线性复杂度的</strong>。</p>
<p>然而之后的操作还是需要nlgn</p>
<pre><code class="go">func sortArray(nums []int) []int {
    length := len(nums)
    for i:=length/2; i &gt;= 0; i-- {
        fixdown(nums, i)
    }
    for ;length &gt; 1; length--  {
        nums[length-1], nums[0] = nums[0], nums[length-1]
        fixdown(nums[:length-1], 0)
    }
    return nums
}

func fixdown(nums []int, k int) {
    length := len(nums)
    for k &lt; length {
        child := 2*k+1
        if child &lt; length-1 &amp;&amp; (nums[child] &lt; nums[child+1]) {
            child++
        }
        if child &lt; length &amp;&amp; nums[child] &gt; nums[k] {
            nums[child], nums[k] = nums[k], nums[child]
            k = child
        } else {
            break
        }
    }
}</code></pre>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>平衡多路归并排序。</p>
<p>初始分布遍+多路归并</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>通过一个散列函数将关键字转换为表中地址，理想情况是不同的关键字地址不同，如果相同时则出现冲突</p>
<p>第二步就是冲突解决</p>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><ol>
<li>链地址法</li>
</ol>
<p>通过将冲突的位置使用链表储存来解决冲突问题。</p>
<ol start="2">
<li>开放定址法</li>
</ol>
<p>线性探测、平方探测、再hash等，查找下一个空位</p>
<h3 id="动态hash"><a href="#动态hash" class="headerlink" title="动态hash"></a>动态hash</h3><p>哈希表在表快满的时候效率会急剧下降，所以需要动态的改变其大小。</p>
<h2 id="符号表与二叉搜索树"><a href="#符号表与二叉搜索树" class="headerlink" title="符号表与二叉搜索树"></a>符号表与二叉搜索树</h2><p>符号表是一种数据结构，其中数据项含有关键字，支持两个基本操作：插入新的数据项，返回给定关键字的数据项</p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>三种性能保障方法：</p>
<ol>
<li>随机化</li>
<li>摊还</li>
<li>优化</li>
</ol>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h4><p>理想模型，其要么没有子节点要么子节点是以下三种节点之一</p>
<p>2，3，4表示的是节点关键值划分出来的域，因此对应的关键字个数就应该是1，2，3</p>
<p>2-3-4树难以实现。<br>红黑树是2-3-4树的二叉形式，将3，4节点中的子树用红链接连接，剩下的用黑链接</p>
<p>定义：</p>
<ol>
<li>节点是红色或者黑色</li>
<li>根结点必须是黑色</li>
<li>红色节点子节点必须是黑色</li>
<li>一个节点到树的底部所有路径上的黑色节点数应当相等。</li>
</ol>
<h2 id="单源最短路径算法"><a href="#单源最短路径算法" class="headerlink" title="单源最短路径算法"></a>单源最短路径算法</h2><h3 id="relax操作"><a href="#relax操作" class="headerlink" title="relax操作"></a>relax操作</h3><p><img src="https://i.loli.net/2020/03/07/A1R7EB8P6hTV9am.jpg" alt="Jietu20200307-184224@2x"></p>
<p>路径松弛性质</p>
<p>前驱子图、前驱节点。</p>
<h3 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman-ford算法"></a>Bellman-ford算法</h3><p>按照节点数对于每一条边进行松弛操作。O（VE）</p>
<p>可以对含负权重的有向图操作。</p>
<p>如果之后还可以松弛，说明存在负权重的环。</p>
<h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><p>要求每一条边都是非负权重。</p>
<p>是一种贪心算法，总选择最短路径估计值最小的节点加入s中。</p>
<p>其时间复杂度和查找最小值的算法有关。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>dataStructure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>c线程池实现</title>
    <url>/blog/2020/03/05/c%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>自己照着github和csdn里别的大哥写的代码完成了自己的线程池。</p>
<p>参考连接如下：</p>
<p><a href="https://blog.csdn.net/virgofarm/article/details/80994153" target="_blank" rel="noopener">https://blog.csdn.net/virgofarm/article/details/80994153</a></p>
<p><a href="https://github.com/Pithikos/C-Thread-Pool" target="_blank" rel="noopener">https://github.com/Pithikos/C-Thread-Pool</a></p>
<p><a href="https://github.com/mbrossard/threadpool" target="_blank" rel="noopener">https://github.com/mbrossard/threadpool</a></p>
<a id="more"></a>

<h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h1><blockquote>
<p>面试的时候问到了这个问题，感觉没有回答到点子上</p>
</blockquote>
<ol>
<li><p>服务器的创建和销毁开销很大，如果每个请求都十分短暂，那么就会在创建和销毁的过程中消耗大量的资源</p>
</li>
<li><p>活动的线程也会消耗资源，如果对于线程的数量没有限制的话，就会在大量请求到达服务器的时候创建出大量的工作线程，会消耗大量的内存空间，影响服务器的使用。</p>
</li>
<li><p>如果线程的数目固定，并且每个线程都有很长的生命周期，那么线程切换也就是固定的，这样就会给服务器减轻很多压力，但是如果频繁的创建和销毁线程，必将导致频繁的切换线程，使得线程之间的切换不再遵循系统的固定切换周期，线程切换的开销也会增大很多。</p>
</li>
</ol>
<h2 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h2><p><a href="https://blog.csdn.net/chengonghao/article/details/51779279" target="_blank" rel="noopener">https://blog.csdn.net/chengonghao/article/details/51779279</a></p>
<p>在详细的说明线程池的构成之前我们首先了解一下pthread_cond_t，这个叫做条件变量，可以和pthread_mutex_t一起完成进程之间的通信。</p>
<p>条件变量的作用就是使进程阻塞在条件变量上，当其条件满足的时候唤醒线程，完成操作</p>
<p>首先，pthread_cond_t具有五个函数：</p>
<pre><code class="c">/* 初始化一个条件变量 */
int pthread_cond_init (pthread_cond_t* cond, pthread_condattr_t *cond_attr);

/* 销毁一个条件变量 */
int pthread_cond_destroy(pthread_cond_t* cond);

/* 令一个消费者等待在条件变量上 */
int pthread_cond_wait(pthread_cond_t* cond);

/* 生产者通知等待在条件变量上的消费者 */
int pthread_cond_signal(pthread_cond_t* cond);

/* 生产者向消费者广播消息 */
int pthread_cond_broadcast(pthread_cond_t* cond);</code></pre>
<p>其中最主要的就是wait方法，他可以使进程在这个语句上阻塞，当signal或者broadcast方法被调用的时候被唤醒。</p>
<p>cond和mutex的组合使用示例：</p>
<pre><code class="c">/* consumet*/
pthread_mutex_lock(&amp;mutex); // 拿到互斥锁，进入临界区
while (false){
    pthread_cond_wait(cond, mutex); // 令进程等待在条件变量上修改件
}    
pthread_mutex_unlock(&amp;mutex); // 释放互斥锁

/*porduct*/
pthread_mutex_lock(&amp;mutex); // 拿到互斥锁，进入临界区
设置条件为真
pthread_cond_signal(cond); // 通知等待在条件变量上的消费者
pthread_mutex_unlock(&amp;mutex); // 释放互斥锁</code></pre>
<p>按照我们之前的知识，这个程序是会死锁的，但实际上，程序运行到<code>pthread_cond_wait</code>的时候，线程会先释放mutex，在被唤醒之后重新拿回mutex。</p>
<p>这样以来我们就可以通过mutex和cond的组合完成另一种模式的线程通信。</p>
<h2 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h2><p>首先我们来说一下为什么要用线程池：<br>如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了</p>
<p>一般来说，线程池的组成主要是：</p>
<ol>
<li><p>线程管理器：用于创建并管理线程池。</p>
</li>
<li><p>工作线程：线程池中实际执行任务的线程。在初始化线程时会预先创建好固定数目的线程在池中，这些初始化的线程一般处于空闲状态，一般不占用CPU，占用较小的内存空间。</p>
</li>
<li><p>任务接口：每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。</p>
</li>
<li><p>任务队列：用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活，下文中就是用到的链表。</p>
</li>
</ol>
<p>附上代码：</p>
<p>threadpool.h</p>
<pre><code class="c">#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

#define MAX_THREAD 5
#define MAX_TASKS 64


/* the interface of the work*/
typedef struct 
{
    void (*func) (void*);
    void *argument;
}tasks;

/* the struct of cond and mutex
 *to complish complish comunication between threads*/

typedef struct 
{
    pthread_cond_t cond;
    pthread_mutex_t locker;

}condition;


/* the definition of the erro type */
typedef enum {
    threadpool_invalid        = -1,
    threadpool_lock_failure   = -2,
    threadpool_queue_full     = -3,
    threadpool_shutdown       = -4,
    threadpool_thread_failure = -5
} threadpool_error_t;

/* 
 * the definition of the threadpool
 * @var threads,  array of pthread
 * @var cur_cond, condition pointer
 * @var tasks_queue, the queue of the task
 * @var thread_count, the num in threadpool
 * @var queue_head, the head of queue
 * @var queue_tail, the tail of queue
 * @var shutdown_flag, tag for shutdown operation
 * @var queue_size, the size of queue
 * @var started, the num of running threads
 * @var pending_count, the num of pending task in queue
 * */ 

typedef struct
{
    pthread_t* threads;
    condition* cur_cond;
    tasks *tasks_queue;
    int thread_count;
    int queue_head;
    int queue_tail;
    int shutdown_flag;
    int queue_size;
    int started;
    int pending_count;
}threadpool;



threadpool* thread_pool_init(int, int);

int threadpool_add(threadpool*, void (*func)(void*), void*);

int threadpool_destroy(threadpool*);


/* initial the condition struct*/
condition* condition_init(void) {
    condition* newcond = (condition*)malloc(sizeof(condition));
    if (newcond == NULL) {
        goto err;
    }

    if ((pthread_cond_init(&amp;newcond-&gt;cond, NULL) != 0) 
    || (pthread_mutex_init(&amp;newcond-&gt;locker, NULL) != 0)) {
        goto err;
    }

    return newcond;

err:
    if (newcond != NULL) {
        free(newcond);
    }
    return NULL;
}</code></pre>
<p>threadpool.c</p>
<pre><code class="c">#include &quot;threadpool.h&quot;
static void* threadpool_thread_run(void*);

condition* condition_init(void) {
    condition* newcond = (condition*)malloc(sizeof(condition));
    if (newcond == NULL) {
        goto err;
    }

    if ((pthread_cond_init(&amp;newcond-&gt;cond, NULL) != 0) 
    || (pthread_mutex_init(&amp;newcond-&gt;locker, NULL) != 0)) {
        goto err;
    }

    return newcond;

err:
    if (newcond != NULL) {
        free(newcond);
    }
    return NULL;
}

threadpool* threadpool_init(int thread_num, int queue_size)
{
    threadpool* pool;

    if (thread_num&lt;=0 || thread_num &gt; MAX_THREAD 
    || queue_size &lt;= 0 || queue_size &gt; MAX_TASKS ) {
        return NULL;
    }

    pool = (threadpool*)malloc(sizeof(threadpool));
    if (pool == NULL) {
        goto err;
    }

    /* initialize*/
    pool-&gt;thread_count = 0;
    pool-&gt;queue_head = pool-&gt;queue_tail = pool-&gt;pending_count = 0;
    pool-&gt;shutdown_flag = pool-&gt;started = 0;
    pool-&gt;queue_size = queue_size;

    pool-&gt;threads = (pthread_t *)malloc(sizeof(pthread_t) * thread_num);
    pool-&gt;tasks_queue = (tasks*)malloc(sizeof(tasks)*queue_size);
    pool-&gt;cur_cond = condition_init();

    if (pool-&gt;threads == NULL || pool-&gt;cur_cond == NULL 
    || pool-&gt;tasks_queue == NULL) {
        goto err;
    }

    for (int i = 0; i&lt;thread_num; i++) {
        if (pthread_create(&amp;pool-&gt;threads[i], NULL,
        threadpool_thread_run, (void*)pool) != 0) {
            threadpool_destroy(pool);
            return NULL;
        }
        pool-&gt;thread_count++;
        pool-&gt;started++;
    }

    return pool;

err:
    if (pool != NULL) {

    }
    return NULL;
}

int threadpool_add(threadpool* pool, void (*func)(void*), void* argument)
{
    int err = 0;

    if (pool == NULL || func == NULL) {
        return threadpool_invalid;
    }

    condition* curcond = pool-&gt;cur_cond;
    if(pthread_mutex_lock(&amp;curcond-&gt;locker) != 0) {
        return threadpool_lock_failure;
    }

    if (pool-&gt;shutdown_flag != 0) {
        return threadpool_shutdown;
    }

    if (pool-&gt;queue_size == pool-&gt;pending_count) {
        return threadpool_queue_full;
    }

    pool-&gt;tasks_queue[pool-&gt;queue_tail].func = func;
    pool-&gt;tasks_queue[pool-&gt;queue_tail].argument = argument;
    pool-&gt;queue_tail = (pool-&gt;queue_tail+1) % pool-&gt;queue_size;
    pool-&gt;pending_count++;

    if (pthread_cond_signal(&amp;curcond-&gt;cond) != 0) {
        return threadpool_lock_failure;
    }

    if(pthread_mutex_unlock(&amp;curcond-&gt;locker) != 0) {
        return threadpool_lock_failure;
    }

    return err;
}

static void * threadpool_thread_run(void *thepool) {
    threadpool* pool = (threadpool*) thepool;
    tasks task;

    for(;;) {
        pthread_mutex_lock(&amp;pool-&gt;cur_cond-&gt;locker);

        while(pool-&gt;pending_count == 0 &amp;&amp; !(pool-&gt;shutdown_flag)) {
            pthread_cond_wait(&amp;pool-&gt;cur_cond-&gt;cond, &amp;pool-&gt;cur_cond-&gt;locker);
        }

        if(pool-&gt;shutdown_flag) {
            break;
        }

        task.func = pool-&gt;tasks_queue[pool-&gt;queue_head].func;
        task.argument = pool-&gt;tasks_queue[pool-&gt;queue_head].argument;
        pool-&gt;queue_head = (pool-&gt;queue_head + 1) % pool-&gt;queue_size;
        pool-&gt;pending_count--;

        pthread_mutex_unlock(&amp;pool-&gt;cur_cond-&gt;locker);

        (*(task.func))(task.argument);
    }

    pool-&gt;started--;

    pthread_exit(NULL);
    return NULL;
}

int threadpool_destroy(threadpool* pool) {
    if (pool == NULL) {
        return -1;
    }

    if (pool-&gt;shutdown_flag) {
        return -1;
    }

    pthread_cond_broadcast(&amp;pool-&gt;cur_cond-&gt;cond);

    for (int i=0; i&lt; pool-&gt;thread_count; i++) {
        pthread_join(pool-&gt;threads[i], NULL);
    }
    free(pool-&gt;threads);
    free(pool-&gt;tasks_queue);

    pthread_mutex_destroy(&amp;(pool-&gt;cur_cond-&gt;locker));
    pthread_cond_destroy(&amp;(pool-&gt;cur_cond-&gt;cond));

    free(pool);
    pool = NULL;
    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>threadpool</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>golang打补丁</title>
    <url>/blog/2020/03/05/golang%E6%89%93%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<p>标题即内容😊</p>
<a id="more"></a>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ol>
<li>存在高级break语句可以跳出循环到指定位置</li>
</ol>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(&quot;1&quot;)

Exit:
    for i := 0; i &lt; 9; i++ {
        for j := 0; j &lt; 9; j++ {
            if i+j &gt; 15 {
                fmt.Print(&quot;exit&quot;)
                break Exit
            }
        }
    }

    fmt.Println(&quot;3&quot;)
}</code></pre>
<ol start="2">
<li>for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</li>
</ol>
<p>等号左边和右边含有多个表达式，就是平行赋值。<br>由于Go没有逗号表达式，而++和–是语句而不是表达式，如果想在for中执行多个变量,需要使用平行赋值</p>
<pre><code class="go">for i, j := 1, 10; i &lt; j; i,j=i+1,j+1 {  //死循环
    fmt.Println(i)
}

// wrong example
for i, j := 1, 10; i &lt; j; i++,j++ {
    fmt.Println(i)
}
</code></pre>
<ol start="3">
<li>for语句中的condition每次循环都要执行一次，因此不要把condition写复杂。</li>
</ol>
<pre><code class="go">// use as an example, do not use len(str)
for i=0; i&lt; len(str); i++ {
    fmt.Println(str[i])
}</code></pre>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>无缓冲的channel是同步的，而有缓冲的channel是非同步的<br>比如</p>
<p>c1:=make(chan int)        无缓冲</p>
<p>c2:=make(chan int,1)      有缓冲</p>
<p>c1&lt;-1                            </p>
<p>无缓冲的 不仅仅是 向 c1 通道放 1 而是 一直要有别的携程 &lt;-c1 接手了 这个参数，那么c1&lt;-1才会继续下去，要不然就一直阻塞着</p>
<p>而 c2&lt;-1 则不会阻塞，因为缓冲大小是1 只有当 放第二个值的时候 第一个还没被人拿走，这时候才会阻塞。打个比喻<br>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走, 无缓冲保证信能到你手上。<br>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来，有缓冲的，保证信能进你家的邮箱</p>
<h2 id="值类型和饮用类型"><a href="#值类型和饮用类型" class="headerlink" title="值类型和饮用类型"></a>值类型和饮用类型</h2><p>golang中分为值类型和引用类型</p>
<p>值类型分别有：int系列、float系列、bool、string、数组和结构体<br>引用类型有：指针、slice切片、管道channel、接口interface、map、函数等</p>
<p>值类型的特点是：变量直接存储值，内存通常在栈中分配<br>引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配</p>
<h2 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h2><p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>GO语言中字符串是不可变的，所以不能对字符串中某个字符单独赋值。<br>字符串不支持下标操作。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p><a href="https://zhuanlan.zhihu.com/p/34211611" target="_blank" rel="noopener">zhihu</a></p>
<h2 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h2><p>a tool in go to find the bugs in your code, <a href="https://studygolang.com/articles/9619" target="_blank" rel="noopener">more details</a>.</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode面试模拟</title>
    <url>/blog/2020/03/04/leetcode%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>斥巨资购买leetcode会员之后拥有的人上人体验💩</p>
<a id="more"></a>

<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p><img src="https://i.loli.net/2020/03/04/Zgi7DmCY4dwMyue.jpg" alt="Jietu20200304-173009@2x"></p>
<p>花了很长时间在这道题上，基本上算是暴力解法，遍历数组，用hash表存下来，之后用数组保存哈希表的key，排序后倒置遍历，可能的问题指出在sum&gt;=store[i]可能存在在之前就已经满足条件的情况。</p>
<p>注意，当遍历了一遍都不成功时，返回的值不应该是0，而应当是数组长度。</p>
<pre><code class="go">func hIndex(citations []int) int {
    m := make(map[int]int)
    for _, value := range citations {
        m[value]++
    }
    store := make([]int, 0)
    for k := range m {
        store = append(store, k)
    }
    sort.Ints(store)
    sum := 0
    for i := len(store) - 1; i &gt;= 0; i-- {
        sum += m[store[i]]
        if sum &gt;= store[i] {
            temp := sum - m[store[i]]
            if i != len(store)-1 &amp;&amp; temp &gt;= store[i] {
                return temp
            }
            return store[i]
        }
    }
    if len(citations) &gt; 0 {
        return len(citations)
    }
    return 0
}</code></pre>
<p><img src="https://i.loli.net/2020/03/04/8RwDzxycTrYk4Es.jpg" alt="Jietu20200304-173802@2x"></p>
<p>这题我是做过的，长度补齐之后依次加就行了</p>
<pre><code class="go">func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    firstLength := getlength(l1)
    secondLength := getlength(l2)
    add := &amp;ListNode{0, nil}
    tail := add
    if firstLength &gt; secondLength {
        for i := 1; i &lt; (firstLength - secondLength); i++ {
            tail.Next = &amp;ListNode{0, nil}
            tail = tail.Next
        }
        tail.Next = l2
        l2 = add
    } else if firstLength &lt; secondLength {
        for i := 1; i &lt; (secondLength - firstLength); i++ {
            tail.Next = &amp;ListNode{0, nil}
            tail = tail.Next
        }
        tail.Next = l1
        l1 = add
    }
    if calculate(l1, l2) == 1 {
        head := &amp;ListNode{1, l1}
        return head
    }
    return l1
}

func getlength(root *ListNode) int {
    res := 0
    for root != nil {
        res++
        root = root.Next
    }
    return res
}

func calculate(l1, l2 *ListNode) int {
    if l1 == nil &amp;&amp; l2 == nil {
        return 0
    }
    res := l1.Val + l2.Val + calculate(l1.Next, l2.Next)
    l1.Val = res % 10
    return res / 10
}</code></pre>
<p><img src="https://i.loli.net/2020/03/04/TBntFlXm3bpoeAH.jpg" alt="Jietu20200304-173955@2x"></p>
<p>转成数组之后，双指针遍历。</p>
<pre><code class="go">func isPalindrome(x int) bool {
    if x &lt; 0 {
        return false
    }
    store := make([]int, 0)
    for ;x &gt; 0; x /= 10 {
        store = append(store, x%10)
    }
    begin, end := 0, len(store)-1
    for begin &lt;= end {
        if store[begin] != store[end] {
            return false
        }
        begin++
        end--
    }
    return true
}</code></pre>
<p>比上面那个要机智一点，把一个数分成两个来判定。</p>
<pre><code class="go">func isPalindrome(x int) bool {
    if x &lt; 0 ||(x%10==0 &amp;&amp; x!=0){
        return false
    }

    var revertedNumber int
    for x &gt; revertedNumber{
        revertedNumber = revertedNumber * 10 + x%10
        x/=10
    }
    return revertedNumber == x || revertedNumber /10 == x
}</code></pre>
<p><img src="https://i.loli.net/2020/03/05/AEMfnU63BJIoXPT.jpg" alt="Jietu20200305-232717@2x"></p>
<p>哈希或者快慢指针</p>
<pre><code class="go">func hasCycle(head *ListNode) bool {
    fast, slow := head, head
    count := 0
    for fast != nil &amp;&amp; slow != nil {
        if count % 2 == 1 {
            slow = slow.Next
        }
        fast = fast.Next
        if fast == slow {
            return true
        }
        count++
    }
    return false
}

func hasCycle(head *ListNode) bool {
    m := make(map[*ListNode]bool)
    for head != nil {
        if m[head] {
            return true
        }
        m[head] = true
        head = head.Next
    }
    return false
}</code></pre>
<p><img src="https://i.loli.net/2020/03/05/zuIMvy8KfDAT9Cm.jpg" alt="Jietu20200305-235210@2x"></p>
<p>这个问题思路上没啥难的，关键在于细节实现上尤其是MaxInt32等的判定。</p>
<pre><code class="go">func myAtoi(str string) int {
    res, negative, begin := 0, false, false
    for _, value := range str {
        if value == &#39; &#39; &amp;&amp; !begin {
            continue
        }
        if (value == &#39;+&#39; || value == &#39;-&#39;) &amp;&amp; !begin {
            if value == &#39;-&#39; {
                negative = true
            }
            begin = true
            continue
        }
        if value &gt;= &#39;0&#39; &amp;&amp; value &lt;= &#39;9&#39; {
            if !begin {
                begin = true
            }
            res = res*10 + int(value-48)
            if res &gt; (-math.MinInt32) &amp;&amp; negative {
                res = math.MinInt32
                negative = false
                break
            }
            if res &gt; math.MaxInt32 &amp;&amp; !negative {
                res = math.MaxInt32
                break
            }
        } else {
            break
        }
    }
    if negative {
        res = (-res)
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/06/sLu79nDazT4gVUj.jpg" alt="Jietu20200306-000722@2x"></p>
<p>这题虽然很简单，但是下面的第一种做法属实巧妙，充分利用了过半的条件。<br>后面的解法是我的，很常规，用了map。</p>
<pre><code class="go">func majorityElement(nums []int) int {
    var last, count int
    for _, v := range nums {
        if count == 0 {
            last = v
            count = 1
            continue
        }
        if last == v {
            count++
        } else {
            count--
        }
    }
    return last
}

func majorityElement(nums []int) int {
    length := len(nums)
    m := make(map[int]int)
    for _, value := range nums {
        m[value] = m[value] + 1
        if m[value] &gt; length/2 {
            return value
        }
    }
    return 0
}</code></pre>
<p><img src="https://i.loli.net/2020/03/07/cp5QOBEXHYCFMnR.jpg" alt="Jietu20200307-122040@2x"></p>
<p>这个题属实很巧妙，插入和弹出的O（1）算法都很好写，问题在于最大值上，我们需要额外维持一个数组来保存最大值信息。</p>
<p>最大值的维持有这样一个规律：对于一新的value，之前入队的小于value的值都对其无影响。因此我们维持一个递减数列，每次有新值的时候将递减数列中小于这个值的数全部删除，这样以来我们就可以完成需要的操作。</p>
<p>虽然其中有可能有O（n）的复杂度，但是摊还之后其应当为O（1）。</p>
<pre><code class="go">type MaxQueue struct {
    queue []int
    aux []int
}


func Constructor() MaxQueue {
    return MaxQueue{
        queue: make([]int, 0),
        aux: make([]int, 0),
    }
}


func (this *MaxQueue) Max_value() int {
    if len(this.aux) == 0 {
        return -1
    }
    return this.aux[0]
}


func (this *MaxQueue) Push_back(value int)  {
    this.queue = append(this.queue, value)
    index := 0
    for index = range this.aux {
        if this.aux[index] &lt; value {
            break
        }
    }
    if len(this.aux) &gt; 0 &amp;&amp; this.aux[index] &gt;= value { index++ }
    this.aux = append(this.aux[:index], value)
}


func (this *MaxQueue) Pop_front() int {
    if len(this.queue) == 0 {
        return -1
    }
    res := this.queue[0]
    this.queue = this.queue[1:]
    if this.aux[0] == res {
        this.aux = this.aux[1:]
    }
    return res
}
</code></pre>
<p><img src="https://i.loli.net/2020/03/12/iz7mUreH8wIuk2j.jpg" alt="Jietu20200312-200130@2x"></p>
<p>观察可得正着走n-（k%n）即为所求起点，所以首先遍历一遍，构造出一个环并且求长度，然后再确定头节点。</p>
<pre><code class="go">func rotateRight(head *ListNode, k int) *ListNode {
    if head == nil {
        return head
    }
    travel, length := head, 1
    for travel.Next != nil {
        length++
        travel = travel.Next
    }
    travel.Next = head
    for i:=0; i&lt;length-(k%length)-1; i++ {
        head = head.Next
    }
    head, head.Next = head.Next, nil
    return head
}</code></pre>
<p><img src="https://i.loli.net/2020/03/13/nW61QMTGzkVcqXo.jpg" alt="Jietu20200313-080126@2x"></p>
<p>之前在那本数据结构里看到的，原地归并排序的方法，将第二个数组倒置拷贝至第一个数组，进行双调排序</p>
<pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int) {
    for i, j := m, n-1; i &lt; m+n; i, j = i+1, j-1 {
        nums1[i] = nums2[j]
    }
    for i, index := m+n-1, 0; index &lt; i; index++ {
        if nums1[index] &gt;= nums1[i] {
            temp := nums1[i]
            for j := i; j &gt; index; j-- {
                nums1[j] = nums1[j-1]
            }
            nums1[index] = temp
        }
    }
}</code></pre>
<p>除此之外还可以使用剑指offer中提到的从后往前进行排序。</p>
<pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int) {
    for m!=0 &amp;&amp; n!=0 {
        if nums1[m-1] &lt; nums2[n-1] {
            nums1[m+n-1] = nums2[n-1]
            n--
        } else {
            nums1[m+n-1] = nums1[m-1]
            m--
        }
    }
    if n != 0 {
        copy(nums1[:n], nums2[:n])
    }
}</code></pre>
<p><img src="https://i.loli.net/2020/03/15/1RUi4CoYzcDH35l.jpg" alt="Jietu20200315-205528@2x"></p>
<p>有一说一，这种格子的题直接广搜就完事了<br>这个题比较秒的在于，用过的直接置0就🉑️了。没必要害在哪hashmap</p>
<pre><code class="go">func maxAreaOfIsland(grid [][]int) int {
    max := 0
    queue:= make([]int, 0)
    for i, v := range grid {
        for j, value := range v {
            temp := 0
            if value == 1 {
                temp++
                grid[i][j] = 0
                queue = append(queue, i*100+j)
                for len(queue) &gt; 0 {
                    nextQue := make([]int, 0)
                    for _, node := range queue {
                        cow, row := node%100, node/100
                        if row!=0 &amp;&amp; grid[row-1][cow]==1 {
                            temp++
                            grid[row-1][cow] = 0
                            nextQue = append(nextQue, (row-1)*100+cow)
                        }
                        if row!=len(grid)-1 &amp;&amp; grid[row+1][cow]==1 {
                            temp++
                            grid[row+1][cow]=0
                            nextQue = append(nextQue, (row+1)*100+cow)
                        }
                        if cow!=0 &amp;&amp; grid[row][cow-1]==1 {
                            temp++
                            grid[row][cow-1]=0
                            nextQue = append(nextQue, row*100+cow-1)
                        }
                        if cow!=len(v)-1&amp;&amp;grid[row][cow+1]==1 {
                            temp++
                            grid[row][cow+1]=0
                            nextQue = append(nextQue, row*100+cow+1)
                        }
                    }
                    queue = nextQue
                }
            }
            if temp &gt; max {
                max = temp
            }
        }
    }
    return max
}  </code></pre>
<p><img src="https://i.loli.net/2020/03/16/DWgAmhpOz7GSrb8.jpg" alt="Jietu20200316-155925@2x"></p>
<p>题目不难，关键在于判断的问题，值得注意的是只有一个点也可以作为一个路径。<br>按照题解的方式简化了代码，但是这样其实就慢了一点，不过看起来更加简明。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
    res := math.MinInt32
    helper(root, &amp;res)
    return res
}

func helper(root *TreeNode, res *int) int {
    if root == nil {
        return 0
    }
    left := int(math.Max(float64(helper(root.Left, res)), float64(0)))
    right := int(math.Max(float64(helper(root.Right, res)), float64(0)))
    if root.Val + left + right &gt; *res {
        *res = root.Val + left + right
    }
    return root.Val + int(math.Max(float64(left), float64(right)))
}</code></pre>
<p><img src="https://i.loli.net/2020/03/16/IhBRb6FyGxT5WXY.jpg" alt="Jietu20200316-164133@2x"></p>
<p>这题确实不难，关键是思维定式了，以为只能操作指针，实际上这道题是让我们通过赋值来完成删除操作，将链表当作数组。</p>
<pre><code class="go">func deleteNode(node *ListNode) {
    prev := node
    for ;node.Next != nil; node = node.Next {
        node.Val, prev = node.Next.Val, node
    }
    prev.Next = nil
}</code></pre>
<p><img src="https://i.loli.net/2020/03/16/tWw7HZCR3bQjEIl.jpg" alt="Jietu20200316-182503@2x"></p>
<p>这个题真的是我见过的最牛逼的题，所有的2的幂都应当满足<code>(n &amp; (n-1)) == 0</code></p>
<pre><code class="go">func isPowerOfTwo(n int) bool {
    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) == 0
}</code></pre>
<p><img src="https://i.loli.net/2020/03/17/QfwTD3HlaL5jWFg.jpg" alt="Jietu20200316-210810@2x"></p>
<p>有一说一，这个也是真的牛逼，两个相同的数异或为0，零和任何数异或都为其本身。<br>这个题我一开始只能想到哈希表来做。</p>
<pre><code class="go">func singleNumber(nums []int) int {
    res := 0
    for _, value := range nums {
        res ^= value
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/17/EStl1Qjmos6n4v5.jpg" alt="Jietu20200317-114152@2x"></p>
<p>这个题关键在于，我们使用快慢指针相遇之后的位置，然后从头节点再出发一个指针，和相遇点一起出发之后的相遇位置就是环入口，可以从数学中推到出来。</p>
<pre><code class="go">func detectCycle(head *ListNode) *ListNode {
    fast, slow:= head, head
    for fast != nil {
        if fast.Next == nil {
            return nil
        }
        slow, fast = slow.Next, fast.Next.Next
        if slow == fast {
            break
        }
    }
    if fast == nil {
        return nil
    }
    for head != fast {
        head, fast = head.Next, fast.Next
    }
    return head
}</code></pre>
<p><img src="https://i.loli.net/2020/03/17/H2KTILljRtOZsuB.jpg" alt="Jietu20200317-131923@2x"></p>
<p>这个题是很明显的动态规划问题，递推关系为<code>path[m][n] = path[m-1][n] + path[m][n-1]</code></p>
<pre><code class="go">func uniquePaths(m int, n int) int {
    store := make([][]int, n)
    for i := range store {
        store[i] = make([]int, m)
    }
    for i:=0; i&lt;n; i++ {
        for j:=0; j&lt;m; j++ {
            if i == j &amp;&amp; i == 0 {
                store[i][j] = 1
                continue
            }
            if i != 0 {
                store[i][j] += store[i-1][j]
            }
            if j != 0 {
                store[i][j] += store[i][j-1]
            }
        }
    }
    return store[n-1][m-1]
}</code></pre>
<p><img src="https://i.loli.net/2020/03/17/U3VuMEh92ex7INT.jpg" alt="Jietu20200317-153134@2x"></p>
<p>先给出一个常规的搜索算法，选择使用了广搜，保存的是数组下标。<br>这道题还可以用位运算解，简直是神仙解法。</p>
<pre><code class="go">func subsets(nums []int) [][]int {
    queue, res := make([][]int, 0), make([][]int, 1)
    res[0] = []int{}
    for i := range nums {
        queue = append(queue, []int{i})
    }
    for len(queue) &gt; 0 {
        nextQueue := make([][]int, 0)
        for _, v := range queue {
            subset := make([]int, len(v))
            for i, value := range v {
                subset[i] = nums[value]
            }
            res = append(res, subset)
            for j:=v[len(v)-1]+1; j&lt;len(nums); j++ {
                temp := make([]int, len(v))
                copy(temp, v)
                temp = append(temp, j)
                nextQueue = append(nextQueue, temp)
            }
        }
        queue = nextQueue
    }
    return res
}</code></pre>
<p>从0开始每次加一，其二进制是000， 001，010，011，100，101，110，111，刚好和下标对应，是子集的下标。</p>
<pre><code class="go">func subsets(nums []int) [][]int {
    var n = uint(len(nums))
    res := make([][]int, 0, 1 &lt;&lt; n)
    var i uint
    for i = 0; i &lt; 1&lt;&lt;n; i++ {
        s := make([]int, 0)
        var j uint
        for j = 0; j &lt; n; j++ {
            if i&amp;(1&lt;&lt;j) != 0 {
                s = append(s, nums[j])
            }
        }
        res = append(res, s)
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/18/VQxfTCL1MomjRaI.jpg" alt="Jietu20200318-132632@2x"></p>
<p>固定矩形2，只要一号在二号矩形之外就可以。</p>
<pre><code class="go">func isRectangleOverlap(rec1 []int, rec2 []int) bool {
    return !(rec1[1] &gt;= rec2[3] || rec1[3] &lt;= rec2[1] || rec1[2] &lt;= rec2[0] || rec1[0] &gt;= rec2[2])
}</code></pre>
<p><img src="https://i.loli.net/2020/03/18/B3EvAY4xiJ1t5Pr.jpg" alt="Jietu20200318-213817@2x"></p>
<p>确实很有东西，注意递归传递前序遍历的slice，巧妙的用到了前序和中序遍历结果的性质。</p>
<pre><code class="go">func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }

    // 中顺序列找根结点
    var root int
    for k, v :=  range inorder {
        if v == preorder[0] {
            root = k
            break
        }
    }

    // 左右子树归类
    // pre_left, pre_right := preorder[1: root+1], preorder[root+1:]
    // in_left, in_right := inorder[0: root], inorder[root+1:]

    // 左右子树递归
    return &amp;TreeNode{
        Val:   preorder[0],
        Left:  buildTree(preorder[1: root+1], inorder[0: root]),
        Right: buildTree(preorder[root+1:], inorder[root+1:]),
    }
}</code></pre>
<p><img src="https://i.loli.net/2020/03/18/6QaEevJyIp3nB5x.jpg" alt="Jietu20200318-220617@2x"></p>
<pre><code class="go">func buildTree(inorder []int, postorder []int) *TreeNode {
    if len(inorder) == 0 || len(postorder) == 0 {
        return nil
    }
    var root int
    for i, v := range inorder {
        if v == postorder[len(postorder)-1] {
            root = i
            break
        }
    }

    return &amp;TreeNode{
        Val: inorder[root],
        Left: buildTree(inorder[:root], postorder[:root]),
        Right: buildTree(inorder[root+1:], postorder[root:len(postorder)-1]),
    }
}</code></pre>
<p><img src="https://i.loli.net/2020/03/19/Q1Hcb93TCxEpAUD.jpg" alt="Jietu20200319-223944@2x"></p>
<p>回溯加剪枝，问题在于如果是一棵满二叉树会有性能退化。</p>
<pre><code class="go">func countNodes(root *TreeNode) int {
    if root == nil {
        return 0
    }
    num, success := 0, false
    depth := deep(root, &amp;success, &amp;num)
    return (1&lt;&lt;depth)-1-num
}

func deep(root *TreeNode, success *bool, num *int) int {
    if root.Left == root.Right {
        return 1
    }
    if root.Right == nil {
        (*num)++
        *success = true
        return 2
    }
    right := deep(root.Right, success, num)
    if *success {
        return right+1
    }
    left := deep(root.Left, success, num)
    if left != right {
        (*num) += (1&lt;&lt;right)
        *success = true
    }
    return left+1
}</code></pre>
<p><img src="https://i.loli.net/2020/03/23/yDObY7okaq5MTwn.jpg" alt="Jietu20200323-202237@2x"></p>
<p>用DFS会超时，因此这道题应该用动态规划，递推式为<code>dp[i] += dp[i-coins]</code></p>
<pre><code class="go">func change(amount int, coins []int) int {
    dp := make([]int, amount+1)
    dp[0] = 1
    for _, v := range coins {
        for i:=v;i&lt;=amount;i++ {
            dp[i] += dp[i-v] 
        }
    }
    return dp[amount]
}</code></pre>
<p><img src="https://i.loli.net/2020/03/23/DGxcU5tNSEI92zK.jpg" alt="Jietu20200323-223538@2x"></p>
<pre><code class="go">type timetable [][]int

func (a timetable) Len() int {
    return len(a)
}
func (a timetable) Swap(i, j int) {
    a[i], a[j] = a[j], a[i]
}
func (a timetable) Less(i, j int) bool {
    if a[i][0] &lt; a[j][0] {
        return true
    }
    return false
} 

func minMeetingRooms(intervals [][]int) int {
    if len(intervals) == 0 {
        return 0
    }
    sort.Sort(timetable(intervals))

    room := make([]int, 1)
    room[0] = intervals[0][1]
    for i:=1; i&lt;len(intervals); i++ {
        j := 0
        for ; j&lt;len(room);j++ {
            if intervals[i][0] &gt;= room[j] {
                room[j] = intervals[i][1]
                break
            } 
        }
        if j == len(room) {
            room = append(room, intervals[i][1])
        }
    }
    return len(room)
}</code></pre>
<p><img src="https://i.loli.net/2020/03/25/PglJq9SiEVI8syA.jpg" alt="Jietu20200325-075541@2x"></p>
<p>分步算，然后减去重复的</p>
<pre><code class="go">func surfaceArea(grid [][]int) int {
    res := 0
    min := func (a, b int) int {
        if a &lt; b {
            return a
        }
        return b
    }
    for i, v := range grid {
        for j, value := range v {
            if value != 0 {
                res += (6+(value-1)*4)
                if i != 0 &amp;&amp; grid[i-1][j] != 0 {
                    res -= min(value, grid[i-1][j])
                }
                if j != 0 &amp;&amp; grid[i][j-1] != 0 {
                    res -= min(value, grid[i][j-1])
                }
                if i != len(grid)-1 &amp;&amp; grid[i+1][j] != 0 {
                    res -= min(value, grid[i+1][j])
                }
                if j != len(grid)-1 &amp;&amp; grid[i][j+1] != 0 {
                    res -= min(value, grid[i][j+1])
                }
            }
        }
    }
    return res
}</code></pre>
<p>这个更机智一点，每次把左上两边重复的减去两次。</p>
<pre><code class="go">func surfaceArea(grid [][]int) int {
    res := 0
    for i:=0; i&lt;len(grid); i++ {
        for j:=0; j&lt;len(grid); j++ {
            if grid[i][j] &gt; 0 {
                res += 4 * grid[i][j] + 2
            }
            if j&gt;0 {
                res -= min(grid[i][j], grid[i][j-1]) * 2
            }
            if i&gt;0 {
                res -= min(grid[i][j], grid[i-1][j]) * 2
            }
        }
    }
    return res
}

func min(a, b int) int {
    if a &lt;= b {
        return a
    }
    return b
}</code></pre>
<p><img src="https://i.loli.net/2020/03/25/kgaOsW4lM7rNYwz.jpg" alt="Jietu20200325-214429@2x"></p>
<p>这题一样很强，我们可以发现最后拿到2的能赢，拿到1的输。<br>而奇数的约数只能是奇数或者1，操作之后是偶数。<br>而偶数的约数可以是奇偶或者1，我们可以用1来操作，是奇数。<br>分析可以得出，奇数输，偶数赢。</p>
<pre><code class="go">func divisorGame(N int) bool {
    res := (N&amp;1 == 0)
    return res
}</code></pre>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列扫盲</title>
    <url>/blog/2020/03/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<p>内容如题。<br>参考：</p>
<ol>
<li><a href="https://developer.51cto.com/art/201904/595020.html" target="_blank" rel="noopener">什么是消息队列？</a></li>
</ol>
<a id="more"></a>

<h2 id="消息队列有什么用"><a href="#消息队列有什么用" class="headerlink" title="消息队列有什么用"></a>消息队列有什么用</h2><h3 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p>
<p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<blockquote>
<p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p>
</blockquote>
<p>只有在<strong>业务流程允许异步处理</strong>的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p>
<h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><ol>
<li>点对点</li>
</ol>
<p>消息生产者向消息队列中发送了一条消息之后，只能被<strong>一个消费者消费一次</strong>。</p>
<ol start="2">
<li>发布/订阅</li>
</ol>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>高可用<br>需要是集群/分布式的</p>
</li>
<li><p>消费问题<br>重复消费和消息顺序问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet</title>
    <url>/blog/2020/03/03/Internet/</url>
    <content><![CDATA[<p>internet for my lovely offer.</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分组交换电路交换：<br>分组交换更加高效，利用率更高，利用了储存转发的思想。</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" alt="pic"></p>
<p>注意传输时延与传播时延：</p>
<ul>
<li>传输时延是主机或者路由器传输数据帧需要的时延</li>
<li>传播时延是数据在线路上传播需要的时延。</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="pic"></p>
<p>五层协议体系：</p>
<ul>
<li>应用层：HTTP、DNS、SMTP协议等</li>
<li>运输层：为<strong>进程提供通用的数据传输服务</strong>–TCP/UDP<ul>
<li>可靠性传输：TCP<ul>
<li>三次握手，四次挥手</li>
<li>数据单位为报文段</li>
<li>按字节确认</li>
</ul>
</li>
<li>用户数据报协议：<ul>
<li>不可靠、无链接</li>
</ul>
</li>
</ul>
</li>
<li>网络层：为主机提供数据传输服务 IP</li>
<li>链路层：针对的依旧是是主机间的传输服务 </li>
</ul>
<p>OSI体系：<br>在应用层和运输层之间添加了表示层和会话层</p>
<ul>
<li>表示层：处理数据，使得应用程序不需要关心在各台主机中数据内部格式问题。</li>
<li>会话层：建立及管理会话</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>这是一个分布式的数据库，提供主机名和服务器IP的转换服务。DNS是具有层次的。</p>
<p>DNS一般只使用UDP传输，端口号为53</p>
<p>只有在返回的响应超过512字节（UDP最大传输容量）或者进行区域传送（主服务器向辅助域名服务器传送变化的部分）使用TCP</p>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>文件传送协议，需要两个连接来传送一个文件：</p>
<ol>
<li>控制连接：打开端口号21等待客户端连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ol>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg"> </div><br>

<h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ul>
<li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：<strong>IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。</strong>该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关（第一跳路由器）。</p>
</li>
</ul>
<h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ul>
<li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li><p><strong>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</strong></p>
</li>
<li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</zero-width></zero-width></zero-width></zero-width></p>
</li>
<li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ul>
<li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ul>
<li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>网络层只负责将数据传递给主机，而真正通信的应该是主机中的进程。传输层提供了进程之间的逻辑通信，实现多路复用与多路分解。</p>
<p>端口————用于标记应用层进程或者是线程（16bit）</p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><ul>
<li><p>序号：对于字节流进行编号，表示传输数据的第一个字节的序号</p>
</li>
<li><p><strong>确认号</strong>：希望收到的下一段报文的序号（TCP是累计确认）</p>
</li>
<li><p><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li><p><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li><p><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li><p><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h3 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h3><ul>
<li>三次握手</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="pic"></p>
<ol>
<li>首先B处于监听状态，等待客户的连接请求。</li>
<li>A向B发送连接请求报文，SYN=1，ACK=0，选择一个初始序号x</li>
<li>B收到连接请求报文，如果统一建立连接则发送确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A收到B的连接确认之后，还要向B发出确认，确认号为y+1，序号为x+1</li>
<li>B收到A确认后连接建立</li>
</ol>
<p>三次握手的原因：<br>防止失效连接请求到达服务器，错误开启连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<ul>
<li>四次挥手</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="pic"></p>
<ol>
<li>A发送连接释放报文，FIN=1</li>
<li>B收到后发出确认，此时TCP为半关闭状态，B能向A发送数据但是A不能向B发送。</li>
<li>B不再需要连接时，发送连接释放报文。</li>
<li>A收到后进入TIME-WAIT状态，等待两个最大报文存活时间后释放连接</li>
<li>B收到A的确认请求后释放连接。</li>
</ol>
<p>四次挥手的原因：</p>
<p>客户端发送FIN连接释放报文之后，服务器收到了这个报文，进入CLOSE-WAIT状态等待报文传输结束后发送释放连接报文。</p>
<p>四次挥手的原因还有一个就是TCP是全双工，因此需要两边都关闭。</p>
<p><strong>TIME-WAIT</strong><br>客户端收到FIN报文后进入此状态，并不直接close，因为：</p>
<ol>
<li>确保最后一个报文能到达，如果A的释放确认报文没有到达的话，B超时之后会重新发送释放请求报文，A等待就是为了处理这个。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ol>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>慢开始、拥塞避免、快速重传、快速恢复</p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>最开始cwnd为1，慢开始阶段没收到一个ACK，cwnd++，因此发送方能发送的报文数量为2，4，6，8.。。。</p>
<p>当cwnd达到之前设置好的ssthresh时，进入拥塞避免阶段，cwnd线性增长。</p>
<p>如果超时则，ssthresh=cwnd/2，重新慢开始</p>
<h4 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h4><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时<strong>直接进入拥塞避免</strong>。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层是整个互联网的核心，因此应当让网络层尽可能简单，使用IP协议可以把异构的物理网络连接起来，是的网络成看起来像是一个统一的网络。</p>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="ip"></p>
<ul>
<li><p><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。</p>
</li>
<li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。<strong>片偏移的单位为 8 字节。</strong></p>
</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt="pic"></p>
<h3 id="IP地址编码"><a href="#IP地址编码" class="headerlink" title="IP地址编码"></a>IP地址编码</h3><ol>
<li>分类：网络号+主机号，不公的分类具有不同的固定的网络号长度</li>
<li>子网划分：网络号中划分一部分作为子网，IP地址变为三级，使用时需要子网掩码</li>
<li>无分类（网络前缀）：CIDR =&gt; 路由聚合<br>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。<br>路由表中项目由“网络前缀”和“下一跳地址”组成，遵循最长前缀匹配原则。</li>
</ol>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p>网络层实现主机之间的通信，而链路层负责每段具体链路的通信。因此在实际传输过程中，IP数据报的源地址和目的地址始终不变，MAC地址一直在改变。</p>
<p>而ARP协议可以通过IP地址得到MAC地址。</p>
<h3 id="虚拟专用网络"><a href="#虚拟专用网络" class="headerlink" title="虚拟专用网络"></a>虚拟专用网络</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p><img src="https://i.loli.net/2020/03/08/uAk8QLew3HZPr27.jpg" alt="Jietu20200308-170712@2x"></p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>开放最短路径优先算法，洪泛式交换节点的信息，快速收敛，通过Dijkstra算法计算最短路径。</p>
<p>其基于IP做洪泛式信息交换使得每个主机都可以维护整个网络的拓扑结构。</p>
<p>当状态变化时通知其他主机，即使没有变化，每30分钟也要通信一次。</p>
<p>其通信具有序列号，并使用MD5加密。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5wiki</a></p>
</blockquote>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
</ul>
</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器</p>
<h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为   <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" alt="pic"></p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" alt="pic"></p>
<h2 id="HTTP-TCP-UDP"><a href="#HTTP-TCP-UDP" class="headerlink" title="HTTP/TCP/UDP"></a>HTTP/TCP/UDP</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">http参考文章</a></p>
<p>http是一个客户端终端和服务器端请求和应答的标准。</p>
<p>http协议中并未指定必须使用的层。http实际可以运行在任何协议上，只不过其假定下层协议提供可靠的传输，因此，任何提供这种保证的下层协议都可以被使用。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>协议定义了客户端如何从服务器请求web页面，以及服务器如何将web页面返回客户端。</p>
<p>http协议使用了请求/响应模型：<br>客户端向服务器端发送一个请求报文，其中包括<strong>请求的方法、URL、协议版本以及请求头部和请求数据</strong>。服务器则以一个状态行作为响应，内容包括协议版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>在浏览器键入一个url，会经历一下流程：</p>
<ol>
<li>dns解析url域名中对应的ip地址</li>
<li>解析出ip地址之后，根据ip和默认端口号80，和服务器建立tcp连接。</li>
<li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li>
<li>服务器根据请求内容作出响应，返回相应报文</li>
<li>根据连接类型断开连接或者维持一段时间。</li>
<li>浏览器页面渲染。</li>
</ol>
<p>http是一种无状态的协议，也就是说其自身不对请求/响应之间的通讯状态进行保存。也就是说，在协议级别，不对之前的请求和响应做保存。</p>
<p>cookie技术是解决这个问题的方式。</p>
<h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><p>http/1.1中一共有8种方法：</p>
<ol>
<li><p>GET<br>向指定资源发起请求。该方法应只用在读取数据，而不应当用在产生副作用的操作中。原因是get可以被爬虫随意访问。</p>
</li>
<li><p>HEAD<br>同get类似，是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。</p>
</li>
<li><p>POST<br>向指定资源提交数据，请求服务器进行处理。数据被放在请求体中，可能会创建资源或者修改资源。</p>
</li>
<li><p>PUT<br>向指定位置上传其最新内容。</p>
</li>
<li><p>DELETE<br>请求服务器删除标识资源。</p>
</li>
<li><p>TRACE<br>回显服务器收到的请求，用于调试</p>
</li>
<li><p>OPTIONS<br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
<li><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p>
</li>
</ol>
<p>⚠️注意事项：</p>
<ol>
<li><p>方法名区分大小写。<br>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p>
</li>
<li><p>服务器至少应当实现GET或者HEAD方法，其他方法都是可选的。</p>
</li>
</ol>
<h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><p>所有的http响应第一行都是状态码，依次是http版本号、三位状态码、以及描述状态的短语由空格分隔。</p>
<table>
<thead>
<tr>
<th>开头</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3</td>
<td>重定向状态码</td>
<td>需要附加请求以完成操作</td>
</tr>
<tr>
<td>4</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><p>超文本传输协议的统一资源定位符将从因特网获取信息的<strong>五个基本元素</strong>包括在一个简单的地址中：</p>
<ul>
<li>传送协议</li>
<li>层级URL标记符号（为//，固定不变）</li>
<li>访问资源的凭证信息（可以省略）</li>
<li>服务器（通常为域名，也可以为ip地址）</li>
<li>端口号（数字方式表示，如果为默认值可以省略）</li>
<li>路径（以/划分每一层目录名称）</li>
<li>查询（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）</li>
<li>片段（以#为起点，前段路由hash模式）</li>
</ul>
<h4 id="http请求-响应格式"><a href="#http请求-响应格式" class="headerlink" title="http请求/响应格式"></a>http请求/响应格式</h4><p><img src="https://i.loli.net/2020/03/06/RiWD5GPCMzmvyo2.jpg" alt="Jietu20200306-153746@2x"></p>
<p><img src="https://i.loli.net/2020/03/06/OZrnNMlbTEHtm92.jpg" alt="Jietu20200306-153814@2x"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP收到数据后需要发送一个确认，但是不是立即发送的，需要等待几分之一秒。</p>
<p>TCP保持<strong>首部和数据</strong>的检验和，这个检验和是端到端的，如果有变化则丢弃不要。</p>
<p>TCP用序号来标识发送的字节流，其中序号标识发送的报文段中的第一个数据字节，序号是32位无符号整数，当到末尾后从0重新开始。</p>
<p>当建立一个新连接时，SYN标志为1。序号字段包含由这个主机选择的该链接的初始序号ISN。该主机要发送数据的第一个字节序号为这个序号加1，因为SYN标志占了一个序号。</p>
<p>确认序号包含发送确认一端所期望的下一个序号。因此确认序号是上次已经接收到的数据字节序号加1.只有ACK标志为1的时候确认才有效。</p>
<p>TCP为应用层提供全双工的链接，这意味着数据能在两个放心啊个上独立的传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p>
<p>TCP缺少选择确认或者选择否认，它只能累计确认。</p>
<p>TCP的流量控制由窗口来提供。窗口大小为字节数，窗口大小是一个16bit的字段。</p>
<p>TCP中还有一个比较常见的字段MSS，指的是可以传输块的最大大小。其实际上是与物理线路有关的。<br>其只能出现在SYN报文中。</p>
<p><img src="https://i.loli.net/2020/03/07/oNTuXQpfhawsFe4.jpg" alt="Jietu20200307-145330@2x"></p>
<h3 id="TCP的连接与终止"><a href="#TCP的连接与终止" class="headerlink" title="TCP的连接与终止"></a>TCP的连接与终止</h3><p><img src="https://i.loli.net/2020/03/07/TX9eD8ZK4fB5PrO.jpg" alt="Jietu20200307-145852@2x"></p>
<p>当一端为了建立连接而发送SYN时，需要为连接选择一个初始的序号，ISN是随时间改变的，因此每个连接都有不同的ISN。这样选择序号的目的在于防止在网络中被延迟的分组以后又被重传，而导致某个连接的一方对其错误解释。</p>
<p>建立一个连接需要三次握手，而终止需要四次挥手。这是因为TCP的半关闭，既然一个TCP连接是全双工，那么每个方向就必须单独关闭。</p>
<blockquote>
<p>半关闭是指TCP一端关闭了数据的发送之后还可以从另一端接收数据。</p>
</blockquote>
<p>BSD版中的TCP采用一种500ms的定时器，用于确定终止和连接中的所有超时。</p>
<p>当TCP的一端接收到FIN报文的时候，会给上层的应用一个文件结束符表明数据接收到头了。</p>
<p><img src="https://i.loli.net/2020/03/07/r3SiqIEkP7KUpTB.jpg" alt="Jietu20200307-151433@2x"></p>
<p><img src="https://i.loli.net/2020/03/07/bV52f3jPK7NmgcI.jpg" alt="Jietu20200307-151722@2x"></p>
<h4 id="2MSL的等待状态"><a href="#2MSL的等待状态" class="headerlink" title="2MSL的等待状态"></a>2MSL的等待状态</h4><p>MSL：最大报文生存时间，TCP实现选择的，可以是30s、1min、2min</p>
<p>这样可以防止最后一个ack丢失，等待另一段超时重发最后的FIN</p>
<p>这段时间内不能使用这个socket。</p>
<p>这段时间内任何迟到的报文将被丢弃。</p>
<p>存在一个问题，服务器主动关闭一个连接之后在2MSL的时间间隔内不能使用这个端口。</p>
<h3 id="复位报文段（RST-1）"><a href="#复位报文段（RST-1）" class="headerlink" title="复位报文段（RST=1）"></a>复位报文段（RST=1）</h3><p>产生复位的原因是连接请求到达时，目的端口没有在听。</p>
<p>也可以通过复位来进行异常释放。</p>
<p>当一方由于掉电等原因意外断开之后，接收到报文会以复位回应。</p>
<h3 id="同时打开-关闭"><a href="#同时打开-关闭" class="headerlink" title="同时打开/关闭"></a>同时打开/关闭</h3><p><img src="https://i.loli.net/2020/03/07/adC6cMlqKDoxUNe.jpg" alt="Jietu20200307-153946@2x"></p>
<p><img src="https://i.loli.net/2020/03/07/Dot3ATvkVj2RmS9.jpg" alt="Jietu20200307-154112@2x"></p>
<h3 id="超时与重传"><a href="#超时与重传" class="headerlink" title="超时与重传"></a>超时与重传</h3><p>TCP为每个连接维持4个不同的定时器：</p>
<ol>
<li>重传定时器使用于希望收到另一端的确认</li>
<li>persist定时器使窗口大小信息不断流动</li>
<li>keepalive检测一个空闲连接何时崩溃或重启</li>
<li>2MSL定时器</li>
</ol>
<p>RTT估测；</p>
<h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p><a href="https://www.cnblogs.com/cangqinglang/p/11503057.html" target="_blank" rel="noopener">https://www.cnblogs.com/cangqinglang/p/11503057.html</a></p>
<p><a href="https://www.cnblogs.com/sui776265233/p/9289858.html" target="_blank" rel="noopener">https://www.cnblogs.com/sui776265233/p/9289858.html</a></p>
<p>只有TCP会粘包，UDP不会。<br>粘包的主要原因是接收方不知道你要发多少。</p>
<p>主要是由于TCP的negal算法导致的。</p>
<p>其为了减少网络中的报文数量，收集很多小数据直到达到一定值才发送。</p>
]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>internet</tag>
      </tags>
  </entry>
  <entry>
    <title>operating system</title>
    <url>/blog/2020/03/03/operating-system/</url>
    <content><![CDATA[<p>面试准备之操作系统篇</p>
<a id="more"></a>

<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是资源分配的基本单位，线程是进程的执行路径，不拥有资源只可以访问隶属于进程的资源。</p>
<p>进程撤销的系统开销要远大于线程</p>
<p>线程可以直接通过进程中的数据通信，而进程需要通过IPC（进程通信）</p>
<p>进程状态：创建，就绪，等待，执行，僵尸（已经结束但是还没有被父进程回收），终结</p>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol>
<li>批处理系统<br>没有很多用户操作，需要保证吞吐量和周转时间。</li>
</ol>
<p>先来先服务、短作业优先、最短剩余时间优先。</p>
<ol start="2">
<li>交互式系统（分时系统）<br>Round Robin、优先级调度、多级优先调度（结合RR和优先级算法）</li>
</ol>
<p>多级优先调度需要根据系统目标来定义进程优先度调节算法。</p>
<ol start="3">
<li>实时系统<br>要求在在一个确定的时间之内得到响应</li>
</ol>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>临界区与临界资源：访问临界资源的代码称作临界区<br>临界区需要仔细检查</p>
<p>同步和互斥</p>
<ul>
<li>同步是多个进程因为合作而产生制约关系，进程之间需要有先后执行次序</li>
<li>互斥是同一时刻只有一个进程可以进入临界区。</li>
</ul>
<p>信号量（semaphore）<br>是一个整型变量，其初始值不小于零，可以表示资源数量。</p>
<p>对于信号量的操作————P、V操作</p>
<ul>
<li>P操作是获取资源的操作，对信号量-1如果结果大于零，则执行反之则阻塞</li>
<li>V操作释放资源，对信号量加一，如果大于等于零则唤醒一个因为该信号量而进入阻塞状态的进程。</li>
</ul>
<p><strong>P、V操作是原子操作。</strong></p>
<p>生产者消费者问题————两个信号量一个表示空余缓冲区一个表示已使用缓冲区大小。<br>此时也应当注意互斥锁的使用。</p>
<blockquote>
<p>哲学家问题<br>可以限定两个条件：</p>
<ol>
<li>哲学界只能同时拿起左右两个筷子</li>
<li>左右两个人都不在吃才能吃</li>
</ol>
</blockquote>
<pre><code class="c">#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&amp;mutex);
    state[i] = HUNGRY;
    check(i);
    up(&amp;mutex);
    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&amp;mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&amp;mutex);
}

void eat(int i) {
    down(&amp;mutex);
    state[i] = EATING;
    up(&amp;mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&amp;s[i]);
    }
}</code></pre>
<blockquote>
<p>读者写者问题<br>第一个读者加锁，需要一个mutex保护记录读者数量的变量。</p>
</blockquote>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程通信与进程同步不能混淆：</p>
<ul>
<li>进程通信是一种手段</li>
<li>进程同步是一个目的，是为了使进程按一定顺序执行。</li>
</ul>
<ol>
<li>管道（pipe）</li>
</ol>
<pre><code class="c">#include &lt;unistd.h&gt;
int pipe(int fd[2])</code></pre>
<p>fd[0]用于读，fd[1]用于写<br>具有以下限制：</p>
<ul>
<li>只能半双工通信，单向交替传输</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<ol start="2">
<li>FIFO（命名管道）</li>
</ol>
<p>去除了管道只能用于父子进程中的限制。</p>
<pre><code class="c">#include &lt;sys/stat.h&gt;
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);</code></pre>
<p>常用于C-S应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<p>使用命名管道可以不关注网络层协议的具体细节。</p>
<ol start="3">
<li>消息队列</li>
</ol>
<p>消息队列可以进行削峰和解耦合</p>
<ol>
<li>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</li>
<li>模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。以发布-订阅模式为例，订阅消息的进程无需关心消息的产生。</li>
</ol>
<p>缺点是系统可用性降低、复杂性增高、由于消息可能被错误消费或者多次消费，也存在一致性的问题。</p>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
<blockquote>
<p>go —– nsq</p>
</blockquote>
<ol start="4">
<li>信号量</li>
</ol>
<p>一个计数器，用于为多个进程提供对共享数据对象的访问</p>
<ol start="5">
<li>共享储存</li>
</ol>
<p>允许多个进程同时使用一片储存区域。是最快的一种IPC</p>
<p>需要使用信号量来控制对共享内存的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。</p>
<ol start="6">
<li>socket</li>
</ol>
<p>实现了不同计算机间的进程通信。</p>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" alt="pic"></p>
<ul>
<li>预处理阶段：处理以#开头的预处理命令</li>
<li>编译阶段： 翻译成汇编文件</li>
<li>汇编文件： 将汇编文件汇编为可重定位目标文件</li>
<li>链接阶段： 将可重定向文件和单独编译的目标文件合并，得到可执行目标文件。</li>
</ul>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg" alt="pic"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><p>MMU中保存着页表，负责虚拟页号和物理页号之间的转换，其中最后一位是有效位。</p>
<p>虚拟地址分为两部分，一部分是页面号，另一部分是偏移量。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>和缓存的淘汰算法类似</p>
<ol>
<li>最佳算法（OPT）</li>
</ol>
<p>是理想的算法，换出去的是将来最长时间不会被使用的。</p>
<ol start="2">
<li>LRU（最久未使用）</li>
</ol>
<p>使用一个链表来维持页面，该页面被使用之后放在队尾，每次置换从队头开始。</p>
<p>这样实现代价比较高。</p>
<ol start="3">
<li>最近未使用（NRU)</li>
</ol>
<p>每个页面具有两个状态位：R和M，当页面被访问时设置页面为R=1，当被修改时，设置M为1.其中R会定时清零，因此页面分为四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<ol start="3">
<li><p>FIFO</p>
</li>
<li><p>第二次机会算法</p>
</li>
</ol>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<p>使用链表有移动链表节点的性能代价，可以使用环形链表用一个指针指向最老的页面即可。</p>
<h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul>
<li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p>
</li>
<li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</li>
<li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</li>
<li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ol>
<li>先来先服务</li>
</ol>
<p>优点是简单公平，缺点是未做任何优化</p>
<ol start="2">
<li>最短寻道优先</li>
</ol>
<p>优先调度与当前刺头所在磁道最近的的磁道</p>
<ol start="3">
<li>电梯算法</li>
</ol>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><a href="https://blog.csdn.net/wljliujuan/article/details/79614019" target="_blank" rel="noopener">参考网页</a></p>
<h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><ol>
<li>互斥条件</li>
<li>不可抢夺条件</li>
<li>请求和保持</li>
<li>循环等待</li>
</ol>
<h3 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ol>
<li>系统资源不足</li>
<li>程序推进顺序不合理</li>
</ol>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ol>
<h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，装作无事发生。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟算法反而会获得更高的性能</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p>死锁检测代价过于高昂。</p>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<ol>
<li>每种类型一个资源的死锁检测</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"> </div><br>

<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<ol start="2">
<li>每种类型多个资源的死锁检测</li>
</ol>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"> </div><br>

<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li><p>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</p>
</li>
<li><p>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</p>
</li>
<li><p>如果没有这样一个进程，算法终止。</p>
</li>
<li><p>死锁恢复</p>
</li>
</ol>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>破坏四个必要条件即可。</p>
<p>如资源统一标号，只能顺序向上请求（破坏环路等待）<br>或者静态分配资源</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>银行家算法。</p>
<p>安全状态定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<h2 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h2><ul>
<li>关于字符设备和块设备的更多区别：</li>
</ul>
<p>块设备只能以块为单位接受输入和返回输出，而字符设备则以字节为单位。大多数设备是字符设备，因为它们不需要缓冲而且不以固定块大小进行操作。 块设备对于I/O 请求有对应的缓冲区，因此它们可以选择以什么顺序进行响应，字符设备无须缓冲且被直接读写。对于存储设备而言调 读写的顺序作用巨大，因为在读写连续的扇区比分离的扇区更快。 字符设备只能被顺序读写，而块设备可以随机访问。虽然块设备可随机访问，但是对于磁盘这类机械设备而言，顺序地组织块设备的访问可以提高性能。</p>
<h2 id="进程和线程的主要区别"><a href="#进程和线程的主要区别" class="headerlink" title="进程和线程的主要区别"></a>进程和线程的主要区别</h2><p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p>在开销方面：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）线程组之间只能共享资源。</p>
<p>包含关系：没有线程的进程可以看作是单线程的。如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>守护进程（ daemon)</strong>是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务 。 守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断 。</p>
<p>僵尸进程是指该进程已经结束但是没有被父进程回收资源。可以通过kill父进程使其编程孤儿进程，由init进程接管。</p>
]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer--gogogo</title>
    <url>/blog/2020/03/02/%E5%89%91%E6%8C%87offer-gogogo/</url>
    <content><![CDATA[<p>一直有听说这本书，决定刷一下leetcode上的这个题。</p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/03/02/F5hs7bkZJuMrCfD.jpg" alt="Jietu20200302-181515@2x"></p>
<p>下面这个题解是一个0ms的题解，蛮巧妙</p>
<pre><code class="go">func canConstruct(ransomNote string, magazine string) bool {
    caps := make([]int, 26)
    for _, v := range ransomNote {
        idx := indexOf(v, magazine, caps[v-97])
        if idx == -1 {
            return false
        }
        caps[v-97] = idx + 1
    }
    return true
}

func indexOf(c int32, magazine string, fromIdx int) int {
    for i := fromIdx; i &lt; len(magazine); i++ {
        c1 := magazine[i]
        if int32(c1) == c {
            return i
        }
    }
    return -1
}</code></pre>
<p>我的解法，其实时间复杂度差不多。空间复杂度也一样。</p>
<pre><code class="go">func canConstruct(ransomNote string, magazine string) bool {
    m := make([]int, 26)
    for _, v := range magazine {
        m[v - &#39;a&#39;]++
    }
    for _, v:= range ransomNote {
        m[v - &#39;a&#39;]--
        if m[v - &#39;a&#39;] &lt; 0 {
            return false
        }
    }
    return true
}</code></pre>
<p><img src="https://i.loli.net/2020/03/02/F6u4kqKvdmbVOMn.jpg" alt="Jietu20200302-204952@2x"></p>
<p>其实和这个题差不多，<a href="https://leetcode-cn.com/problems/consecutive-numbers-sum/solution/lian-xu-zheng-shu-qiu-he-by-leetcode/" target="_blank" rel="noopener">官方题解</a><br>也有拿双指针做的，一快一慢然后计算和，如果大于target则慢指针前进，小于则快指针前进</p>
<pre><code class="go">func findContinuousSequence(target int) [][]int {
    res := make([][]int, 0)
    for i:=int(math.Sqrt(float64(2*target))); i&gt;=2; i-- {
        judge := target - i * (i - 1) / 2
        if judge % i == 0 {
            begin := judge / i
            temp := make([]int, 0)
            for j:=0; j&lt;i; j++ {
                temp = append(temp, begin+j)
            }
            res = append(res, temp)
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/02/oFseV17HjfTYSgE.jpg" alt="Jietu20200302-213008@2x"></p>
<p>类似动态规划，保存每个滑动窗口的最大坐标，如果在窗口外则更新，每次滑动只看新加入的是否比现在维持的大。</p>
<pre><code class="go">func maxSlidingWindow(nums []int, k int) []int { 
    res := make([]int, 0)
    begin, end, max:= 0, k-1, -1
    for end&lt;len(nums) &amp;&amp; end &gt;= 0 {
        if max &lt; begin {
            max = findMax(nums, begin, end)
        } else {
            if nums[max] &lt;= nums[end] {
                max = end
            }
        }
        res = append(res, nums[max])
        begin++
        end++
    }
    return res
}

func findMax(nums []int, begin, end int) int {
    res := begin
    for i:=begin; i&lt;=end;i++ {
        if nums[res] &lt;= nums[i] {
            res = i
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/03/zQt238REaKIPMep.jpg" alt="Jietu20200303-113029@2x"></p>
<p>只有四种情况，逐步缩小范围就行了。</p>
<p>看了题解，还可以按层来模拟。</p>
<pre><code class="go">func spiralOrder(matrix [][]int) []int {
    rowbegin, rowend := 0, len(matrix)
    if rowend== 0 {
        return []int{}
    }
    cowbegin, cowend := 0, len(matrix[0])
    res := make([]int, 0,cowend*rowend)
    count := 0
    for cowbegin &lt; cowend &amp;&amp; rowbegin &lt; rowend {
        switch count {
            case 0:
                for i:=cowbegin; i&lt;cowend;i++{
                    res = append(res, matrix[rowbegin][i])
                }
                rowbegin++
            case 1:
                for i:=rowbegin; i&lt;rowend;i++ {
                    res = append(res, matrix[i][cowend-1])
                }
                cowend--
            case 2:
                for i:=cowend-1; i&gt;=cowbegin; i-- {
                    res = append(res, matrix[rowend-1][i])
                }
                rowend--
            case 3:
                for i:=rowend-1; i&gt;=rowbegin;i-- {
                    res = append(res, matrix[i][cowbegin])
                }
                cowbegin++
        }
        count = (count+1) % 4
    }
    return res
}</code></pre>
<h2 id="面试题03"><a href="#面试题03" class="headerlink" title="面试题03"></a>面试题03</h2><p><img src="https://i.loli.net/2020/03/25/EcVyAeKGxIYRovm.jpg" alt="Jietu20200325-185752@2x"></p>
<p>我们要将每个数i，放在数组的第i个位置，如果不是就进行交换。只是不明白书中为什么说至少交换两次就可以交换到指定的位置。</p>
<pre><code class="go">func findRepeatNumber(nums []int) int {
    for i:=0; i&lt;len(nums); i++ {
        for nums[i] != i {
            if nums[i] == nums[nums[i]] {
                return nums[i]
            }
            nums[i], nums[nums[i]] = nums[nums[i]], nums[i]
        }
    }
    return -1
}</code></pre>
<h2 id="面试题04"><a href="#面试题04" class="headerlink" title="面试题04"></a>面试题04</h2><p><img src="https://i.loli.net/2020/03/25/MHPFcwoKqfmLXhe.jpg" alt="Jietu20200325-194238@2x"></p>
<p>从右上角开始，如果大于目标则此列不要，小于则此行不要。（另外从左下角开始也可以）！</p>
<pre><code class="go">func findNumberIn2DArray(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
    row, cow := 0, len(matrix[0])-1
    for row&lt;len(matrix) &amp;&amp; cow &gt;=0 {
        if target &lt; matrix[row][cow] {
            cow--
        } else if target &gt; matrix[row][cow] {
            row++
        } else {
            return true
        }
    }
    return false
}</code></pre>
<h2 id="面试题34-二叉树中和为某一值的路径"><a href="#面试题34-二叉树中和为某一值的路径" class="headerlink" title="面试题34 二叉树中和为某一值的路径"></a>面试题34 二叉树中和为某一值的路径</h2><p><img src="https://i.loli.net/2020/03/25/IVpyCf9ha5tFWRo.jpg" alt="Jietu20200325-205003@2x"></p>
<pre><code class="go">func pathSum(root *TreeNode, sum int) [][]int {
    res, _ := helper(root, sum)
    reverse := func (a []int) {
        for i:=(len(a)-1)/2;i&gt;=0;i-- {
            a[i], a[len(a)-1-i] = a[len(a)-1-i], a[i]
        }
    }
    for _, v := range res {
        reverse(v)
    }
    return res
}

func helper(root *TreeNode, sum int) ([][]int, bool) {
    res := make([][]int, 0)
    if root == nil {
        return [][]int{}, false
    }
    if root.Val == sum &amp;&amp; root.Left == root.Right &amp;&amp; root.Left == nil {
        return [][]int{[]int{root.Val}}, true
    }
    lvalue, lsuc := helper(root.Left, sum-root.Val)
    rvalue, rsuc := helper(root.Right, sum-root.Val)
    if lsuc {
        for _, v := range lvalue {
            res = append(res, append(v, root.Val))
        }
    }
    if rsuc {
        for _, v := range rvalue {
            res = append(res, append(v, root.Val))
        }
    }
    return res, lsuc || rsuc
}</code></pre>
<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06 从尾到头打印链表"></a>面试题06 从尾到头打印链表</h2><p><img src="https://i.loli.net/2020/03/25/uZ7grfA4EMshloL.jpg" alt="Jietu20200325-205913@2x"></p>
<pre><code class="go">func reversePrint(head *ListNode) []int {
    res := make([]int, 0)
    for head != nil {
        res = append(res, head.Val)
        head = head.Next
    }
    length := len(res)
    if length == 0 {
        return res
    }
    for i:=(length-1)/2;i&gt;=0;i-- {
        res[i], res[length-i-1] = res[length-i-1], res[i]
    }
    return res
}</code></pre>
<h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07 重建二叉树"></a>面试题07 重建二叉树</h2><p><img src="https://i.loli.net/2020/03/25/anYSeQKuDArqvRP.jpg" alt="Jietu20200325-211903@2x"></p>
<pre><code class="go">func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder)==0 || len(inorder) == 0 {
        return nil
    }
    index := 0
    for ;index&lt;len(inorder); index++ {
        if inorder[index] == preorder[0] {
            break
        }
    }
    return &amp;TreeNode{
        Val: preorder[0],
        Left: buildTree(preorder[1:index+1], inorder[:index]),
        Right: buildTree(preorder[index+1:], inorder[index+1:]),
    }
}</code></pre>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>可以有三种方式：</p>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode/</a></p>
<p>讲道理，蛮机智。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>go标准库container使用</title>
    <url>/blog/2020/02/25/go%E6%A0%87%E5%87%86%E5%BA%93contains-List%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>这几天刷leetcode算法题树的部分的时候频繁的需要用到队列和栈，一开始我想拿slice实现，后面看了别人的题解中有用到list这个标准库，提供了一个双向的链表感觉很方便，就拿来一用</p>
<p>不过因为其使用interface{}类型来实现泛型，所以使用起来有一些需要注意的地方，所以用博客记录一下。</p>
<p>官方文档：<a href="https://go-zh.org/pkg/container/list/" target="_blank" rel="noopener">list文档</a></p>
<p>补充一下container库中剩下的内容。</p>
<a id="more"></a>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>首先list中储存了一个Element类型的变量，其定义如下：</p>
<pre><code class="go">type Element struct {

    // The value stored with this element.
    Value interface{}
    // contains filtered or unexported fields
}</code></pre>
<p>其中使用了接口类型定义Value，这样以来Element就可以实现存储任何值。</p>
<p>list的操作其实不难，定义在其中的方法看名字就能看出来是啥，使用的一个简单示例如下。</p>
<pre><code class="go">package main

import (
    &quot;container/list&quot;
    &quot;fmt&quot;
)

func main() {
    // Create a new list and put some numbers in it.
    l := list.New()
    e4 := l.PushBack(4)
    e1 := l.PushFront(1)
    l.InsertBefore(3, e4)
    l.InsertAfter(2, e1)

    // Iterate through list and print its contents.
    for e := l.Front(); e != nil; e = e.Next() {
        fmt.Println(e.Value)
    }

}</code></pre>
<h2 id="interface-类型断言"><a href="#interface-类型断言" class="headerlink" title="interface{}类型断言"></a>interface{}类型断言</h2><p>值得注意的只有一点，就是iterface在进行类型转换的时候是需要使用类型断言的。</p>
<pre><code class="go">func preorderTraversal(root *TreeNode) []int {
    stack := list.New()
    res := make([]int, 0)
    stack.PushBack(root)
    for stack.Len() &gt; 0 {
        cur  := stack.Back()
        curValue, _ := cur.Value.(*TreeNode)
        stack.Remove(cur)
        if curValue != nil {
            res = append(res, curValue.Val)
            stack.PushBack(curValue.Right)
            stack.PushBack(curValue.Left)
        }
    }
    return res
}</code></pre>
<p>比如刚刚做完的那道前序遍历的题，其中<code>curValue, _ := cur.Value.(*TreeNode)</code>就是一句类型断言。</p>
<p>类型断言是访问接口类型底层值的唯一方法，可以通过断言来在运行时检查interface中是否含有某种类型。上述的方法其实不够规范，因为忽略了后面返回的那个值。</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>container库中具有一个heap的接口，通过实现该接口，可以实现一个小顶堆。</p>
<p>接口的定义如下</p>
<pre><code class="go">type Interface interface {
    sort.Interface
    Push(x interface{}) // add x as element Len()
    Pop() interface{}   // remove and return element Len() - 1.
}</code></pre>
<p>其中sort.Interface是另一个包中的接口定义，提供了对于任意元素的排序方法，我们实现堆时，首先也要实现这个接口。</p>
<pre><code class="go">type Interface interface {
    // Len is the number of elements in the collection.
    // Len 为集合内元素的总数
    Len() int
    // Less reports whether the element with
    // index i should sort before the element with index j.
    //
    // Less 返回索引为 i 的元素是否应排在索引为 j 的元素之前。
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    // Swap 交换索引为 i 和 j 的元素
    Swap(i, j int)
}</code></pre>
<p>之后给出一个IntHeap和优先队列的例子。<a href="https://go-zh.org/pkg/container/heap/#pkg-examples" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS设置grub默认kernel</title>
    <url>/blog/2020/02/22/ECS%E8%AE%BE%E7%BD%AEgrub%E9%BB%98%E8%AE%A4kernel/</url>
    <content><![CDATA[<p>操作系统课设要编译内核，因为不想使用mac跑虚拟机所以选择租了阿里云一个ECS来进行。之前的步骤都进行的很愉快，直到我不管怎样设置grub都不能使用我新编译的那个内核。</p>
<p>设置默认内核的方法有这些：</p>
<ol>
<li><p>/etc/default/grub 修改这个文件。参考<a href="https://help.aliyun.com/knowledge_detail/58187.html?spm=5176.13910061.0.0.7241523fvOwstK&aly_as=tZCH4b4a" target="_blank" rel="noopener">阿里云手册</a></p>
</li>
<li><p>使用这个命令 <code>sudo grub-set-default</code>，最终我是使用这个解决的，但是需要注意的是，不能只给出内核的名字，还要写成这样<code>sudo grub-set-default &quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.4.137&quot;</code><a href="https://www.jianshu.com/p/c76bc5e113f1" target="_blank" rel="noopener">参考这个博客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Notes</title>
    <url>/blog/2020/02/17/Database-Notes/</url>
    <content><![CDATA[<p>看到很多大厂都有对于数据库掌握的要求，打算从mysql和Redis入手填充下数据库方面的知识栈。</p>
<a id="more"></a>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库是按照数据结构来组织、存储和管理数据的仓库，关系型数据库（RDBMS）是建立在关系模型上的数据库，借助于集合代数的方法和概念来管理数据库，关系型数据库有以下特点：</p>
<ol>
<li>数据以表格形式给出。</li>
<li>每行为各记录名称，每列为记录名称对应的数据域。</li>
<li>许多行列结合形成一张表单</li>
<li>若干表单组合成database</li>
</ol>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>mysql是最流行的关系型数据库管理系统，在web应用方面是最好的关系型数据库管理系统之一。</p>
<h3 id="创建数据库、删除数据库"><a href="#创建数据库、删除数据库" class="headerlink" title="创建数据库、删除数据库"></a>创建数据库、删除数据库</h3><pre><code class="sql">CREATE DATABASE database_names
drop database &lt;databaseName&gt;


mysqladmin -u root -p create database_names 
mysqladmin -u root -p drop databaseName
</code></pre>
<p>后者使用管理员权限创建数据库。删除时应当注意删除后所有的数据都将不在，所以需要一些权限去操作。</p>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>使用use命令选择数据库</p>
<pre><code class="sql">use databaseName</code></pre>
<p>mysql 中支持标准sql的数值类型，主要包括数值、日期和时间、字符串。<br><a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">mysql_data_types</a></p>
<p><strong>创建数据表：</strong></p>
<p><code>CREATE TABLE table_name (column_name column_type);</code><br>一般使用这样的语法来创建Mysql数据表</p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<p>解析：</p>
<ul>
<li>如果不想使用NULL可以设置为NOT NULL，这样建立NULL值时就会报错。</li>
<li>AUTO_INCREMENT设置自增属性，一般用于主键。</li>
<li>PRIMARY KEY关键字用于定义列为主键。可以使用多列来定义主键，列间以逗号分割</li>
<li>ENGINE=InnoDB DEFAULT CHARSET=utf8 前者设置引擎，后者设置编码</li>
</ul>
<p>⚠️注意：表名和字段名使用反引号而不是单引号</p>
<h3 id="数据库插入"><a href="#数据库插入" class="headerlink" title="数据库插入"></a>数据库插入</h3><pre><code class="sql">INSERT INTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );</code></pre>
<p>sql使用；作为分割语句的分隔符。</p>
<pre><code class="sql">INSERT INTO table_name  (field1, field2,...fieldN)  VALUES  (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;</code></pre>
<p>添加多列数据时使用逗号作为分割。</p>
<pre><code class="sql">mysql&gt; INSERT INTO runoob_tbl
    -&gt; VALUES
    -&gt; (0, &quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &#39;2016-05-06&#39;);</code></pre>
<p>如果每列都要添加数据可以不规定列。第一列主键如果不使用自增比较容易错乱，如果使用自增的话可以使用0或者NULL，这样添加数据可以自增。</p>
<h3 id="sql-select"><a href="#sql-select" class="headerlink" title="sql select"></a>sql select</h3><p>通过该语句可以查询数据：</p>
<pre><code class="sql">SELECT column_name,column_name
FROM table_name
[WHERE Clause]
[LIMIT N][ OFFSET M]</code></pre>
<p>命令解释：</p>
<ul>
<li>可以查询多个表，使用逗号分割即可，where中可以设置查询条件。</li>
<li>可以设置LIMIT属性来设定返回的记录数量。</li>
<li>可以痛殴OFFSET来设置偏移量</li>
</ul>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><blockquote>
<p>和if语句的作用一样，可以通过AND和OR制定过个条件。出了select语句歪还可以用与delete和update语句</p>
<p>where：数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p>
<p>group by:对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p>
<p>having：用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p>
<p>执行顺序</p>
<p>select –&gt;where –&gt; group by–&gt; having–&gt;order by</p>
</blockquote>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>可以用来更新数据</p>
<pre><code class="sql">UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]</code></pre>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><pre><code class="sql">DELETE FROM table_name [WHERE Clause]</code></pre>
<blockquote>
<p>delete，drop，truncate 都有删除表的作用，区别在于：</p>
<p> 1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。<br> 2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。<br> 3、执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。</p>
</blockquote>
<h3 id="like-子句"><a href="#like-子句" class="headerlink" title="like 子句"></a>like 子句</h3><p>like子句通常用于where语句中，以进行模糊搜索,一般和%一起使用，其中%和正则表达式中的*一样，表示任意字符。</p>
<h3 id="union语句"><a href="#union语句" class="headerlink" title="union语句"></a>union语句</h3><p>union语句可以连接多个select语句的结果，整合为一个结果集返回。其是默认不含有重复数据的，如果使用union all指令可以得到全部的数据，包括重复的在内。</p>
<p>注意其中select语句可以是一个完整的包含where限制条的语句。</p>
<pre><code class="sql">SELECT country, name FROM Websites
WHERE country=&#39;CN&#39;
UNION ALL
SELECT country, app_name FROM apps
WHERE country=&#39;CN&#39;
ORDER BY country;</code></pre>
<h3 id="mysql排序"><a href="#mysql排序" class="headerlink" title="mysql排序"></a>mysql排序</h3><p>使用mysql中的order by子句来设定哪个字段需要进行排序</p>
<pre><code class="sql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...
ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</code></pre>
<p>可以使用多个字段来排序<br>使用ASC和DESC来设置升序或者降序排列，默认为升序<br>where和like指令依然可以使用</p>
<h3 id="Group-by语句"><a href="#Group-by语句" class="headerlink" title="Group by语句"></a>Group by语句</h3><p>根据一个或者多个列对于结果集进行分组<br>在分组的列上面我们可以使用count avg sum等函数</p>
<pre><code class="sql">SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;</code></pre>
<blockquote>
<p>可是使用coalesce来设置一个取代NULL的语法 coalesce(a, b, c）如果是NULL则依次往后顺。</p>
</blockquote>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>用于连接两个不同的表中的数据，有三种连接方式：<br>INNER JOIN，LEFT JOIN，RIGHT JOIN</p>
<p>区别在于，第一个相当于取两个表的交集，而剩下两个连接方式不会管另一个表中是否有对应的数据，只返回一个表中符合标准的所有值</p>
<p>Example:</p>
<p><a href="https://www.runoob.com/mysql/mysql-join.html" target="_blank" rel="noopener">join</a></p>
<p><img src="https://i.loli.net/2020/02/19/lgQB1FiIYCKc9eX.jpg" alt="Jietu20200219-150659@2x"></p>
<p><img src="https://i.loli.net/2020/02/19/Mq1i4ewaWnNm5JZ.jpg" alt="Jietu20200219-150825@2x"></p>
<h3 id="NULL值处理"><a href="#NULL值处理" class="headerlink" title="NULL值处理"></a>NULL值处理</h3><p>三大运算符进行NULL值的比较：IS NULL，IS NOT NULL，&lt;=&gt;</p>
<h2 id="mysql-regex"><a href="#mysql-regex" class="headerlink" title="mysql regex"></a>mysql regex</h2><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配开始位置，如果设置了Multiline属性，也可以匹配\n \r</td>
</tr>
<tr>
<td>$</td>
<td>匹配结束位置</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符以为的任何单个字符</td>
</tr>
<tr>
<td>[abc.. ]</td>
<td>字符集合，用于匹配其中包含的任何字符</td>
</tr>
<tr>
<td>[^abc ]</td>
<td>字符集合取非</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或者多次</td>
</tr>
<tr>
<td>+</td>
<td>可以匹配前面的表达式一次或者多次</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配确定的n次</td>
</tr>
<tr>
<td>{n, m}</td>
<td>匹配n-m次</td>
</tr>
</tbody></table>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>用于处理操作量大，复杂度高的数据。（个人认为是数据库操作语句的集合）</p>
<blockquote>
<p>mysql中只有使用innodb引擎才可以使用事务</p>
</blockquote>
<p>一般来说事务需要有四个条件：<strong>原子性，一致性，独立性，持久性</strong></p>
<ol>
<li><p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ol>
<h3 id="alter命令"><a href="#alter命令" class="headerlink" title="alter命令"></a>alter命令</h3><p>用于修改数据表名或者修改数据表字段</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><ul>
<li><input disabled type="checkbox"> index</li>
</ul>
<h3 id="temporary-table"><a href="#temporary-table" class="headerlink" title="temporary table"></a>temporary table</h3><p>临时表顾名思义就是临时创建出来的用于保存临时数据的表，在连接关闭后会自动删除并释放空间。</p>
<pre><code class="sql">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (
    -&gt; product_name VARCHAR(50) NOT NULL
    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00
    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>mysql中也可以自定义函数，类似于大多数编程语言函数是一些语句的集合，用来将一些实现特定目的的语句组合起来来降低复杂度。但是注意，mysql中的函数注重返回值，一些语句是不能实现的。</p>
<p>函数只能返回一个值，不能够返回一个结果集。</p>
<p><strong>create</strong></p>
<pre><code class="sql">create function 函数名([参数列表]) returns 数据类型
begin
 sql语句;
 return 值;
end;</code></pre>
<p>example:</p>
<pre><code class="sql">-- 最简单的仅有一条sql的函数
create function myselect2() returns int return 666;
select myselect2(); -- 调用函数

--
create function myselect3() returns int
begin 
    declare c int;
    select id from class where cname=&quot;python&quot; into c;
    return c;
end;
select myselect3();
-- 带传参的函数
create function myselect5(name varchar(15)) returns int
begin 
    declare c int;
    select id from class where cname=name into c;
    return c;
end;
select myselect5(&quot;python&quot;);</code></pre>
<p><strong>call</strong></p>
<p>select + function</p>
<pre><code class="sql">-- 无参调用
select myselect3();
-- 传参调用
select myselect5(&quot;python&quot;);
select * from class where id=myselect5(&quot;python&quot;);</code></pre>
<p><strong>delete</strong></p>
<p><code>drop + function_name</code></p>
<p><strong>查看函数</strong></p>
<ul>
<li>查看函数创建语句：show create function 函数名;</li>
<li>查看所有函数：show function status [like ‘pattern’];</li>
</ul>
<h2 id="mysql变量"><a href="#mysql变量" class="headerlink" title="mysql变量"></a>mysql变量</h2><p>mysql中一共有四种变量：会话变量、全局变量、局部变量和用户变量，前两个统称为系统变量。</p>
<p><strong>用户变量</strong><br>顾名思义是用户定义的变量，有两种方式：</p>
<pre><code class="sql"># two ways use SET
SET @variable = expr
SET @variable := expr

# only be able to use := in select
SELECT @variable := expr</code></pre>
<ol>
<li>未定义变量的初始值为 null（可不定义变量直接使用，不会报错）</li>
<li>变量名对大小写不敏感</li>
<li>变量不能在要求字面值的地方使用，比如 select 中的 limit 语句等。</li>
<li>调用用户变量的表达式的计算顺序实际上是未定义的，如 <code>SELECT @a = 0, @a := @a + 1;</code>，两列都可能是 0 。</li>
</ol>
<p><strong>会话变量</strong><br>会话变量为服务器为每个客户端连接维护的变量。在客户端连接时，使用相应全局变量的当前值对客户端的会话变量进行初始化。</p>
<p>顾名思义，会话变量的作用域就是一个会话 Session 咯。</p>
<pre><code class="sql">set session var_name = value;
set @session.var_name = value;
set var_name = value;

show session variables;
# 以上代码会把所有会话变量罗列出来，可通过 like 进行过滤
show session variables LIKE &quot;%var%&quot;;</code></pre>
<p><strong>全局变量</strong><br>全局变量会影响服务器整体操作。但是一旦重启，这些设置会被重置。注意要想更改全局变量，必须具有SUPER权限。</p>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>事务是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用rollback进行回滚。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png" alt="pic"></p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol>
<li><p>原子性（Atomicity）<br>事务被视为不可分割的最小单元，事务要么全部提交成功，要么全部失败回滚。</p>
</li>
<li><p>一致性（Consistency）<br>数据库在事务执行前后都要保持一致性，即所有的事务对同一个数据的读取结果都是相同的。</p>
</li>
<li><p>隔离性（Isolation）<br>一个事务所做的修改在最终提交之前，对于其他事务不可见。</p>
</li>
<li><p>持久性（Durability）<br>一旦事务提交，其所做的修改将会永远保存在数据库中。</p>
</li>
</ol>
<p>⚠️这几个概念虽然简单但是并不是很好理解，主要因为其不是平级的关系。</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"> </div><br>

<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"> </div><br>

<h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"> </div><br>

<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"> </div><br>

<h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"> </div><br>

<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="上课笔记"><a href="#上课笔记" class="headerlink" title="上课笔记"></a>上课笔记</h1>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>datebase</tag>
      </tags>
  </entry>
  <entry>
    <title>做点应该做的</title>
    <url>/blog/2020/02/11/%E5%81%9A%E7%82%B9%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84/</url>
    <content><![CDATA[<p>进入社会大染缸前的必要准备</p>
<a id="more"></a>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><input disabled type="checkbox"> Notes</li>
</ul>
<ul>
<li>数据结构</li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> 链表</li>
<li><input disabled type="checkbox"> 树</li>
<li><input disabled type="checkbox"> 栈和队列</li>
<li><input checked disabled type="checkbox"> 哈希表</li>
<li><input checked disabled type="checkbox"> 字符串</li>
<li><input disabled type="checkbox"> 数组与矩阵</li>
<li><input disabled type="checkbox"> 图</li>
<li><input disabled type="checkbox"> 位运算</li>
</ul>
<ul>
<li>算法</li>
</ul>
<ul>
<li><input disabled type="checkbox"> 双指针</li>
<li><input disabled type="checkbox"> 贪心思想</li>
<li><input checked disabled type="checkbox"> 二分查找</li>
<li><input checked disabled type="checkbox"> 分治</li>
<li><input disabled type="checkbox"> 搜索</li>
<li><input disabled type="checkbox"> 动态规划</li>
<li><input disabled type="checkbox"> 数学</li>
<li><input disabled type="checkbox"> sort</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li><input disabled type="checkbox"> Notes</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><input disabled type="checkbox"> Notes</li>
</ul>
<h2 id="datebase"><a href="#datebase" class="headerlink" title="datebase"></a>datebase</h2><ul>
<li><input checked disabled type="checkbox"> mysql</li>
<li><input disabled type="checkbox"> redis</li>
</ul>
]]></content>
      <categories>
        <category>schedule</category>
      </categories>
      <tags>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode Notes</title>
    <url>/blog/2020/02/10/leetcode-Notes/</url>
    <content><![CDATA[<p>leetcode刷题笔记</p>
<a id="more"></a>

<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h3><p>题目描述：<br><img src="https://cdn.img.wenhairu.com/images/2020/02/10/m6tzN.jpg" alt="problem"></p>
<p>解法说明：</p>
<ol>
<li>暴力解法，按长度从高到低遍历字符串找到答案。</li>
<li>Manacher 算法（马拉车算法）</li>
</ol>
<h3 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h3><blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<p>马拉车算法 Manacher‘s Algorithm 是用来查找一个<strong>字符串的最长回文子串的线性方法</strong>，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们处理一个字符串的奇偶长度问题，选择在每个字符中间插入一个#，这样不论如何所有的字符长度都是奇数，而为了使其到达边界能够自动停止，我们可以在两端插入两个不相等的符号。<br><img src="https://i.loli.net/2020/03/06/JMQ2SW94LArtNCG.jpg" alt="Jietu20200306-160132@2x"></p>
<p>对于这样分割后的字符串我们只需要计算每个元素（包括#在内）的中心扩展后的长度然后即可计算出回文串的起始位置和长度。<br><img src="https://i.loli.net/2020/03/06/MOQphCjsU8fLVYI.jpg" alt="Jietu20200306-160227@2x"><br>起始的位置为P的下标i减去P[i]除以2即为字符串的起始下标，而最长回文串长度为P[i]</p>
<p><strong>马拉车算法的关键就在于计算P[i]</strong><br>我们使用C来表示当前循环中确定的驻点，而R为该回文串的右边半径，即为该回文串在右边的边界。边界位置为C+R<br>对于在C确定的回文串以内的点的P值，其实际和关于C对称的点的P值一样。<br><img src="https://i.loli.net/2020/03/06/WHh8o5O7xA3LVav.jpg" alt="Jietu20200306-160256@2x"><br>因为C+R以内是C确定的回文串范围，所以这个结论比较容易得到，但是有几种情况下，这个结论是不正确的。</p>
<ol>
<li><p>超出了R<br>i+p[i_mirrors] &gt; R，此时我们可以先将其扩展至R再依次往后扩展。</p>
</li>
<li><p>p[i_mirrors]遇到左边界<br>对于i使用正常的中心扩展即可。</p>
</li>
<li><p>i=R<br>对其赋值为0，然后使用正常的中心扩展。</p>
</li>
</ol>
<p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。<br>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。<br><img src="https://i.loli.net/2020/03/06/VbT8N6U37esdgRF.jpg" alt="Jietu20200306-160326@2x"></p>
<h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413.等差数列划分"></a>413.等差数列划分</h3><p>题目描述：<br><img src="https://cdn.img.wenhairu.com/images/2020/02/10/m6jJB.jpg" alt="题目描述"></p>
<p>求解思路：<br>使用动态规划进行求解，首先等差数列最至少应当由3个元素组成。<br>如果数组a是一个等差数列，且其之后的一个元素与a能组成等差数列的话，新的数组等差数列组数为<strong>sum(a)+len(a)-1</strong>，这个式子是我求解问题的核心思想。<br>那么我们从数组起始开始遍历，每次试图把当前数组的下一个元素加入目前的等差数列中，如果可以加入，则需要更新目前的遍历位置。</p>
<p>因为只遍历一次数组，所以时间复杂度为O(n), 空间复杂度应该为O(1)</p>
<p>代码如下：</p>
<pre><code class="go">func numberOfArithmeticSlices(A []int) int {
    dif := 0 //公差
    count := 0 //等差数列计数
    for i := 0; i &lt;= len(A)-3; i++ {
        if 2*A[i+1] == (A[i] + A[i+2]) {
            dif = A[i+1] - A[i]
            length := 3 //等差数列长度，起始为3
            count++ //首先这个3个元素的起始数列应当算上
            for {
                if length+i &gt;= len(A) { //计算到边界则直接返回
                    return count
                }
                if A[length+i]-A[length+i-1] == dif { //如果可以加入等差数列则更新count值
                    count += length - 1
                    length++
                } else {
                    i = length + i - 1 //如果不能加入到数列中，则只需要将i定位至当前等差数列的最后一个即可
                    break
                }
            }
        }
    }
    return count
}</code></pre>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://i.loli.net/2020/02/29/9nw1tIymVpa3Uor.jpg" alt="Jietu20200229-231214@2x"></p>
<p>根据时间复杂度要求可以看出需要二分查找<br>我是根据情况直接分情况进行了，题解中给出了找到最小点然后翻转回来再操作的方法。</p>
<pre><code class="go">func search(nums []int, target int) int {
    if len(nums) == 0 {
        return -1
    }
    low, high := 0, len(nums)-1
    for low &lt; high {
        mid := (high-low)/2 + low
        if target == nums[mid] {
            return mid
        }
        if mid == low {
            low++
            continue
        }
        if nums[mid] &gt;= nums[low] {
            if nums[mid] &lt; nums[high] {
                if target &gt; nums[mid] {
                    low = mid + 1
                } else {
                    high = mid - 1
                }
            } else {
                if target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] {
                    high = mid - 1
                } else {
                    low = mid + 1
                }
            }
        } else {
            if target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] {
                low = mid + 1
            } else {
                high = mid - 1
            }
        }
    }
    if nums[low] == target {
        return low
    }
    return -1
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAF8t.jpg" alt="problem"></p>
<p>这个题本身没什么难的，使用二分查找很容易得到结果，但是我因为一些go语言特性的问题，花了不少功夫来解决问题。<br>贴代码如下：</p>
<pre><code class="go">func nextGreatestLetter(letters []byte, target byte) byte {
    offset := search(letters, target)
    if offset &gt; int(&#39;z&#39;-target) {
        return byte(int(target) + offset - 26)
    }
    return byte(int(target) + offset)
}

func search(subLetters []byte, target byte) int {
    length := len(subLetters)

    if length == 1 {
        res := int(subLetters[0]) - int(target)
        //一开始使用byte型运算之后转为int，结果出乎意料，因为byte溢出
        if res &gt; 0 {
            return res
        }
        return res + 26
    }

    mid := length / 2
    left := search(subLetters[:mid], target)
    right := search(subLetters[mid:], target)
    if left &lt; right {
        return left
    }
    return right
}</code></pre>
<p>问题出在注释位置，此处一开始使用的是byte型直接计算，结果出现了溢出，导致结果十分离谱，以后注意，这个问题是ics时提到过的。</p>
<p>我就是个智障，上面的那道题我的做法是分治而不是二分查找，二分查找比较重要的条件在于<strong>一开始所给的就是一个有序的序列</strong>，然后我们才能进行二分查找。</p>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mANGS.jpg" alt="problem"></p>
<p>求开方也可以使用二分查找来完成。</p>
<pre><code class="go">func mySqrt(x int) int {
    // guessNum := x
    // for ;guessNum*guessNum &gt; x; {
    //     guessNum =guessNum/2
    // }
    // for ;guessNum*guessNum &lt;= x; {
    //     guessNum++
    // }
    // return guessNum-1

    if x == 1 {
        return 1
    }
    low, high, mid := 0, x, 0
    for low &lt; high-1 {
        mid = (high-low)/2 + low
        if mid*mid &gt; x {
            high = mid
        } else {
            low = mid
        }
    }
    return (high + low) / 2
}
</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAY4C.jpg" alt="problem34"></p>
<p>选择使用二分查找法，找到两边的边界，如果中间值为目标值，选择从中间往两边拓展，一开始重新构建一个slice头尾确定为一个不存在与原给定slice中的数字是为了更好的做后面的拓展操作，这样边界值更好处理。</p>
<pre><code class="go">func searchRange(nums []int, target int) []int {
    numsNew := make([]int, len(nums)+2)
    for i := range nums {
        numsNew[1+i] = nums[i]
    }
    numsNew[0], numsNew[len(nums)+1] = -1, -1

    low, high, mid := 1, len(nums), 0

    for {
        mid = low + (high-low)/2
        if numsNew[low] == numsNew[high] &amp;&amp; numsNew[low] == target {
            return []int{low - 1, high - 1}
        }
        if low &gt;= high {
            return []int{-1, -1}
        }
        if target &gt; numsNew[mid] {
            low = mid + 1
        } else if target &lt; numsNew[mid] {
            high = mid - 1
        } else {
            low, high = mid, mid
            for {
                if numsNew[low] == target {
                    low--
                }
                if numsNew[high] == target {
                    high++
                }
                if numsNew[low] != target &amp;&amp; numsNew[high] != target {
                    return []int{low, high - 2}
                }
            }

        }
    }
}</code></pre>
<h2 id="problem-153"><a href="#problem-153" class="headerlink" title="problem 153"></a>problem 153</h2><p><img src="https://cdn.img.wenhairu.com/images/2020/02/11/mAfLs.jpg" alt="problem153"></p>
<p>算是比较熟练的掌握了二分查找法，这个题的关键在于条件要考虑仔细了</p>
<pre><code class="go">func findMin(nums []int) int {
    low, high, mid := 0, len(nums)-1, 0

    for low &lt; high {
        mid = (high-low)/2 + low
        if (high - low) == 1 {
            if nums[high] &gt; nums[low] {
                return nums[low]
            }
            return nums[high]
        }// when the slice length is 2, return the min directly.
        if nums[mid] &lt; nums[mid-1] {
            return nums[mid]
        }
        if nums[mid] &gt; nums[high] {
            low = mid + 1
        } else if nums[mid] &lt; nums[low] {
            high = mid
        }
        if nums[low] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[high] {
            return nums[low]
        }
    }
    return nums[high]
}</code></pre>
<h2 id="分治算法-1"><a href="#分治算法-1" class="headerlink" title="分治算法"></a>分治算法</h2><p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAS1H.jpg" alt="problem95"></p>
<p>第一次一遍通过的题目，这个题一开始没有什么思路，后面想到可以使用递归求解，实际上属于一种分治的思想，依次选择划分递归调用左右两边的生成函数。<br>这道题对于我的难度大多在go语言本身上，声明nil时需要使用var语句 表明类型。</p>
<blockquote>
<p>卡特兰数</p>
</blockquote>
<pre><code class="go">func generateTrees(n int) []*TreeNode {
    res := generate(1, n)
    return res
}

func generate(begin, end int) []*TreeNode {
    res := make([]*TreeNode, 0)
    if begin == end {
        res = append(res, &amp;TreeNode{begin, nil, nil})
    }
    for i := begin; i &lt;= end; i++ {
        if i == begin {
            var l *TreeNode = nil
            for _, r := range generate(begin+1, end) {
                temp := TreeNode{i, l, r}
                res = append(res, &amp;temp)
            }
        }
        if i == end {
            var r *TreeNode = nil
            for _, l := range generate(begin, end-1) {
                temp := TreeNode{i, l, r}
                res = append(res, &amp;temp)
            }
        }
        if i &gt; begin &amp;&amp; i &lt; end {
            for _, l := range generate(begin, i-1) {
                for _, r := range generate(i+1, end) {
                    temp := TreeNode{i, l, r}
                    res = append(res, &amp;temp)
                }
            }
        }
    }
    return res
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAOQh.jpg" alt="problem241"></p>
<p>这个题我真的是个憨憨，花了大半个下午都没做对，一开始我选择以一个完整的算式为分割位置，这样处理既繁琐又不太对，因为字符串中的数字并不见得只有一个字符。后面参考了一下答案，得到了之后的结果，</p>
<pre><code class="go">import (
    &quot;strconv&quot;
    &quot;sort&quot;
)
func diffWaysToCompute(input string) []int {
    res := make([]int, 0)
    for i := 0; i &lt; len(input)-1; i++ {
        if input[i:i+1] == &quot;+&quot; || input[i:i+1] == &quot;-&quot; || input[i:i+1] == &quot;*&quot; {
            left := diffWaysToCompute(input[0:i])
            right := diffWaysToCompute(input[i+1:])
            for _, lvalue := range left {
                for _, rvalue := range right {
                    temp := 0
                    switch input[i : i+1] {
                    case &quot;+&quot;:
                        temp = lvalue + rvalue
                    case &quot;-&quot;:
                        temp = lvalue - rvalue
                    case &quot;*&quot;:
                        temp = lvalue * rvalue
                    }
                    res = append(res, temp)
                }
            }
        }
    }
    if len(res) == 0 {
        // a clever trick to handle with the string
        value, _ := strconv.Atoi(input)
        res = append(res, value)
    }
    sort.Ints(res)
    return res
}
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="https://i.loli.net/2020/02/29/7f2LBxRwQPHA3sF.jpg" alt="Jietu20200229-141257@2x"></p>
<p>常规的在前面加一个节点使操作更加简单，用一个slice模拟栈，遍历一遍链表实现求解。</p>
<pre><code class="go">func reverseKGroup(head *ListNode, k int) *ListNode {
    if k &lt;= 1 {
        return head
    }
    count, res, traversal := 0, &amp;ListNode{-1, head}, head
    head = res
    stack := make([]*ListNode, k)
    for traversal != nil {
        count++
        stack[count-1] = traversal
        traversal = traversal.Next
        if count == k {
            for i := k - 1; i &gt; 0; i-- {
                stack[i].Next = stack[i-1]
            }
            stack[0].Next = traversal
            head.Next = stack[k-1]
            head = stack[0]
            count = 0
        }
    }
    return res.Next
}</code></pre>
<p><img src="https://i.loli.net/2020/02/29/WZKQeJE8NRI3fiF.jpg" alt="Jietu20200229-203848@2x"></p>
<p>先提供一个复杂度有点高的算法。每次都遍历每个链表的头节点依次添加。<br>建议用下面的方法。</p>
<pre><code class="go">func mergeKLists(lists []*ListNode) *ListNode {
    head := &amp;ListNode{}
    p := head
    for true {
        index := 0
        var node *ListNode
        for i, nd := range lists {
            if node == nil {
                node = nd
                index = i
            } else if nd != nil &amp;&amp; node.Val &gt; nd.Val {
                node = nd
                index = i
            }
        }
        if node == nil {
            break
        }

        lists[index] = node.Next
        node.Next = nil
        p.Next = node
        p = p.Next
    }
    return head.Next
}</code></pre>
<p>用了多路归并，时间复杂度骤降😂<br><img src="https://i.loli.net/2020/02/29/IyDkdflgOq6JLzr.jpg" alt="Jietu20200229-205600@2x"></p>
<pre><code class="go">func mergeKLists(lists []*ListNode) *ListNode {
    switch len(lists) {
        case 0:
            return nil
        case 1:
            return lists[0]
        case 2:
            return mergeTwoList(lists[0], lists[1])
        default:
            mid := len(lists) / 2
            return mergeTwoList(mergeKLists(lists[:mid]), mergeKLists(lists[mid:])) 
    }
}

func mergeTwoList(list1, list2 *ListNode) *ListNode {
    res := &amp;ListNode{-1, nil}
    next := res
    for list1 != nil &amp;&amp; list2 != nil {
        if list1.Val &lt; list2.Val {
            next.Next = list1
            list1 = list1.Next
        } else {
            next.Next = list2
            list2 = list2.Next
        }
        next = next.Next
    }
    if list1 == nil {
        next.Next = list2
    } else {
        next.Next = list1
    }
    return res.Next
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAXmD.jpg" alt="problem"></p>
<p>这道题虽然很简单但是，解法可以十分巧妙。假设链表一的长度为a+c,链表二的长度为a+c，其中c为公共部分长度，当两者不相交时为0.这样我们可以通过使拼接使得链表的长度都为a+b+c，这样如果两个链表没有焦点访谈则会同时等于nil</p>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    l1, l2 := headA, headB
    for ;l1 != l2; {
        if l1 == nil {
            l1 = headB
        } else {
            l1 = l1.Next
        }
        if l2 == nil {
            l2 = headA
        } else {
            l2 = l2.Next
        }
    }
    return l1
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAiEs.jpg" alt="pic"></p>
<p>题目很简单，用了两种方法解决，应当注意的一点是，对go语言的一些特性还是不熟悉，题解给出的代码十分简介，我写的总是很冗长。</p>
<pre><code class="go">func reverseList(head *ListNode) *ListNode {
    rhead, tail := recursion_reverseList(head)
    tail.Next = nil
    return rhead
}

func recursion_reverseList(head *ListNode) (rhead, tail *ListNode) {
    if head.Next == nil {
        tail = head
        rhead = head
        return rhead, tail
    } else {
        rhead, tail = recursion_reverseList(head.Next)
        tail.Next = head
        tail = head
        return rhead, tail
    }
}

func reverseList(head *ListNode) *ListNode {
    prev,cur := &amp;ListNode{},head
    prev = nil
    for cur != nil{
        cur.Next,prev,cur = prev,cur,cur.Next
    }
    return prev
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mAsgR.jpg" alt="pic"></p>
<pre><code class="go">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    head := &amp;ListNode{0, nil}
    point := head
    for (l1 != nil) || (l2 != nil) {
        if l1 == nil {
            point.Next = l2
            return head.Next
        }
        if l2 == nil {
            point.Next = l1
            return head.Next
        }
        if l1.Val &lt;= l2.Val {
            point.Next, l1 = l1, l1.Next
            point = point.Next
        } else {
            point.Next, l2 = l2, l2.Next
            point = point.Next
        }

    }
    return head.Next
}
</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/13/mA2rN.jpg" alt="83"></p>
<p>真的佛了，这破题也能做半天，细节太重要了，就第三行的两个语句的次序都会影响结果</p>
<pre><code class="go">func deleteDuplicates(head *ListNode) *ListNode {
    cur := head
    for cur != nil &amp;&amp; cur.Next != nil {
        if cur.Val == cur.Next.Val {
            cur.Next = cur.Next.Next
            continue
        }
        cur = cur.Next
    }
    return head
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/14/mAtRn.jpg" alt="19"></p>
<p>做题果然是熟能生巧的一件事情，做多了之后，链表的题也得心应手起来了，这题使用递归来计算深度，进行删除节点的判断，需要注意边界值的判断，即起始位置。</p>
<p>查看题解之后发现这道题也可以使用双指针来求解，只需要使第一个指针比后面那个提前走n步，保证间隔即可。</p>
<pre><code class="go">func removeNthFromEnd(head *ListNode, n int) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    depth := traversal(head, n)
    if depth == n {
        head = head.Next
    }
    return head
}

func traversal(head *ListNode, n int) int {
    if head.Next == nil {
        return 1
    }
    depth := traversal(head.Next, n) + 1
    if depth == n+1 {
        head.Next = head.Next.Next
    }
    return depth
}
</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/14/mAzbA.jpg" alt="pic"></p>
<p>题目不难，不过有一点值得注意，为了使类似空链表或者只有一个节点的链表更容易操作，我在原链表前面添加了一个-1节点</p>
<pre><code class="go">func swapPairs(head *leetcodetool.ListNode) *leetcodetool.ListNode {
    cur := head
    var pre = &amp;leetcodetool.ListNode{-1, nil}
    pre.Next, head = head, pre
    for cur != nil &amp;&amp; cur.Next != nil {
        pre.Next, cur.Next, cur.Next.Next = cur.Next, cur.Next.Next, cur
        cur, pre = cur.Next, cur
    }
    return head.Next
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mu9iD.jpg" alt="pic"></p>
<pre><code class="go">func oddEvenList(head *ListNode) *ListNode {
    oddList, evenList := &amp;ListNode{-1, nil}, &amp;ListNode{-1, nil}
    oddHead, evenHead := oddList, evenList

    count := 1

    for head != nil {
        if count%2 == 1 {
            oddList.Next = head
            oddList = oddList.Next
        } else {
            evenList.Next = head
            evenList = evenList.Next
        }
        head = head.Next
        count++
    }
    head, oddList.Next, evenList.Next = oddHead.Next, evenHead.Next, nil
    return head
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mu1Ft.jpg" alt="pic725"></p>
<p>首先遍历链表计算长度，然后根据计算出来的长度来计算每个链表的长度，前length%k个为length/k+1，使用一个int slice储存，然后仔遍历一遍链表，按照存储的长度做划分即可</p>
<pre><code class="go">func splitListToParts(root *ListNode, k int) []*ListNode {
    length := 0
    for count := root; count != nil; count = count.Next {
        length++
    }

    split := make([]int, k)
    for i := range split {
        split[i] = length / k
    }
    for i := 0; i &lt; length%k; i++ {
        split[i]++
    }

    res := make([]*ListNode, 0)
    for _, splitLength := range split {
        temp := &amp;ListNode{-1, nil}
        head := temp
        for j := 0; j &lt; splitLength; j++ {
            temp.Next, root = root, root.Next
            temp = temp.Next
        }
        temp.Next = nil
        res = append(res, head.Next)
    }
    return res
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/17/mupnS.jpg" alt="pic234"></p>
<p>使用快慢指针来锁定链表后半段，慢指针每两次走一步，这样就可以确定中点位置，然后倒置后半段即可</p>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
    slow, traversal := head, head

    count := 0
    for traversal != nil &amp;&amp; traversal.Next != nil {
        traversal = traversal.Next
        count++
        if count%2 == 0 {
            slow = slow.Next
        }
    }

    slow, _ = invertList(slow)

    for slow != nil &amp;&amp; head != nil {
        if slow.Val != head.Val {
            return false
        }
        slow, head = slow.Next, head.Next
    }
    return true
}

func invertList(head *ListNode) (invertHead, tail *ListNode) {

    if head == nil || head.Next == nil {
        return head, head
    }
    ihead, tail := invertList(head.Next)
    tail.Next, head.Next = head, nil
    tail = tail.Next
    return ihead, tail
}
</code></pre>
<h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>hashmap使用O(N)来存储数据，使用<strong>常数时间</strong>来查找数据</p>
<p><img src="https://i.loli.net/2020/02/17/vpWnYVXrJ1IKAN5.jpg" alt="Jietu20200217-220621@2x"></p>
<p>这道题因为要时间界为n，考虑到任何基于比较的排序算法的下界为nlogn，所以想到使用hash表来实现，查看了关于map的定义，发现其是hash的一种实现，所以通过map存储数组元素。然后来看有多少个连续的元素。<br>注意就是内部循环需要对遍历过的元素做标记，否则会超时。</p>
<pre><code class="go">func longestConsecutive(nums []int) int {
    m := make(map[int]bool)
    res := 0

    for _, value := range nums {
        m[value] = true
    }

    for _, value := range nums {
        if m[value] {
            length := 1
            for i := value + 1; m[i]; i++ {
                length++
                m[i] = false
            }
            for i := value - 1; m[i]; i-- {
                length++
                m[i] = false
            }
            if res &lt;= length {
                res = length
            }
        }
    }

    return res
}
</code></pre>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><img src="https://i.loli.net/2020/03/09/X5KzmSN8GhLVfBl.jpg" alt="Jietu20200309-173302@2x"></p>
<p><img src="https://i.loli.net/2020/02/19/PTrDVy9bLY2Hvg5.jpg" alt="Jietu20200219-180808@2x"></p>
<p>使用数组长度为26的字符存储</p>
<pre><code class="go">func isAnagram(s string, t string) bool {
    store := make([]int, 26)
    if len(s) != len(t) {
        return false
    }
    for i:=0; i&lt;len(s); i++ {
        store[s[i]-&#39;a&#39;]++
    }
    for i:=0; i&lt;len(t); i++ {
        store[t[i]-&#39;a&#39;]--
    }
    for _, value := range store {
        if value != 0 {
            return false
        }
    }
    return true
}</code></pre>
<p><img src="https://i.loli.net/2020/02/19/hIB4fET1gLWiNwA.jpg" alt="Jietu20200219-183807@2x"></p>
<p>用数组做的，题解里看到一个用map做的更简洁一些的版本，可以使用[]byte(s)将字符串转换为字符slice</p>
<pre><code class="go">func longestPalindrome(s string) int {
    store := make([]int, 52)
    sum,odd := 0,0

    if len(s) == 0 {
        return 0
    }

    for i:=0; i&lt;len(s); i++{
        index := int(s[i])-&#39;a&#39;
        if index &lt; 0 {
            index += 59 // handle the situation of capital char
        }
        store[index]++
    }

    for _, value := range store {
        if value % 2 == 0 {
            sum+=value
        } else {
            odd = 1
            sum+=(value-1)
        }
    }

    return sum+odd
}</code></pre>
<p><img src="https://i.loli.net/2020/02/19/Ao4sSInZX5L9vft.jpg" alt="Jietu20200219-185229@2x"></p>
<pre><code class="go">func isPalindrome(x int) bool {
    if x &lt; 0 {
        return false
    }

    y, _ := recursion(x)
    if x == y {
        return true
    }
    return false
}

func recursion(x int) (int, int) {
    if x &lt; 10 {
        return x, 1
    }
    num := x % 10
    sum, depth := recursion(x / 10)
    for i := 0; i &lt; depth; i++ {
        num = num * 10
    }
    return num + sum, depth + 1
}</code></pre>
<p>使用递归太过繁琐了，可以直接通过迭代实现的</p>
<pre><code class="go">func isPalindrome(x int) bool {
    if x &lt; 0 ||(x%10==0 &amp;&amp; x!=0){
        return false
    }

    var revertedNumber int
    for x &gt; revertedNumber{
        revertedNumber = revertedNumber * 10 + x%10
        x/=10
    }
    return revertedNumber == x || revertedNumber /10 == x
}</code></pre>
<p><img src="https://i.loli.net/2020/02/19/QdczrepGiDLCH9v.jpg" alt="Jietu20200219-231905@2x"></p>
<p>依次拓展字符串即可</p>
<pre><code class="go">func countSubstrings(s string) int {
    var chars = []byte(s)
    sum := 0

    for i := range chars {
        sum += count(chars, i, i)
        sum += count(chars, i, i+1)
    }
    return sum
}

func count(chars []byte, begin, end int) int {
    sum := 0
    for begin &gt;= 0 &amp;&amp; end &lt;= len(chars)-1 {
        if chars[begin] == chars[end] {
            sum = sum + 1
        } else {
            break
        }
        begin--
        end++
    }
    return sum
}</code></pre>
<h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p><img src="https://i.loli.net/2020/02/20/563XwoPvamHiQ1Y.jpg" alt="Jietu20200220-000113@2x"></p>
<pre><code class="go">func maxDepth(root *TreeNode) int {
    return getdep(root)
}

func getdep(root *TreeNode) int {
    if root == nil {
        return 0
    }

    left := getdep(root.Left)
    right := getdep(root.Right)
    if left &gt; right {
        return left+1
    }
    return right+1
}</code></pre>
<p><img src="https://i.loli.net/2020/02/20/d5gkVlGoEOHhDm8.jpg" alt="Jietu20200220-001452@2x"></p>
<p>使用上面的求高度的方法就能求解。</p>
<p><img src="https://i.loli.net/2020/02/20/lvKUAMzqFhxcyRp.jpg" alt="Jietu20200220-110652@2x"></p>
<p>值得注意的是一开始我把赋值语句分开写导致，left更改之后传递给right，代码死循环。</p>
<pre><code class="go">func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)

    return root
}</code></pre>
<p><img src="https://i.loli.net/2020/02/20/FyOL1DbfY9RAt7S.jpg" alt="Jietu20200220-160533@2x"></p>
<p>递归合并即可，不过我使用新的节点和在t1上原地修改空间差距不大。</p>
<pre><code class="go">func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil &amp;&amp; t2 == nil {
        return nil
    }
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }

    t1.Val = t1.Val+t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)

    return t1
}</code></pre>
<p><img src="https://i.loli.net/2020/02/22/LGtfRqxwMS74ngi.jpg" alt="Jietu20200222-231012@2x"></p>
<p>这个题使用了回溯的思想，保存了前缀和，通过前缀和的差来计算路径长度。值得学习。</p>
<p>这个题我有两个地方出了错误，第一是map应当初始化一个m[0]=1进去，不然没有和第一项的比对；第二点是这里的路径只有从上至下，一开始我考虑了从下至上的情况。</p>
<pre><code class="go">func pathSum(root *TreeNode, sum int) int {
    m := make(map[int]int)
    m[0]=1
    res := recursion(root, m, 0, sum)
    return res
}

func recursion(root *TreeNode, m map[int]int, pathSum int, sum int) int{
    var res int = 0
    if root == nil {
        return 0
    }

    curSum := pathSum + root.Val
    res += m[curSum-sum]

    m[curSum]+=1

    res += recursion(root.Left, m, curSum, sum) + recursion(root.Right,m, curSum, sum)

    fmt.Println(res, curSum)

    m[curSum]-=1
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/22/clN9AvK2sFOCZDd.jpg" alt="Jietu20200222-231327@2x"></p>
<p>我并没有想出这么巧妙的递归实现。应当注意可以这样对两个方向进行单个的递归操作。</p>
<pre><code class="go">func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return recursion(root.Left, root.Right)
}

func recursion(left *TreeNode, right *TreeNode) bool {
    if (left == nil &amp;&amp; right != nil)  || (left != nil &amp;&amp; right == nil){
        return false
    }
    if left == nil &amp;&amp; right == nil {
        return true
    }

    if left.Val != right.Val {
        return false
    }

    return recursion(left.Left, right.Right) &amp;&amp; recursion(left.Right, right.Left)
}</code></pre>
<p><img src="https://i.loli.net/2020/02/23/pWfgKMXTmd4EH2s.jpg" alt="Jietu20200223-113129@2x"></p>
<p>这道题按理说没啥难的，但是我用全局变量的时候，提交总是无法通过，关键是错误示例执行是可以通过的。一脸懵逼，这样以来代码就冗余不少，猜测是leetcode的全局变量的问题。</p>
<pre><code class="go">func diameterOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    left, left_max := getdep(root.Left)
    right, right_max := getdep(root.Right)
    sum := left + right


    if left_max &gt;= sum &amp;&amp; left_max &gt;= right_max  {
        return left_max
    } else if right_max &gt;= sum &amp;&amp; left_max &lt;= right_max {
        return right_max
    } else {
        return sum
    }
}

func getdep(root *TreeNode) (depth, max int) {
    if root == nil {
        return 0, 0
    }

    left, left_max := getdep(root.Left)
    right, right_max := getdep(root.Right)
    sum := left + right

    if left_max &gt;= sum &amp;&amp; left_max &gt;= right_max  {
        max = left_max
    } else if right_max &gt;= sum &amp;&amp; left_max &lt;= right_max {
        max = right_max
    } else {
        max = sum
    }

    if left &gt; right {
        return left+1, max
    }
    return right+1, max
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/24/mGQCn.jpg" alt></p>
<p>说实话，使用slice实现队列比我想象中的要简单很多，我为每一层的节点单独开辟了一个slice，遍历完这一层之后将队列指针换为下一层的slice即可。</p>
<pre><code class="go">func minDepth(root *TreeNode) int {
    queue := make([]*TreeNode, 0)
    if root == nil {
        return 0
    }

    queue = append(queue, root)
    depth :=  0

    for len(queue) &gt; 0 {
        sonNode := make([]*TreeNode, 0)
        for _, value := range queue{
            if value == nil {
                continue
            }
            if value.Left == value.Right {
                return depth+1
            }
            sonNode = append(sonNode,value.Left)
            sonNode = append(sonNode,value.Right)
        }
        depth++
        queue = sonNode
    }
    return depth
}</code></pre>
<p><img src="https://i.loli.net/2020/02/24/TtqDLrsY67QgPxG.jpg" alt="Jietu20200224-154347@2x"></p>
<pre><code class="go">func sumOfLeftLeaves(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftVal := 0
    if root.Left != nil &amp;&amp; root.Left.Left==nil &amp;&amp; root.Left.Right==nil {
        leftVal = root.Left.Val
    }
    return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) + leftVal
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/24/mGRkA.jpg" alt="Uploading Jietu20200224-174528@2x.jpg… (6ab1cf5zd)"></p>
<p>真的要哭出来了，这个题我的思路一开始就是正确的，递归中odd表示该节点为根的子树奇数层（也就是包含该根结点）的和，意味着其父节点不可以计算在内，even也就是意味着父节点可以计算在内。提交了两次都出问题在even的计算上，even实际上一共有四种可能性，我最后因为没有考虑到两个even的和导致debug一下午（当然,其实我在摸鱼）</p>
<p>这个题看题解中说来，还挺有代表性的，运用了自底向上的动态规划，当然我做的时候没意识到。</p>
<pre><code class="go">func rob(root *TreeNode) int {
    a, b := recursion(root)
    return max(a, b)
}

func recursion(root *TreeNode) (odd, even int) {
    if root == nil {
        return 0, 0
    }

    leftOdd, leftEven := recursion(root.Left)
    rightOdd, rightEven := recursion(root.Right)

    odd = leftEven + rightEven + root.Val

    even = max(leftEven, leftOdd) + max(rightEven, rightOdd)

    return odd, even
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}</code></pre>
<p><img src="https://i.loli.net/2020/02/24/hQV3PMeycOqofgv.jpg" alt="Jietu20200224-191757@2x"></p>
<p>用了广搜，空间换时间。</p>
<pre><code class="go">func findSecondMinimumValue(root *TreeNode) int {
    queue := make([]*TreeNode,0)
    if root == nil {
        return -1
    }
    queue = append(queue, root)
    res, min := -1, root.Val
    for len(queue) &gt; 0 {
        temp := make([]*TreeNode, 0)
        for _, value := range queue {
            if value == nil {
                continue
            }
            if value.Val &gt; min &amp;&amp; (res == -1 || value.Val &lt; res) {
                    res = value.Val
            }
            temp = append(temp, value.Left)
            temp = append(temp, value.Right)
        }
        queue = temp
    }
    return res
}
</code></pre>
<p><img src alt="Uploading Jietu20200302-200839@2x.jpg… (623gq972d)"></p>
<p>层序遍历找到每层最右边的节点。</p>
<pre><code class="go">func rightSideView(root *TreeNode) []int {
    res := make([]int, 0)
    queue := []*TreeNode{root}
    for len(queue) &gt; 0 {
        temp := make([]*TreeNode, 0)
        var right *TreeNode = nil
        for _, v := range queue {
            if v != nil {
                right = v
                temp = append(temp, v.Left)
                temp = append(temp, v.Right)
            }
        }
        if right != nil {
            res = append(res, right.Val)
        }
        queue = temp
    }
    return res
}</code></pre>
<h3 id="二叉树遍历问题"><a href="#二叉树遍历问题" class="headerlink" title="二叉树遍历问题"></a>二叉树遍历问题</h3><p><img src="https://i.loli.net/2020/02/25/FYPdyVCQlgbkEOn.jpg" alt="Jietu20200225-105817@2x"></p>
<p>比较基础的问题，使用迭代法完成先序遍历，一开始没有想出来，看了网上的思想然后通过go写出来。</p>
<p>这里牵涉到的问题主要是go标准库contains/List的使用，在这上面花了很多时间，稍后将其补充在博客里面。</p>
<pre><code class="go">func preorderTraversal(root *TreeNode) []int {
    stack := list.New()
    res := make([]int, 0)
    stack.PushBack(root) //push
    for stack.Len() &gt; 0 {
        cur  := stack.Back()
        curValue, _ := cur.Value.(*TreeNode)
        stack.Remove(cur) // pop
        if curValue != nil {
            res = append(res, curValue.Val)
            stack.PushBack(curValue.Right)
            stack.PushBack(curValue.Left)
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/25/7CxK8kZmtR4Hpae.jpg" alt="Jietu20200225-164150@2x"></p>
<p>这道题挺有意思的，在纸上画了下图后我发现后序遍历就是倒过来的前序遍历，需要注意的是，倒过来包括也要从右节点开始遍历。</p>
<pre><code class="go">func postorderTraversal(root *TreeNode) []int {
    stack := list.New()
    res := make([]int, 0)
    stack.PushBack(root) //push
    for stack.Len() &gt; 0 {
        cur  := stack.Back()
        curValue, _ := cur.Value.(*TreeNode)
        stack.Remove(cur) // pop
        if curValue != nil {
            res = append(res, curValue.Val)
            stack.PushBack(curValue.Left)
            stack.PushBack(curValue.Right)
        }
    }
    resInvert := make([]int, len(res))
    for i := range res {
        resInvert[len(res)-1-i] = res[i]
    }
    return resInvert
}</code></pre>
<p><img src="https://i.loli.net/2020/02/25/k8Xiu5QgdAOTCmc.jpg" alt="Jietu20200225-172308@2x"></p>
<p>脑袋不好使，想了很久才搞出来，其实就是按照中序遍历的过程走完一遍就行了。</p>
<pre><code class="go">func inorderTraversal(root *TreeNode) []int {
    stack := list.New()
    res := make([]int, 0)
    curValue := root
    for stack.Len() &gt; 0 || curValue != nil {

        for curValue != nil {
            stack.PushBack(curValue)
            curValue = curValue.Left
        }
        cur := stack.Back()
        curValue = cur.Value.(*TreeNode)
        stack.Remove(cur) //pop

        res = append(res, curValue.Val)
        curValue = curValue.Right
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/01/2qlsdnv9KWUraTA.jpg" alt="Jietu20200301-145110@2x"></p>
<pre><code class="go">func levelOrder(root *TreeNode) [][]int {
    queue := make([]*TreeNode, 0)
    queue = append(queue, root)
    res := make([][]int, 0)
    for len(queue) &gt; 0 {
        temp := make([]*TreeNode, 0)
        content := make([]int, 0)
        for _, value := range queue {
            if value != nil {
                temp = append(temp, value.Left)
                temp = append(temp, value.Right)
                content = append(content, value.Val)
            }
        }
        queue = temp
        if len(content) &gt; 0 {
            res = append(res, content)
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/26/NjQCAgVWTxbiE1J.jpg" alt="Jietu20200226-171832@2x"></p>
<p>DFS中序遍历，计数达到后剪枝</p>
<pre><code class="go">func kthSmallest(root *TreeNode, k int) int {
    stack := list.New()
    curValue := root
    for curValue != nil || stack.Len() &gt; 0 {
        for curValue != nil {
            stack.PushBack(curValue)
            curValue = curValue.Left
        }
        cur := stack.Back()
        curValue = cur.Value.(*TreeNode)
        stack.Remove(cur)

        k--
        if k == 0 {
            return curValue.Val
        }
        curValue = curValue.Right
    }
    return -1
}</code></pre>
<p><img src="https://i.loli.net/2020/02/26/3xPHA2rj4M9ORny.jpg" alt="Jietu20200226-161328@2x"></p>
<p>题目不难，迷惑的一点是最快的算法和我的代码一模一样，我12ms他4ms。。。</p>
<pre><code class="go">func trimBST(root *TreeNode, L int, R int) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val &gt; R {
        return trimBST(root.Left, L, R)
    }
    if root.Val &lt; L {
        return trimBST(root.Right, L, R)
    }
    root.Left = trimBST(root.Left, L, R)
    root.Right = trimBST(root.Right, L, R)
    return root
}</code></pre>
<p><img src="https://i.loli.net/2020/02/27/auU9RI3DrtZVjq1.jpg" alt="Jietu20200227-101605@2x"></p>
<p>递归解法，判断条件比较重要，当两个字节点或者一个字节点和父节点本身含有目标节点时为结果。</p>
<pre><code class="go">var res *TreeNode
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    helper(root, p, q)
    return res
}

func helper(root, p, q *TreeNode) bool {
    if root == nil {
        return false
    }
    resLeft := helper(root.Left, p, q)
    resRight := helper(root.Right, p, q)
    curBool := root.Val == p.Val || root.Val == q.Val
    if (resLeft &amp;&amp; resRight) || (resLeft &amp;&amp; curBool) || (resRight &amp;&amp; curBool) || (curBool &amp;&amp; (p.Val == q.Val)) {
        res = root
    }
    if root.Val == p.Val || root.Val == q.Val {
        return true
    }
    return resLeft || resRight
}</code></pre>
<h2 id="stack-amp-queue"><a href="#stack-amp-queue" class="headerlink" title="stack &amp; queue"></a>stack &amp; queue</h2><p><img src="https://i.loli.net/2020/02/25/5synrTmzeF9SPJD.jpg" alt="Jietu20200225-224552@2x"></p>
<p>首先我们看到此题应该想到：可以逆向遍历数组来减少重复的遍历次数。这里提供两种做法，第一种就是常规的方法，通过依次比较和累加计算每个位置的索引值。第二种是使用栈，思路见下图（leetcode官方题解）：</p>
<p><img src="https://i.loli.net/2020/02/25/UWafsFPRyNpHuGv.jpg" alt="Jietu20200225-231222@2x"></p>
<pre><code class="go">func dailyTemperatures(T []int) []int {
    res := make([]int, len(T))
    for i := range T {
        address := len(T) - 1 - i
        if i == 0 {
            res[len(T)-1] = 0
            continue
        }
        index := 1
        for T[address+index] &lt;= T[address] {
            index += res[address+index]
            if res[address+index] == 0  {
                if  T[address+index] &lt;= T[address] {
                    index = 0
                }
                break
            }
        }
        res[address] = index
    }
    return res
}

func dailyTemperatures2(T []int) []int {
    res := make([]int, len(T))
    var (
        stack = make([]int, len(T))
        top   = 0
    )
    stack[top], top = len(T)-1, 1
    for i := range T {
        invert := len(T) - i - 1
        for top != 0 &amp;&amp; T[stack[top-1]] &lt;= T[invert] {
            top--
        }
        if top != 0 {
            res[invert] = stack[top-1] - invert
        } else {
            res[invert] = 0
        }
        stack[top], top = invert, top+1
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/28/f3TB4QlWwqcRjov.jpg" alt="Jietu20200228-224922@2x"></p>
<p>用栈就行</p>
<pre><code class="go">func isValid(s string) bool {
    stack := list.New()
    for _, value := range s {
        if stack.Len() == 0 {
            stack.PushBack(byte(value))
            continue
        }
        if value == &#39;(&#39; || value == &#39;{&#39; || value == &#39;[&#39; {
            stack.PushBack(byte(value))
            continue
        }
        prev := stack.Back()
        prevalue := prev.Value.(byte)
        switch value {
            case &#39;}&#39;: 
            if prevalue != &#39;{&#39; {
                return false
            }
            case &#39;)&#39;:
            if prevalue != &#39;(&#39; {
                return false
            }
            case &#39;]&#39;:
            if prevalue != &#39;[&#39; {
                return false
            }
        }
        stack.Remove(prev)
    }
    if stack.Len() != 0 {
        return false
    }
    return true
}</code></pre>
<p><img src="https://i.loli.net/2020/02/27/Q2Ks8mwSLaNE3el.jpg" alt="Jietu20200227-114848@2x"></p>
<p>使用了所谓的分支限界😂</p>
<pre><code class="go">func findTarget(root *TreeNode, k int) bool {
    m := make(map[int]bool)
    queue := make([]*TreeNode, 0)
    queue = append(queue, root)

    for len(queue) &gt; 0 {
        temp := make([]*TreeNode, 0)
        for _, value := range queue {
            if value != nil {
                if m[k-value.Val] {
                    return true
                }
                m[value.Val]=true
                temp = append(temp, value.Left)
                temp = append(temp, value.Right)
            }
        }
        queue = temp
    }
    return false
}</code></pre>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><img src="https://i.loli.net/2020/02/27/KnvqA2WLyeJ7ax1.jpg" alt="Jietu20200227-155255@2x"></p>
<p>有两种做法，本质上是差不多的，更推荐使用第一种双指针，看注释即可。<br>第二种稍微繁琐一点，使用一个slice保存了所有的小于起始高度的，当遇到一个大于该高度的就做计算，到最后将易保存的序列倒置计算即可。</p>
<pre><code class="go">func trap(height []int) int {
    var left, right, leftMax, rightMax, res int
    right = len(height) - 1
    for left &lt; right {
        if height[left] &lt; height[right] {
            if height[left] &gt;= leftMax {
                //设置左边最高柱子
                leftMax = height[left]
            } else {
                //右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池
                res += leftMax - height[left]
            }
            left++
        } else {
            if height[right] &gt; rightMax { 
                //设置右边最高柱子
                rightMax = height[right] 
            } else {
                //左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池
                res += rightMax - height[right] 
            }
            right--
        }
    }
    return res
}

func trap(height []int) int {
    list, rain := make([]int, 0), 0
    list = append(list, 0)
    for _, value := range height {
        list = append(list, value)
        if value &gt;= list[0] {
            if len(list) &gt; 2 {
                rain += calculate(list)
            }
            list = list[len(list)-1:]
        }
    }

    invert := []int{0}
    for i := range list {
        value := list[len(list)-1-i]
        invert = append(invert, value)
        if value &gt;= invert[0] {
            if len(invert) &gt; 2 {
                rain += calculate(invert)
            }
            invert = invert[len(invert)-1:]
        }
    }
    return rain
}

func calculate(height []int) int {
    res := height[0] * (len(height)-2)
    for i:=1; i &lt; len(height)-1; i++ {
        res -= height[i]
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/27/gvKOH1U5TMVh6Pi.jpg" alt="Jietu20200227-163617@2x"></p>
<p>双指针，因为面积是通过较小的高度决定的，所以我们每次移动较小的那个指针。</p>
<pre><code class="go">func maxArea(height []int) int {
    begin, end := 0, len(height)-1
    res := int(math.Min(float64(height[begin]), float64(height[end])))*(end-begin)
    for begin &lt; end {
        if height[begin] &gt; height[end] {
            end--
            temp := int(math.Min(float64(height[begin]), float64(height[end])))*(end-begin)
            res = int(math.Max(float64(temp), float64(res)))
        }else {
            begin++
            temp := int(math.Min(float64(height[begin]), float64(height[end])))*(end-begin)
            res = int(math.Max(float64(temp), float64(res)))
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/27/FnKf3U19GoRP5MX.jpg" alt="Jietu20200227-165035@2x"></p>
<p>双指针很好做的。</p>
<pre><code class="go">func twoSum(numbers []int, target int) []int {
    begin, end := 0, len(numbers)-1
    for begin &lt; end {
        if (numbers[begin] + numbers[end]) &gt; target {
            end--
        } else if (numbers[begin] + numbers[end]) &lt; target {
            begin++
        } else {
            break
        }
    }
    return []int{begin+1, end+1}
}
</code></pre>
<p><img src="https://i.loli.net/2020/02/27/6W7ofH2KhAyFLDQ.jpg" alt="Jietu20200227-182539@2x"></p>
<p>由上一道题得到的灵感，排序+双指针<br>细节问题太重要了。</p>
<pre><code class="go">func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    res := make([][]int, 0)
    if len(nums) &lt; 3 {
        return res
    }
    for i, target := range nums {
        if target &gt; 0 {
            return res
        }
        if  i &gt; 0 &amp;&amp; nums[i]==nums[i-1]{
            continue
        }
        begin, end := i+1, len(nums)-1
        for begin &lt; end {
            if (nums[begin] + nums[end]) &gt; -target {
                end--
            } else if (nums[begin] + nums[end]) &lt; -target {
                begin++
            } else {
                temp := []int{target, nums[begin], nums[end]}
                res = append(res, temp)
                for begin &lt; end &amp;&amp; nums[begin]==nums[begin+1] {
                    begin++
                }
                for begin &lt; end &amp;&amp; nums[end]==nums[end-1] {
                    end--
                }
                begin++
                end--
            }
        }
    }
    return res
}</code></pre>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><img src="https://i.loli.net/2020/02/28/AejVvphG6Q2DHZ1.jpg" alt="Jietu20200228-110008@2x"></p>
<p>⚠️ 据说是字节跳动最常考的一道题。</p>
<p>首先这道题我们应该要想到将问题抽象为一个10叉的字典树，字典树中两个相邻的前缀间有多少个数需要我们使用getcount函数计算</p>
<pre><code class="go">func getcount(prefix, n int) int {
    cur := prefix
    next := prefix+1
    count := 0
    for cur &lt;= n {
        count += int(math.Min(float64(n+1), float64(next)))-cur 
        //防止next大于n，而使用n+1是因为这样算出来的才是实际个数10-13一共有4个，而不等于13-10
        cur *= 10
        next *= 10
    }
    return count
}</code></pre>
<p>至于判断k是否在当前前缀中，只需要看count是否大于k即可，如果大于，就将其往后推一位<br><code>profix *= 10</code><br>如果不在的话就把前缀往后推一位即可<code>prefix++</code></p>
<pre><code class="go">func findKthNumber(n int, k int) int {
    prefix, p := 1, 1
    for p &lt; k {
        count := getcount(prefix, n)
        if p + count &gt; k {
            prefix *= 10
            p++ //算上之前的根节点
        } else {
            prefix++
            p += count
        }
    }
    return prefix
}

func getcount(prefix, n int) int {
    cur := prefix
    next := prefix+1
    count := 0
    for cur &lt;= n {
        count += int(math.Min(float64(n+1), float64(next)))-cur
        cur *= 10
        next *= 10
    }
    return count
}</code></pre>
<h2 id="bytebounce"><a href="#bytebounce" class="headerlink" title="bytebounce"></a>bytebounce</h2><h3 id="好题"><a href="#好题" class="headerlink" title="好题"></a>好题</h3><p><img src="https://i.loli.net/2020/02/28/FylOr5osmB76AHY.jpg" alt="Jietu20200228-141855@2x"></p>
<p>这道题虽然标的是easy，但是属实有点东西的。一开始看到这道题我就觉得可以使用分治算法，后面又觉得动态规划也可以。然后在评论区里看到了下面这个解法，说是叫联机算法，只用遍历一次数组，十分精妙快捷。</p>
<pre><code class="go">func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    sum, max := 0, nums[0]
    for _, value := range nums {
        if sum &lt; 0 {
            sum = 0  //如果前面几个数组元素之和小于零，那么添加上去不增反减，将sum置零重新计算。
        }
        sum += value
        if max &lt; sum {
            max = sum
        }
    }
    return max
}</code></pre>
<p>实际上这个算法就是官方题中的贪心算法。<br>下面给出官方题解中的动态规划算法，该算法对原数组做修改。</p>
<pre><code class="go">func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    max := nums[0]
    for i:=1; i&lt; len(nums); i++ {
        if nums[i-1] &gt; 0 {
            nums[i] += nums[i-1]
        }
        max = int(math.Max(float64(nums[i]), float64(max)))
    }
    return max
}</code></pre>
<p><img src="https://i.loli.net/2020/02/28/HDpiYAxlmtZGOy7.jpg" alt="Jietu20200228-220632@2x"></p>
<p>使用双链表和哈希表实现，哈希表中存储双链表的节点。<br>其中有一个地方有一点小瑕疵，就是在put时对于已经删除的节点不能将哈希表中对应的项删除，只能将其值置为-1，在使用get再次遍历时删除</p>
<pre><code class="go">import (
    &quot;container/list&quot;
)

type LRUCache struct {
    content map[int]*list.Element
    capa int
    queue *list.List
}


func Constructor(capacity int) LRUCache {
    return LRUCache{
        content: make(map[int]*list.Element),
        capa: capacity,
        queue: list.New(),
    }
}


func (this *LRUCache) Get(key int) int {
    if this.content[key] != nil {
        value := this.content[key].Value.(int)
        if  value == -1 {
            delete(this.content, key)
        } else {
            this.queue.MoveToBack(this.content[key])
        }
        return value
    }
    return -1
}


func (this *LRUCache) Put(key int, value int)  {
    if this.content[key] != nil &amp;&amp; this.content[key].Value != -1 {
        this.content[key].Value = value
        this.queue.MoveToBack(this.content[key])
    } else {
        if this.capa &gt; 0 {
            this.capa--
            this.content[key]=this.queue.PushBack(value)
        } else {
            temp := this.queue.Front()
            temp.Value = -1
            this.queue.Remove(temp)
            this.content[key] = this.queue.PushBack(value)
        }
    } 
}</code></pre>
<p><img src="https://i.loli.net/2020/02/28/95SgzQaOjVZkyIf.jpg" alt="Jietu20200228-223038@2x"></p>
<p>后续往前遍历找最大值，其实从前往后用最小值也一样。<br>动态规划问题。</p>
<pre><code class="go">func maxProfit(prices []int) int {
    if len(prices) &lt;= 1 {
        return 0
    }
    res, max := 0, prices[len(prices)-1]
    for i:=len(prices)-2; i&gt;=0; i-- {
        temp := max - prices[i]
        if res &lt; temp {
            res = temp
        }
        if prices[i] &gt; max {
            max = prices[i]
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/02/29/YEM5iAD68mzp3en.jpg" alt="Jietu20200229-152257@2x"></p>
<p>自己猛抠脑壳想出来的办法，最大的优点是只用遍历一次数组，缺点就是看起来就不够优雅😂<br>简单介绍下思路：首先糖果的计算可以看作是一个有序子数组问题，升序和降序的糖果数都是依次递增或者递减的，所以每次迭代时加上序列长度即可。重要的是边界值的考虑，就是一个升序之后是一个更长的降序，这就需要我们对升序序列中最后一个孩子的糖果进行检测，其至少要比降序中的最大值大1.<br>这个题目还有一个特殊的要点在于相等的问题判断，我多次出错都是因为这个，相等是个比较特殊的情况，这个时候我们就不需要满足一定要大的条件，所以在遍历遇到相等时，需要对之前存储的前一个升序的最大值做修改使其不必要再增大</p>
<p>同时介绍一下贪心算法的思路，很简单，左边遍历一次，右边遍历一次，每次都按照规则最优，然后取两次遍历最大值。</p>
<pre><code class="go">func candy(ratings []int) int {
    sum, pre, preSugar, increaselen, decreaselen := 0, -1, 0, 0, 0
    for _, value := range ratings {
        if value &gt; pre &amp;&amp; decreaselen == 0 {
            increaselen++
            sum += increaselen
            pre = value
            preSugar = increaselen
        } else if value &gt; pre &amp;&amp; decreaselen != 0 {
            increaselen, decreaselen = 2, 0
            sum += increaselen
            preSugar = increaselen
            pre = value
        } else if value &lt; pre &amp;&amp; increaselen == 0 {
            decreaselen++
            sum += decreaselen
            if preSugar &lt;= decreaselen {
                sum++
                preSugar++
            }
            pre = value
        } else if value &lt;= pre &amp;&amp; increaselen != 0 {
            increaselen, decreaselen = 0, 1
            sum += decreaselen
            if value == pre {
                preSugar = int(^uint(0) &gt;&gt; 1)
            }
            if preSugar &lt;= decreaselen {
                sum++
                preSugar++
            }
            pre = value
        } else if value == pre &amp;&amp; increaselen == 0 {
            decreaselen = 1
            sum++
            preSugar = int(^uint(0) &gt;&gt; 1)
            pre = value
        }
    }
    return sum
}</code></pre>
<p>贪心算法</p>
<pre><code class="go">// greedy algorithm

func candy(ratings []int) int {
    sum, prev, preSuger := 0, -1, 0
    first := make([]int, len(ratings))
    for i:=0; i&lt;len(ratings); i++ {
        if ratings[i] &gt; prev {
            preSuger++
        } else {
            preSuger=1
        }
        prev = ratings[i]
        first[i]=preSuger
    }
    preSuger, prev = 0, -1
    for i:=len(ratings)-1; i&gt;=0; i-- {
        if ratings[i] &gt; prev {
            preSuger++
        } else {
            preSuger=1
        }
        prev = ratings[i]
        sum += int(math.Max(float64(first[i]), float64(preSuger)))
    }
    return sum
}</code></pre>
<p><img src="https://i.loli.net/2020/03/01/iYgwHaq9CAWy6Or.jpg" alt="Jietu20200301-130735@2x"></p>
<p>可以用快速查找算法，下面给出的是使用container/heap标准库中的接口用小顶堆实现的算法。</p>
<pre><code class="go">type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    // Push and Pop use pointer receivers because they modify the slice&#39;s length,
    // not just its contents.
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func findKthLargest(nums []int, k int) int {
    if len(nums) == 0 {
        return -1
    }
    h := &amp;IntHeap{}
    heap.Init(h)
    for _, value := range nums{
        heap.Push(h, value)
        if h.Len() &gt; k {
            heap.Pop(h)
        }
    }
    return (*h)[0]
}</code></pre>
<p>快速查找算法，感觉我写的可能有点问题，三数取中可能更合理一点</p>
<pre><code class="go">func findKthLargest(nums []int, k int) int {
    if len(nums) == 0 {
        return -1
    }
    for {
        res, addr := quicksort(&amp;nums)
        if addr == k-1 {
            return res
        } else if addr &gt; k-1 {
            nums = nums[:addr]
        } else {
            k -= (addr + 1)
            nums = nums[addr+1:]
        }
    }
    return nums[k-1]
}

func quicksort(nums *[]int) (int, int) {
    if len(*nums) == 1 {
        return (*nums)[0], 0
    }
    length := len(*nums)
    begin, end := 0, length-2
    pivot := (*nums)[length-1]
    for {
        for (*nums)[begin] &gt;= pivot &amp;&amp; begin &lt; length-1 {
            begin++
        }
        for (*nums)[end] &lt; pivot &amp;&amp; begin &lt; end {
            end--
        }
        if begin &lt; end {
            (*nums)[begin], (*nums)[end] = (*nums)[end], (*nums)[begin]
        } else {
            break
        }
    }
    if (*nums)[begin] &lt; (*nums)[length-1] {
        (*nums)[begin], (*nums)[length-1] = (*nums)[length-1], (*nums)[begin]
    }
    return (*nums)[begin], begin
}</code></pre>
<p><img src="https://i.loli.net/2020/03/02/hMlBXTaLpoDbw8j.jpg" alt="Jietu20200302-175101@2x"></p>
<p>数学问题 N=k(2x+k-1)/2，因为k &lt; 2x+k-1所以只需要进行根号N次枚举，同时有<br><code>(N - i * (i - 1) / 2) % i == 0</code><br>关系式成立。</p>
<pre><code class="go">func consecutiveNumbersSum(N int) int {
    res := 1
    for i:=2; i&lt;=int(math.Sqrt(float64(2*N))); i++ {
        if (N - i * (i - 1) / 2) % i == 0 {
            res++
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/01/LRari9KnT6jdesk.jpg" alt="Jietu20200301-172931@2x"></p>
<p>排序后合并</p>
<pre><code class="go">type Interval [][]int

func (inter Interval) Less(i, j int) bool {
    return inter[i][0] &lt; inter[j][0]
}

func (inter Interval) Swap(i, j int) {
    inter[i], inter[j] = inter[j], inter[i]
}

func (inter Interval) Len() int {
    return len(inter)
}

func max(x, y int) int {
    if x &gt; y {
        return x
    }
    return y
}

func merge(intervals [][]int) [][]int {
    sort.Sort(Interval(intervals))
    ans := [][]int{}
    for i := range intervals {
        n := len(ans)
        if n == 0 || intervals[i][0] &gt; ans[n-1][1] {
            ans = append(ans, intervals[i])
        } else {
            ans[n-1][1] = max(ans[n-1][1],intervals[i][1])
        }
    }
    return ans
}</code></pre>
<p><img src="https://i.loli.net/2020/03/02/8KlIOAun5N4kRLo.jpg" alt="Jietu20200302-152050@2x"></p>
<p>我真的垃圾的可以，没看出这其实是斐波那契数列，又或者说是动态规划问题。<br><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/" target="_blank" rel="noopener">官方题解</a>里有两个很牛逼的方法,可以看一看。</p>
<pre><code class="go">func climbStairs(n int) int {
    pre1, pre2, res := 1, 2, 1
    switch n {
        case 1:
            return 1
        case 2: 
            return 2
        default:
            for count:=3;count&lt;=n;count++ {
                res = pre1 + pre2
                pre1, pre2 = pre2, res
            }
            return res
    }
}</code></pre>
<p><img src="https://i.loli.net/2020/03/02/hZDfW3pCcS6LAks.jpg" alt="Jietu20200302-165024@2x"></p>
<p>回溯法，注意append的使用。</p>
<pre><code class="go">//这里声明一个全局变量用来存储所有的排列
var result [][]int 

func permute(nums []int) [][]int {

    //每次调用重置result全局变量，防止结果缓存
    result = make([][]int, 0, 2*len(nums))

    //当nums只有一个元素的情况下，直接返回即可
    if len(nums) == 1 {
        result = append(result, nums)
        return result
    }

    //声明一个arr变量，用来存储路径
    arr := make([]int, 0, len(nums))

    arrange(nums, arr)

    return result
}

func arrange(nums []int, arr []int) {

    //当nums长度为0，选择列表为空，路径选择完毕，返回即可
    if len(nums) == 0 {
        return
    }

    //循环当前的选择列表
    for k, v := range nums {
        arr = append(arr, v)

        newArr := make([]int, len(nums)-1)

        copy(newArr[:k], nums[:k])

        if k &lt; len(nums)-1 {
            copy(newArr[k:], nums[k+1:])
        }
        arrange(newArr, arr)
        if len(arr) == cap(arr) {
            path := make([]int, len(arr))
            copy(path, arr)
            result = append(result, path)
        }
        arr = arr[:len(arr)-1]
    }
}</code></pre>
<p><img src="https://i.loli.net/2020/03/03/m5u4xZRCpzgdcWr.jpg" alt="Jietu20200303-163721@2x"></p>
<p>无脑switch就完事了。</p>
<pre><code class="go">func romanToInt(s string) int {
    tags := make([]bool, 3)
    res := 0 
    for _, v := range s {
        switch v {
            case &#39;I&#39;:
                res += 1
                tags[0] = true
            case &#39;V&#39;:
                if tags[0] {
                    res += 3
                } else {
                    res += 5
                }
                tags = make([]bool, 3)
            case &#39;X&#39;:
                if tags[0] {
                    res += 8
                } else {
                    res += 10
                }
                tags = make([]bool, 3)
                tags[1] = true
            case &#39;L&#39;:
                if tags[1] {
                    res += 30
                } else {
                    res += 50
                }
                tags = make([]bool, 3)
            case &#39;C&#39;:
                if tags[1] {
                    res += 80
                } else {
                    res += 100
                }
                tags = make([]bool, 3)
                tags[2] = true
            case &#39;D&#39;:
                if tags[2] {
                    res += 300
                } else {
                    res += 500
                }
                tags = make([]bool, 3)
            case &#39;M&#39;:
                if tags[2] {
                    res += 800
                } else {
                    res += 1000
                }
                tags = make([]bool, 3)
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/04/nRp2tw8ez3IKhVB.jpg" alt="Jietu20200304-234417@2x"></p>
<p>先对其进行因式分解，若其因子中存在大于10的素数直接返回0<br>之后对因子排序后直接计算，如果大于INTMAX32返回0</p>
<pre><code class="go">func smallestFactorization(a int) int {
    temp := make([]int, 0)
    if a == 1 {
        return 1
    }
    for a &gt; 1 {
        res, factor := helper(a)
        if factor == 0 {
            return 0
        }
        temp = append(temp,factor)
        a = res
    }

    sort.Ints(temp)
    res := 0
    for _, value := range temp {
        res = res *10 + value
    }
    if res &gt; int(math.MaxInt32) {
        res = 0
    }
    return res
}

func helper(a int) (int, int) {
    for i:=9; i&gt;=2; i-- {
        if a % i == 0 {
            return a/i, i
        }
    }
    return a, 0
}</code></pre>
<h2 id="BFS-and-DFS"><a href="#BFS-and-DFS" class="headerlink" title="BFS and DFS"></a>BFS and DFS</h2><p><img src="https://i.loli.net/2020/03/04/BnhZsbS7mRFXfvK.jpg" alt="Jietu20200304-150346@2x"></p>
<p>这种题目一般都使用广度优先搜索,橘子的腐烂过程和bfs按层遍历的情况一样。<br>我们只需要将腐烂的橘子入队即可。</p>
<pre><code class="go">func orangesRotting(grid [][]int) int {
    if len(grid) == 0 {
        return -1
    }
    length, hight, res := len(grid[0])-1, len(grid)-1, 0
    queue := make([]int, 0)
    numsOne := 0
    for i, row := range grid {
        for j, value := range row {
            if value == 2 {
                queue = append(queue, i*10+j)
            }
            if value == 1 {
                numsOne++
            }
        }
    }
    for len(queue) &gt; 0 &amp;&amp; numsOne &gt; 0 {
        temp := make([]int, 0)
        for _, v := range queue {
            i, j := v/10, v%10
            if i&gt;0 &amp;&amp; grid[i-1][j]==1 {
                grid[i-1][j]=2
                temp = append(temp, (i-1)*10+j)
                numsOne--
            }
            if i&lt;hight &amp;&amp; grid[i+1][j]==1 {
                grid[i+1][j]=2
                temp = append(temp, (i+1)*10+j)
                numsOne--
            }
            if j&gt;0 &amp;&amp; grid[i][j-1]==1 {
                grid[i][j-1]=2
                temp = append(temp, i*10+j-1)
                numsOne--
            }
            if j&lt;length &amp;&amp; grid[i][j+1]==1 {
                grid[i][j+1]=2
                temp = append(temp, i*10+j+1)
                numsOne--
            }
        }
        res++
        queue = temp
    }
    if numsOne &gt; 0 {
        return -1
    }
    return res
}</code></pre>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><img src="https://i.loli.net/2020/03/27/bfgJ7am8G9IZx24.jpg" alt="Jietu20200327-190025@2x"></p>
<p>贪心算法连续买入。</p>
<pre><code class="go">func maxProfit(prices []int) int {
    if len(prices) &lt; 2 {
        return 0
    }
    res := 0
    for i:=1; i&lt;len(prices); i++ {
        if prices[i] &gt; prices[i-1] {
            res += (prices[i]-prices[i-1])
        }
    }
    return res
}</code></pre>
<p><img src="https://i.loli.net/2020/03/24/sL4yuWXVIk6m7dA.jpg" alt="Jietu20200324-083636@2x"></p>
<p>其中dp[0]表示没有使用i，dp[i]表示使用了i，剩下的就比较显而易见了。</p>
<pre><code class="go">func massage(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    dp0, dp1 := 0, nums[0]
    for i := 1; i &lt; n; i++ {
        tdp0 := int(math.Max(float64(dp0), float64(dp1)))
        tdp1 := dp0 + nums[i]
        dp0 = tdp0
        dp1 = tdp1
    }
    return int(math.Max(float64(dp0), float64(dp1)))
}</code></pre>
<p><img src="https://i.loli.net/2020/03/24/tBuQdgiJpPonaqK.jpg" alt="Jietu20200324-195316@2x"></p>
<p>难度不大，看代码简单易懂。</p>
<pre><code class="go">func minCost(costs [][]int) int {
    if len(costs) == 0 {
        return 0
    }
    min := func (a, b int) int {
        if a &lt; b {
            return a
        }
        return b
    }
    dp0, dp1, dp2 := costs[0][0], costs[0][1], costs[0][2]
    for i:=1; i&lt;len(costs); i++ {
        dp0, dp1, dp2 = min(dp1, dp2)+costs[i][0], min(dp0，dp2) + costs[i][1], min(dp0, dp1) + costs[i][2]
    }
    return min(min(dp0, dp1), dp2)
}</code></pre>
<p><img src="https://i.loli.net/2020/03/24/OWMLXkYsfQC7AoF.jpg" alt="Jietu20200324-200722@2x"></p>
<p>递推式为<code>dp[i] = min(dp[i-1], dp[i-2]) + cost[i]</code></p>
<pre><code class="go">func minCostClimbingStairs(cost []int) int {
    length := len(cost)
    dp := make([]int, length)
    dp[0], dp[1] = cost[0], cost[1]
    min := func (a, b int) int {
        if a &lt; b {
            return a
        }
        return b
    }
    for i:=2; i&lt;length; i++ {
        dp[i] = min(dp[i-1], dp[i-2]) + cost[i]
    }
    return min(dp[length-1], dp[length-2])
}</code></pre>
<p><img src="https://i.loli.net/2020/03/24/8H2YtrTGZCAK36k.jpg" alt="Jietu20200324-201601@2x"></p>
<p>这个和之前的那个按摩师一样的递推关系。dp0为未使用上一个节点，dp1为使用过上一个节点。</p>
<pre><code class="go">func rob(nums []int) int {
    length := len(nums)
    if length == 0 {
        return 0
    }
    if length == 1 {
        return nums[0]
    }
    dp0, dp1 := nums[0], nums[1]
    max := func (a, b int) int {
        if a &gt; b {
            return a
        }
        return b
    }
    for i:=2; i&lt;length; i++ {
        dp0, dp1 = max(dp0, dp1), dp0+nums[i]
    }
    return max(dp0, dp1)
}</code></pre>
<h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><p><img src="https://i.loli.net/2020/02/20/xcukbpvf4sZdSRA.jpg" alt="Jietu20200220-183400@2x"></p>
<p>此题解法甚屌，我之前并不知道sql可以这样操作。之前看的太笼统，需要重新看一下类型部分。</p>
<pre><code class="sql">UPDATE salary SET sex = CHAR ( ASCII(sex) ^ ASCII( &#39;m&#39; ) ^ ASCII( &#39;f&#39; ) );
# 两箱等数异或为0，0异或任何数为任何数
update salary set sex = char(ascii(&#39;m&#39;) + ascii(&#39;f&#39;) - ascii(&#39;sex&#39;))
# 这个方法更好理解一些</code></pre>
<p><img src="https://i.loli.net/2020/02/20/MFixYWujRsDfIvp.jpg" alt="Jietu20200220-185845@2x"></p>
<p>这个题没啥难的，重要的是我发现sql语句分开写比写成一行更有效率，不知道是不是leetcode的原因。</p>
<pre><code class="sql">select * from cinema 
where description != &quot;boring&quot; 
and id % 2 = 1 
order by rating desc;</code></pre>
<p><img src="https://i.loli.net/2020/02/20/7vfYjog2dxmwH3D.jpg" alt="Jietu20200220-190736@2x"></p>
<p>这个题有点门道，需要group by的使用，通过将其分类然后调用count函数，distinct关键字会使student不能重复。注意笔记中的执行顺序select –&gt;where –&gt; group by–&gt; having–&gt;order by</p>
<pre><code class="sql">select class
from courses
group by class
having count(distinct student) &gt;= 5;</code></pre>
<p><img src="https://i.loli.net/2020/02/20/isAXy6vWo8VPYlx.jpg" alt="Jietu20200220-214303@2x"></p>
<pre><code class="sql">DELETE p1
FROM
    Person p1,
    Person p2
WHERE
    p1.Email = p2.Email
    AND p1.Id &gt; p2.Id

# solution 2
DELETE
FROM
    Person
WHERE
    id NOT IN (
        SELECT id 
        FROM ( 
            SELECT min( id ) AS id 
            FROM Person
            GROUP BY email
        ) AS m
    );</code></pre>
<p><img src="https://i.loli.net/2020/02/20/ExdtpZNjvJH2smS.jpg" alt="Jietu20200220-215513@2x"></p>
<p>因为不管address表中是否含有地址都要进行显示，所以应该使用左外链接。</p>
<pre><code class="sql">select a.FirstName, a.LastName, b.City, b.State
from Person a left join Address b
on a.PersonId = b.PersonId;</code></pre>
<p><img src="https://i.loli.net/2020/02/20/qWrjCe9pKDJkgGV.jpg" alt="Jietu20200220-221009@2x"></p>
<pre><code class="sql">select a.Name as Employee
from Employee a, Employee b
where a.ManagerId = b.Id and a.Salary &gt; b.Salary;

SELECT
    E1.NAME AS Employee
FROM
    Employee E1
    INNER JOIN Employee E2
    ON E1.ManagerId = E2.Id
    AND E1.Salary &gt; E2.Salary;</code></pre>
<p><img src="https://i.loli.net/2020/02/20/zw9TJQHgRfrScDN.jpg" alt="Jietu20200220-221907@2x"></p>
<pre><code class="sql">select Name as Customers
from Customers
where Id not in (
    select CustomerId
    from Orders
)

# left join
SELECT
    C.Name AS Customers
FROM
    Customers C
    LEFT JOIN Orders O
    ON C.Id = O.CustomerId
WHERE
    O.CustomerId IS NULL;</code></pre>
<p><img src="https://i.loli.net/2020/02/20/3UyTJ2OhtmLAE4j.jpg" alt="Jietu20200220-224922@2x"></p>
<p>这个题相对于之前的有一些难度，首先我们应当从Employee表中找出各部门工资最高的人</p>
<pre><code class="sql">select DepartmentId, max(Salary)
from Employee
group by DepartmentId</code></pre>
<p>然后再将两个表连接即可</p>
<pre><code class="sql">SELECT
    Department.name AS &#39;Department&#39;,
    Employee.name AS &#39;Employee&#39;,
    Salary
FROM
    Employee
        JOIN
    Department ON Employee.DepartmentId = Department.Id
WHERE
    (Employee.DepartmentId , Salary) IN
    (   SELECT
            DepartmentId, MAX(Salary)
        FROM
            Employee
        GROUP BY DepartmentId
    ) # 锁定部门最高薪水的人
;</code></pre>
<p><img src="https://i.loli.net/2020/02/21/pS7KWsBgtVH2ADE.jpg" alt="Jietu20200221-123634@2x"></p>
<p>这道题还是有些技巧的，查找第二高的数据，我们可以使用两种方法：一个是使用子查找，首先找出第一高的，然后在查找小于第一高的；第二种是使用limit和offset，对数据做挑选。</p>
<p>这个题的第二个关键点在于没有数据时返回null。<br>⚠️<strong>需要注意的是在sql中空值和null并不相同。</strong><br>这时的处理就需要ifnull函数，ifnull(a, b)，如果a为空值则返回b</p>
<p>这里只写出第二种方法的代码</p>
<pre><code class="sql">select ifnull(
    (select distinct Salary from Eeployee 
    order by Salary desc
    limit 1, 1), null
) as SecondHighestSalary;</code></pre>
<p><img src="https://i.loli.net/2020/02/21/dp786wYMy3vxmcX.jpg" alt="Jietu20200221-142547@2x"></p>
<p>这个题的关键在于构造函数，应当注意的一点在于，首先limit语句中不能计算，所以首先要对输入做处理才行。其次就是工资是不能重复的，所以需要使用distinct语句。</p>
<pre><code class="sql">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT

BEGIN
set N = N -1;
  RETURN (
      # Write your MySQL query statement below.
      select ifnull(
          (
              select distinct Salary
              from Employee
              order by Salary limit N, 1
          ), null
      )
  );
END</code></pre>
<p><img src="https://i.loli.net/2020/02/22/RjGfKZo1xaO5Srz.jpg" alt="Jietu20200222-150155@2x"></p>
<p>首先这个题目不太严谨，没有说明id是唯一的。做法之一是按照id进行计算，从三个表中找到需要的值。</p>
<pre><code class="sql">select distinct l3.Num
from Logs l1, Logs l2, Logs l3
where l1.Id = l2.Id-1 and l2.id = l3.id-1 and l1.num=l2.num and l2.num= l3.num
</code></pre>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>a tour of go</title>
    <url>/blog/2020/02/05/a-tour-of-go/</url>
    <content><![CDATA[<p>Notes about a tour of go.</p>
<a id="more"></a>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>每个Go程序都是由包组成的，程序从main包开始。</p>
<p>所以每个包中的最开始一个语句都应该是package xxx。</p>
<p>下面的程序导入了“fmt”和“math/rand”两个包，按照约定，包名应当与导入路径的最后一个元素一致</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
)

func main() {
    fmt.Println(&quot;a num&quot;,rand.Intn(10))
}
</code></pre>
<p>代码中使用的导入是分组进行的，也可以一个一个导入。</p>
<p>值得注意的是，rand包中的方法Intn是以I开头，go中约定以大写字母开头的是已经导出的，<strong>在导入一个包时，只可以使用已经导出的名字</strong>，未导出的名字不可以在该包外访问</p>
<blockquote>
<p>这应该类似go中的一种封装</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以没有参数（如main函数）或者有多个参数</p>
<pre><code class="go">package main
import &quot;fmt&quot;
func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
</code></pre>
<blockquote>
<p>其函数的声明形式也和rust有些类似，首先就是类型放在后面，返回值的形式也很类似</p>
</blockquote>
<p>如果多个形参的类型相同，可以只写最后一个。</p>
<p>函数可以返回<strong>任意数量</strong>的返回值。</p>
<pre><code class="go">package main
import &quot;fmt&quot;

func swap(x, y string) (string, string ) {
    return y, x
}

func main() {
    a,b := swap(&quot;hello&quot;,&quot;world&quot;)
    fmt.Println(a, b)
}</code></pre>
<p>go的返回值可以命名，会被<em>视作定义在函数顶部的变量</em>，没有参数的return会返回已经命名的返回值</p>
<blockquote>
<p>返回值的命名应当有意义，因为可以作为文档生成。直接返回方式也应当运用在短函数中以防影响可读性</p>
</blockquote>
<pre><code class="go">func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum -x
    return
}</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var语句用于声明一个变量列表，和函数的参数列表一样，类型在最后。<br>var语句可以除像在包或者函数级别。<br>变量声明可以包含初始值，如果初始化值已经存在，可以忽略类型，这点和rust一致</p>
<p><strong>函数中</strong>，简明的赋值语句：=可以在<strong>类型明确</strong>的地方替代var</p>
<p><strong>函数外的每个语句都必须以关键字开始</strong>，因此：=不可以在函数外使用</p>
<p>go的基本类型和大多数语言一致，除了复数complex，除此之外变量声明也可以使用分组成一个语法块</p>
<pre><code class="go">import &quot;math/cmplx&quot;

var (
    Tobe bool = false
    MaxInt uint64 = 1&lt;&lt;64 - 1
    z complex128 = cmplx.Sqrt(-5 + 2i)
)</code></pre>
<p>没有声明初始值的变量会被自动赋为零值，数值类型为0，布尔类型为false，字符串为空字符串</p>
<p><strong>类型转换</strong>：表达式T（v）将值v转换为类型T<br>与C语言不同，Go在不同类型之间赋值必须进行显式的类型转换。</p>
<p>同rust一样，在未生命类型时go会进行对变量的类型推导</p>
<p>简明的声明方式不可以指定变量的类型。</p>
<p>常量的声明与变量类似，只是var语句换成const，而且不可以使用：=<br>一个未指定类型的常量由上下文来决定其类型。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Go只有一种循环结构<strong>for循环</strong></p>
<pre><code class="go">for i := 0; i &lt; 10 ; i++ {
    sum +=i
}</code></pre>
<p>和其他语言可能有所不同，go的循环初始化、条件以及后置的更新语句可以不带括号，但是后面的花括号是必须的。</p>
<blockquote>
<p>初始化和后置语句是可选的</p>
</blockquote>
<pre><code class="go">for ; sum &lt; 1000 ; {
    sum += sum
}</code></pre>
<p>上述的结构中也可以把括号去掉，因为在go中，while叫做for。省略循环条件可以实现无限循环。</p>
<p>if语句和rust中的也一致，即无需小括号大括号是必须的。<br>同for语言一样，if语句可以在条件表达式之前执行一个简单的语句，变量的作用域是if之内</p>
<pre><code class="go">if v := math.Pow(x, n); v &lt; lim {
    return v
}</code></pre>
<h3 id="swich-case"><a href="#swich-case" class="headerlink" title="swich-case"></a>swich-case</h3><p>对于Go而言switch语句整体和c相似，不过Go只运行特定的case而不是之后所有的case，除非以fallthrough语句结束，否则分支会自动停止。</p>
<p>Go的另一个重点在于swith的cace无需为常数而且也不必要取值为整数。</p>
<pre><code class="go">import {
    &quot;fmt&quot;
    &quot;runtime&quot;
}

func main() {
    fmt.Print(:&quot;Go runs on &quot;)
    switch os := runtime.GOOS; os {
        case &quot;darwin&quot;:
            fmt.Println(&quot;macOs&quot;)
        case &quot;linux&quot;:
            fmt.Println(&quot;Linux&quot;)
        default:
            fmt.Println(&quot;%s\n&quot;, os)
    }
}
</code></pre>
<p>switch语句求值顺序为从上到下，没有条件的switch语句和switch true一样，这样可以把if-else语句写的更加美观。</p>
<pre><code class="go">import {
    &quot;fmt&quot;
    &quot;time&quot;
}

func main {
    t := time.Now()
    switch {
        case t.Hour() &lt; 12 :
            fmt.Println(&quot;good morning&quot;)
    }
}</code></pre>
<p><strong>defer</strong>: defer语句会将函数推迟到外层函数返回值执行，defer修饰的函数的参数会立即求值，但是知道外层函数返回时才会被调用。</p>
<p>defer修饰的语句会压入一个栈中，先进后出的形式进行调用</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    defer fmt.Println(&quot;world&quot;)

    fmt.Println(&quot;hello&quot;)
}</code></pre>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go语言拥有指针，指针保存了内存地址。</p>
<p>类型<em>T是一个指向类型T的指针,指针的零值为nil<br>&amp;操作符可以取指针，而</em>操作符可以访问指针指向的值。<br>Go没有指针运算</p>
<pre><code class="go">var t *int
v := 42
p := &amp;v
*p = 20</code></pre>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体（struct）就是一组字段（field）</p>
<p>结构体有两种访问方式</p>
<ol>
<li>点号访问</li>
<li>结构体指针访问，p为指向结构题的指针，则可以使用（*p).x访问其中元素，当然这样写有点麻烦，Go允许隐式的间接引用，即p.x</li>
</ol>
<pre><code class="go">type vertex struct {
    x int
    y int
}

func main() {
    fmt.Println(vertex{1, 2})
    v := Vertex{1, 2}
    p := &amp;v
    p.X = 1e9 //go语言可以使用科学计数法表示数
    fmt.Println(v)
}</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>【n】T表示n个T类型元素的数组，其中数组的长度是固定的<br><code>var array [n]int</code></p>
<p>每个数组的大小都是固定的，go提供slice（切片）来对数组进行动态的访问。</p>
<p>[ ]T表示T类型的切片，切片需要指定上下界来获得对数组的一个半开区间的访问，它包括下界而不包括上界</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    array := [6]{2, 3, 5, 7, 11, 13}
    var s []int = array[1:4]
}</code></pre>
<p>切片并不储存任何数据，他可以看作是数组的引用，当改变切片的值时，底层的数组元素也会被改变。</p>
<p>切片文法类似于没有声明数组长度的数组文法<br><code>[]T {}</code><br>会创建一个数组然后构建一个它的引用，此时该数组是匿名的。</p>
<p>切片的上下界具有默认值，上界默认为数组长度加一，下界为0</p>
<pre><code class="go">var a [10]int

a[0:10]
a[0:]
a[:10]
a[:]
//对于上述数组来说，这些切片是相同的</code></pre>
<p>切片有长度和容量两个属性，切片s的长度和容量可以通过len(s), cap(s)来访问<br>对于一个切片，我们可以通过重新切片来获得拓展其长度。</p>
<pre><code class="go">import &quot;fmt&quot;

func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    printSlice(s)

    // 截取切片使其长度为 0
    s = s[:0]
    printSlice(s)

    // 拓展其长度
    s = s[:4]
    printSlice(s)

    // 舍弃前两个值
    s = s[2:]
    printSlice(s)
}

func printSlice(s []int) {
    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)
}</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxK2o.jpg" alt="result"></p>
<p>切片的零值是nil，零值的切片没有底层数组且长度和容量为0。</p>
<p>切片可以使用内建函数make来实现，这也是创建动态数组的方法。make会创建出一个零值数组然后返回它的切片</p>
<pre><code class="go">var s = make([]int, 5)//len(s)=cap(s)=5

//如果需要指定容量则需要指定第三个参数
var s2 = make([]int, 0, 5)// len(s2)=0, cap(s)=5</code></pre>
<p>切片可以包含任何类型甚至是其他切片。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    // 创建一个井字板（经典游戏）
    board := [][]string{
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
        []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
    }

    // 两个玩家轮流打上 X 和 O
    board[0][0] = &quot;X&quot;
    board[2][2] = &quot;O&quot;
    board[1][2] = &quot;X&quot;
    board[1][0] = &quot;O&quot;
    board[0][2] = &quot;X&quot;

    for i := 0; i &lt; len(board); i++ {
        fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))
    }
}</code></pre>
<p>我们可以使用内建的append指令来使其动态增长，append的第一个参数是切片，之后是需要添加的元素，类似下面的使用方式<br><code>s = append(s, 2, 3, 4)</code></p>
<p>for循环的range形式可以遍历切片或者映射</p>
<pre><code class="go">var pow = []int{0,1,2,3,4,5,6,7}

for i,v := range pow {
    fmt.Println(&quot;value:%d, index:%d&quot;, v, i)
}</code></pre>
<p>range每次返回两个值，第一个是当前的下标，第二个是对应值的副本。可以使用_来忽略某个返回值，如果只需要索引可以省略第二个参数。</p>
<pre><code class="go">for i, _ := range pow
for _, v := range pow

for i := range</code></pre>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxDff.jpg" alt="interest"></p>
<pre><code class="go">package main

import &quot;golang.org/x/tour/pic&quot;

func Pic(dx, dy int) [][]uint8 {
    var result = make([][]uint8, dy)

    //row := make([]uint8, dx)
    for i := range result {
        row := make([]uint8, dx)
        for j := range row {
        row[j] = uint8((i + j) / 2)
        }
        result[i] = row
    }
    return result
}

func main() {
    pic.Show(Pic)
}</code></pre>
<p>注意这里注释掉的部分，如果构造内部slice放在循环体外则会所有的result都指向同一个slice，因为go在这里的等号赋值是浅拷贝，如果使用append就是深拷贝了。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射将键与值进行映射，映射的零值为nil，nil映射既没有键也不能添加键</p>
<p>映射的文法与结构类似不过需要有键名</p>
<pre><code class="go">type Vertex struct {
    x,y int
}

var m = map[string]Vertex {
    &quot;lala&quot; = Vertex{
        2, 3,
    },
    &quot;didi&quot; = Vertex{
        1, 2,
    },
}</code></pre>
<p>注意如果顶级类型只是一个类型名则可以省略</p>
<p>使用make可以初始化映射，然后通过操作来为映射插入或者修改值<br><code>m[key] = value</code></p>
<pre><code class="go">var m = make(map[string]int)

m[&quot;hello&quot;]=1 //insert the key-value
m[&quot;hello&quot;]=2 //modify the ke-value

v = m[&quot;hello&quot;] //get the value of the given key

delete(m, &quot;hello&quot;) //delete the key

v, ok = m[&quot;hello&quot;] // find if the key exist, if it exists, the v will be the value ande ok is a true; if not, the v will be the zero of that type and ok is false</code></pre>
<p><strong>函数也是值，可以用作参数或者返回值</strong>，见下面示例：</p>
<pre><code class="go">func compute(fn func(float64, float64) float64) float64 {
    return fn(3, 4)
}

hypot := func(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
</code></pre>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。他可以访问并赋予其可以引用的变量的值，每个闭包都绑定了自己的变量。</p>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/06/AxEHd.jpg" alt="demo"></p>
<p>使用闭包实现斐波那契数列</p>
<pre><code class="go">package main

import &quot;fmt&quot;

// 返回一个“返回int的函数”
func fibonacci() func() int {
    var num  = [2]int{0,1}
    count := 1
    return func() int {
        if count &lt;= 2 {
            count++
            return num[count-2]
            } else {
            count++
            temp := num[1] + num[0]
            num[0] = num[1]
            num[1] = temp
            return temp
        }
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(f())
    }
}</code></pre>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中没有类，但是可以为结构体定义方法。<br>方法是一类带有特殊的接收者参数的函数，接收者参数位于func关键字与方法名之间。</p>
<pre><code class="go">type Vertex struct {
    x, y int
}

func (v Vertex) Abs() int {
    return v.x + v.y
}</code></pre>
<p>方法就只是一个带接收者参数的函数。</p>
<h3 id="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"><a href="#接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法" class="headerlink" title="接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法"></a>接收者的类型定义必须和方法在同一个包内，不能对于其他包的类型定义方法。不能为内建类型声明方法</h3><p>可以为指针接收者定义方法，这意味着接收者的位置可以使用*T文法。</p>
<p>当使用指针的定义时可以对于接收者的数据进行修改，而如果直接传递接收者值时，只能修改其<strong>副本</strong>。<br>这个结论对于函数也一致，传递类型作为参数时，得到修改的始终是副本，只有指针才能修改类型的值。</p>
<p>而且如果函数的参数是类型指针，则只能使用指针传递。而在方法中，可以使用值进行传递，值在方法中既可以作为指针又可以作为值。<br><strong>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口类型是一组方法签名的组合</p>
<p>接口变量可以保存任何实现了这些方法的类型的值</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Abser interface {
    Abs() float64
}

func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}

    a = f  // a MyFloat 实现了 Abser
    a = &amp;v // a *Vertex 实现了 Abser

    // 下面一行，v 是一个 Vertex（而不是 *Vertex）
    // 所以没有实现 Abser。
    a = &amp;v

    fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</code></pre>
<p>应当注意其中注释的那部分，实现interface abser的是Vertex的指针所以不能使用v而是应当使用&amp;v</p>
<p>实现了一个接口定义的所有方法即为实现了接口，这样就无需使用implements等的显式的定义，这样的隐式定义解耦了接口的定义，接口就可以使用于任何包中无需要提前的准备。</p>
<p>接口也是值，也可以作为参数或者返回值。<br>在内部接口可以认为是值和类型的二元组，（value，type）<br>接口值保存了一个底层类型的具体值，当接口调用方法时，会调用底层类型的相应方法。</p>
<p>有些时候接口值保存的值为nil，这样有时候就需要我们使用一些方式在方法中优雅的解决这种情况<br>保存了nil的接口值并不为nil</p>
<pre><code class="go">type T struct {
    s string
}

type I interface {
    M ()
}

func (t *T) M() {
    if t == nil {
        fmt.Println(&quot;&lt;nil&gt;&quot;)
        return
    } else {
        fmt.Println(t.s)
    }
}</code></pre>
<p>nil的接口值不保存任何具体值和类型，使用nil的接口值会产生一个runtime错误，因为并不知道需要调用哪个类型的底层方法。</p>
<p>没有定义任何方法的接口为空接口，<strong>空接口可以保存任何类型的值，一般用来处理未知类型的值</strong></p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言提供了访问接口底层值的方法。</p>
<p><code>v := i.(T)</code><br>该语句断言接口变量i含有类型T，并试图将T的值赋给v。如果i不含有类型T，这可能会触发一个panic</p>
<p>可以使用与映射类似的方式访问类型断言<br><code>v, ok := i.(T)</code></p>
<p>类型选择，类型选择是一种使用分支结构依次访问断言类型的方式，其结构与switch类似</p>
<pre><code class="go">switch v := i.(type) {
    case T:
    //v的类型为T
    case S：
    //v的类型为S
    default：
    //v的类型与i的接口类型一致
}</code></pre>
<p>fmt包中的Stringer包是最常用的包，它包含了一个解释自己的字符串。</p>
<pre><code class="go">type Stringer interface {
    String() string
}</code></pre>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go使用error来表示错误，同String类似，error也是一个内建的接口</p>
<pre><code class="go">type error interface {
    Error string()
}</code></pre>
<p>fmt包在进行输出的时候也会满足error接口。<br>当使用error时应当注意判断是否为nil，此时表示为成功，否则为失败。</p>
<h2 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h2><p>io包中有一个Reader接口使用比较广泛，可以从数据流的末尾读取数据。</p>
<p>Reader接口有一个read方法，读取数据填充切片并返回一个读取的字节数和一个错误值<br><code>func (T) Read(b []byte) (n int, err error)</code><br>如果读取到文件末尾则返回一个io.EOF错误。</p>
<p>有种常见的模式是使用一个Reader接口包装另一个Reader接口，然后通过某种方法来修改其中数据。</p>
<pre><code class="go">type rot13Reader struct {
    r io.Reader
}
func (reader rot13Reader) Read(b []byte) (int, error) {
    n, err := reader.r.Read(b)
    for i:=0; i&lt;n; i++{
        switch {
        case b[i] &gt;= &#39;A&#39; &amp;&amp; b[i] &lt;&#39;N&#39; :
            b[i] += 13
        case b[i]&gt;=&#39;N&#39; &amp;&amp; b[i] &lt;=&#39;Z&#39;:
            b[i] -=13
        case b[i] &gt;= &#39;a&#39; &amp;&amp; b[i] &lt;&#39;n&#39; :
            b[i] += 13
        case b[i]&gt;=&#39;n&#39; &amp;&amp; b[i] &lt;=&#39;z&#39;:
            b[i] -=13
        }
    }
    return n, err
}
func main() {
    s := strings.NewReader(&quot;Lbh penpxrq gur pbqr!&quot;)
    r := rot13Reader{s}
    io.Copy(os.Stdout, &amp;r)
}</code></pre>
<h2 id="go协程（goroutine）"><a href="#go协程（goroutine）" class="headerlink" title="go协程（goroutine）"></a>go协程（goroutine）</h2><p>goroutine是go运行时管理的轻量级线程。</p>
<p><code>go f(x, y, z)</code><br>会在新的线程中执行f，而对于f、x、y、z的求值则在当前的线程内</p>
<p>goroutine是在同一个地址空间，因此使用共享内存是需要同步，可以使用sync包，也有其他的方式实现同步。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是带有类型的管道，可以通过它来发送或者接收值，信道操作符为&lt;-</p>
<p>和映射切片一样，信道在使用之前必须创建</p>
<pre><code class="go">ch = make(chan int)

v := 2
ch &lt;- v

r := &lt;-ch //&lt;-为数据流动方向</code></pre>
<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func sum(v []int, c chan int) {
    var sum int
    for i := range v {
        sum += v[i]
    }
    ch &lt;- sum
}

func main() {
    value := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(value[:len(value)/2], c)
    go sum(value[len(value)/2:], c)

    x, y := &lt;-c, &lt;-c
    fmt.Println(x, y, x+y)
}</code></pre>
<p>可以通过向make函数添加参数来实现带缓冲区的信道</p>
<p>当传递的内容超过缓冲区大小程序将无法正常执行</p>
<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<p><strong>发送者</strong>可以使用close来关闭一个信道，只有发送者可以关闭，而且如果向关闭了的信道发送消息会导致panic。<br>可以使用for-range循环来不断从信道中读内容，当信道关闭时结束循环。</p>
<p>可以使用两个接收量的传递语句来判断信道是否关闭。<br><code>i, ok := &lt;- ch</code><br>如果ok为false就表明信道已经关闭。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func fabonacci (n int, c chan int) {
    x, y := 0, 1
    for i:=0; i &lt; n; i++ {
        c &lt;- x
        x, y = y, x+y // 值得注意，用这个方式就没必要像之前用的那么麻烦。没必要使用中间变量temp
    }
}

func main() {
    c := make(chan int, 10)
    go fabonacci(cap(c), c)
    for i := range c {
        fmt.Println(i)
    }
}</code></pre>
<h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select 语句使一个 Go 程可以等待多个通信操作。</p>
<p>select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func fabonacci( c, quit chan int) {
    x, y := 0, 1
    select {
        case c &lt;- x:
            x, y = y, x+y
        case &lt;- quit:
            fmt.Println(&quot;quit&quot;)
            return
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)

    go func() {
        for i:=0; i &lt; 10; i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }
    fabonacci()
}</code></pre>
<p>当select的其他分支没有准备好时，default分支就会执行。</p>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>Go标准库中提供的sync.Mutex类型实现了lock和unlock两个方法<br>我们可以使用defer方法将unlock指令推迟来实现互斥。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>博客md图片托管</title>
    <url>/blog/2020/02/05/%E5%8D%9A%E5%AE%A2md%E5%9B%BE%E7%89%87%E6%89%98%E7%AE%A1/</url>
    <content><![CDATA[<p>用github和hexo搭建的博客，有时候markdown里想索引图片，发现博客文件夹中的文件结构和GitHub仓库中的完全不一样，所以难以确定索引路径，之后找到了三种方式：</p>
<a id="more"></a>
<ol>
<li>用github建个仓库专门存放图片</li>
<li>可以在hexo配置文件_config.yml里的post_asset_folder选项设置为true，这样你每次新建一个md文件，就会自动创建一个同名的文件夹用来放资源，索引路径为/assets/文件名</li>
<li>使用图片托管网站，imgur或者别的都行，imgur需要科学上网，我用的是 <a href="https://img.wenhairu.com/" target="_blank" rel="noopener">公众图库</a></li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行与shell脚本编程大全</title>
    <url>/blog/2020/01/28/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>Linux命令行与shell脚本编程大全学习笔记</p>
<a id="more"></a>

<h2 id="基本的shell指令"><a href="#基本的shell指令" class="headerlink" title="基本的shell指令"></a>基本的shell指令</h2><p>tail指令可以检查指令的最后几行，一个有趣的特性是可以使用-f参数，使得其可以在其他进程中使用该指令保持活动状态。<br>用以监视文件的变化</p>
<h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><p><strong>探查进程</strong>：<br>我们一般使用ps指令来探查进程的情况。<br>但是ps实际上十分难以使用，因为它有十分复杂的参数以及多个版本。</p>
<p>ps的缺点之一是只能显示特定时间的进程情况，如果想要实时监测应当使用top指令</p>
<p>如果想结束进程可以使用kill或者killall指令，这两个指令主要是传递信号给进程，进程主要使用信号来传递信息。<br>这两个指令的不同之处为第二个指令不使用进程号而使用进程名来结束所有复合条件的进程。</p>
<p>处理数据文件：<br>sort指令：对于文件进行排序。</p>
<p>grep指令：查找某行数据。egrep, fgrep是类似的版本，功能各有不同</p>
<pre><code class="bash">grep t file1
grep -v t file1 #反向查询
grep -n t file1 #显示行数
grep -c t file1 #-c只返回匹配的行数，而不返回具体行
grep -e t -e f file1 #-e使用多个匹配模式</code></pre>
<p>压缩命令：tar</p>
<p>一行中指定一系列命令，可以通过在每个命令之间加入一个分号实现，但是如果想使用进程列表，则需要在前后加上括号，这样就会产生一个子shell用于执行指令。</p>
<p><code>ps;ls;echo $BASH_SUBSHELL</code><br>最后打印出来的变量值为1，其代表为子shell的层数。</p>
<p>可以使用命令后的一个&amp;号来转入后台运行指令，后台的指令可以使用jobs来查看。</p>
<p>转入后台还可以使用协程执行，即coproc命令，它还可以使用命令的扩展语法指定后台作业的名字。<br><code>coproc My_job { sleep 2; }</code><br>应当注意其中空格都必须存在不能省略。</p>
<h2 id="内建指令"><a href="#内建指令" class="headerlink" title="内建指令"></a>内建指令</h2><p>可以使用type和which找到外部命令的位置。<br>外部命令的执行时，会创建出来一个子进程，这样的过程叫做forking。这样的过程必定要消耗一定的资源。</p>
<p>与之相反的是内建指令就不需要使用子进程来实现，可以使用type指令查看是否为内建指令。</p>
<p>shell也有很多种类型：交互式，非交互式<br>交互式一般指在登陆shell中通过输入bash等指令打开的shell。<br>非交互式一般就是指脚本文件使用的shell。<br>登陆shell会使用/etc/profile文件来设置启动。<br>用户自定义的本地启动文件在用户文件夹下的rc等文件中。</p>
<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>Linux通过用户账户来进行权限的管理。使用UID进行区分。<br>可以在/etc/passwd中看到所有的用户以及相应的UID，其中有很多是为服务提供的账户，并不显示密码，密码另外储存在/etc/shadow文件中，只用特定的程序才能够访问，如登陆程序。</p>
<p>ls命令中，权限展示的第一个指文件类型，后面的每三个字符代表一类用户对于该文件的权限，依次是文件属主权限、属组成员权限、其他用户权限。<br>可以通过umask命令设置默认的文件权限。其中得到的是掩码</p>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h2 id="Linux基本编辑器"><a href="#Linux基本编辑器" class="headerlink" title="Linux基本编辑器"></a>Linux基本编辑器</h2><h2 id="基本shell编程"><a href="#基本shell编程" class="headerlink" title="基本shell编程"></a>基本shell编程</h2><p>命令替换：有两种方式可以从命令中提取信息，并将其赋给变量。</p>
<ol>
<li>反引号字符</li>
<li>$（）格式</li>
</ol>
<p>进行数学计算，可以通过命令替换使用expr指令完成操作，也可以是使用中括号【】。bash中只能使用整数运算，但是zsh（如mac中的shell）可以进行浮点数的相关运算。<br>在bash中进行浮点数运算可以使用bc。其中scale表示小数位数，默认为0</p>
<pre><code class="bash">#！ /bin/bash
var1=`echo &quot;scale=4; 3.44 / 5&quot; | bc`

variable=$(bc &lt;&lt; EOF
options
statements
expressions
EOF )
# 可以使用这样的方式通过重定向完成大量计算过程。
</code></pre>
<h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><p>表示指令执行状态。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>正常退出</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过ctrl+c终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody></table>
<p>一般来讲，shell脚本会以脚本的最后一个命令的退出状态码退出。<br>可以通过exit n指定命令的退出码为n<br>应当注意的是，<strong>退出状态码最大为255</strong></p>
<h2 id="字段分隔符（IFS）"><a href="#字段分隔符（IFS）" class="headerlink" title="字段分隔符（IFS）"></a>字段分隔符（IFS）</h2><p>一般来讲，默认的字段分隔符为空格、制表符、换行符, 可以通过指定IFS来设置分隔符。<br><code>IFS=$&#39;\n&#39;</code></p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>使用getopt解析命令行：<br><code>getopt optstring paramerters</code><br>关键部分在optstring，在其中列出要在脚本中使用的每个命令行选项字母。如果该选项需要参数则使用冒号：。然后getopt就会根据你提供的optstring来解析参数中的命令行参数。可以使用-q来忽略错误消息。</p>
<p>在脚本中使用：</p>
<pre><code class="bash">set -- ${getopt -q ab:cd &quot;$*&quot;}</code></pre>
<p>set指令又一个选项是–，作用是使用参数来代替原本的命令行选项。应当注意的是，getopt并不擅长处理带空格和引号的参数值。</p>
<p><strong>使用更高级的getopts</strong>：<br>命令格式为：<code>getopts optstring variable</code><br>其中optstring和上面的类似，可以在命令行选项前面加上：使得忽视错误信息。<br>和上面的不同，getopts每次只处理一个命令行选项，其使用两个环境变量，一个OPYARG保存选项的参数值，而OPTIND保存参数列表中正在处理的参数的位置。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>可以使用exec命令完成对于文件重定向的实现。<br>该命令可以创建文件描述符，并对其进行相应的重定向操作。<br>将描述符重定向至&amp;-以实现对其的关闭。</p>
<pre><code class="bash">exec 3&gt; test17file
echo &quot;This is a test line of data&quot; &gt;&amp;3
exec 3&gt;&amp;-
</code></pre>
<p>记录消息可以使用tee，该命令类似一个T型通道，将输入分发至指定文件和标准输出。</p>
<ul>
<li><input disabled type="checkbox"> 临时文件</li>
</ul>
<h2 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>脚本可以使用trap命令来捕捉信号，trap的命令格式为：<br><code>trap commands signals</code><br>command位置列出命令，后面跟着需要处理的信号。</p>
<pre><code class="bash">trap &quot;echo Goodbye...&quot; EXIT
# 捕捉退出状态，同样有捕捉ctrl-c的作用。

trap &quot;echo &#39; Sorry! I have trapped the ctrl-c&#39; &quot; SIGINT
# 捕捉ctrl+c信号

trap -- SIGINT
# 删除之前设置的捕捉信号</code></pre>
<h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>只需要在命令后面加一个&amp;即可。<br>可以使用nohup指令将shell脚本和终端分离，其输入输出在hohup文件中</p>
<p>使用bg或者fg命令重启后台的脚本</p>
<p>使用nice和renice来设置命令的优先级，越高优先级越低。</p>
<h3 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h3><p>可以使用at来定时执行文件，而at的输出十分不方便，通过email进行stdout和stderr。</p>
<p>亦可以使用cron时间表来实现。</p>
<h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>函数输出，可以使用echo输出，见实例：</p>
<pre><code class="bash">#! /bin/bash

function func1 {
 read -p &quot;Enter a value: &quot; value
 echo $[ $value * 2 ]
}

result=`func1`
echo &quot;the new value is: $result&quot;</code></pre>
<p>这里有一个值得一提的小技巧，注意这里使用了read的一个选项来进行命令行提示，如果这里使用echo则read读取时会将其一起读取至shell变量中。</p>
<p>参数传递：shell会将函数作为小型的脚本处理，这意味着我们可以使用类似脚本处理参数的方式处理参数</p>
<h3 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h3><p>使用库函数等的关键在于sounce命令，其在当前shell的上下文中执行命令，不会创建新的shell，因此可以使用其中定义的函数。<br>其也有一个简单的别名（alias）称作点操作符</p>
<p>可以在shell中直接定义函数<br>或者将其写入bashrc中每次建立shell都会加载。</p>
<p>使用<strong>shtool库函数</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvfoP.jpg" alt="shtool"></p>
<h2 id="图形化脚本编程"><a href="#图形化脚本编程" class="headerlink" title="图形化脚本编程"></a>图形化脚本编程</h2><p>说起来就是使用文字构建出类似的命令行界面。<br>echo -e允许echo指令输出转义字符。</p>
<p>可以使用select命令比较简单的生成菜单。命令格式如下：</p>
<pre><code class="bash">select variable in list
do
    commands
done
PS3=promt
# 环境变量PS3显示提示。</code></pre>
<p>可以使用dialog包来进行对话框创建。</p>
<p><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvYJh.jpg" alt="dialog"></p>
<h2 id="sed、gawk处理文本"><a href="#sed、gawk处理文本" class="headerlink" title="sed、gawk处理文本"></a>sed、gawk处理文本</h2><p>sed是流文本处理工具，和vim等交互式文本处理不同</p>
<table>
<thead>
<tr>
<th>常用选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>按照脚本执行</td>
</tr>
<tr>
<td>-f</td>
<td>从文件中读取命令</td>
</tr>
<tr>
<td>-n</td>
<td>静默模式，不会输出至stdout</td>
</tr>
</tbody></table>
<h3 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h3><p><code>sed &#39;s/test/trail/&#39; data.txt</code><br>s命令是替换命令，会将data文件中每行默认的第一个test替换为trail。<br>在最后一个斜杠之后还可以加上别的选项</p>
<ol>
<li>数字代表替换第几处</li>
<li>g：表示替换所有匹配的位置</li>
<li>p：同时打印原来的文本</li>
<li>w file：表示输出至file</li>
</ol>
<p>sed中可以使用感叹号作为命令中字符串的分隔符</p>
<p>如果想将命令作用于特定的行中，不针对所有行，则需要使用行寻址。可以使用两种方式：</p>
<p>1.数字方式行寻址</p>
<pre><code class="bash">sed &#39;2s/dog/cat/&#39; data.txt
# 应用于第二行

sed &#39;2,4s/dog/cat/&#39; data.txt
# 2-4

sed &#39;2,$s/dog/cat/&#39; data.txt
# the lines behind No.2
</code></pre>
<p>2.文本方式<br>/pattern/command 按照pattern进行匹配，对匹配成功的行进行操作，其中模式可以使用正则表达式。</p>
<h3 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h3><p>删除命令为d，可以使用上文提到的两种寻址方式来选择删除的行。<br>应当注意模式匹配时需要有开始和结束，不然会出现意外情况。</p>
<h3 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h3><p>插入（i），附加（a），使用寻址来指定操作的行<br>插入会在该行前面，而附加会添加至该行之后。</p>
<h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>修改命令为c，允许修改整行数据 。通上述的命令一样需要指定新的行内容。</p>
<h3 id="转换指令y"><a href="#转换指令y" class="headerlink" title="转换指令y"></a>转换指令y</h3><p>唯一可以操作单个字符的指令。命令格式为：<br><code>[address]y/inchars/outchars/</code></p>
<p>转换指令会对inchars和outchars的值做一对一映射，如果两个字符串的长度不同则会产生一条错误信息。</p>
<p>因此y指令会对文本中所有符合的匹配的数据做映射替换。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>= p两个命令，前者用于打印行号，后者用于打印。同时可以结合-n选项，禁止其他输出，来输出特定匹配选项。</p>
<p>l列出行，可以将不可打印的ascii码等字符打印出来。</p>
<p>r，w：读写指令，可以完成数据流和文件的交互操作。</p>
<h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><p>就目前为止我们学习的sed命令都是只处理数据行的一行，我们可以使用下面三个命令来处理多行数据：</p>
<ol>
<li>N：将数据流中下一行加进来形成一个多行组</li>
<li>D：删除多行组中的一行</li>
<li>P：打印多行组中的一行</li>
</ol>
<p><strong>next命令</strong>：单行模式中使用小写n来表示next命令，单行模式中使用n命令会继续执行之后的命令而不是将命令从头到尾再执行一遍。<br>而多行模式有所不同，它会将下面的一行加入到当前的匹配模式中。</p>
<p><strong>gawk</strong><br>gawk提供一个类编程环境来修改和重新组织文件中的数据<br>gawk是awk的gnu版本，它提供了一种新的编程语言而不是简单的编辑器命令</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-F fs</td>
<td>指定行中的字段分隔符</td>
</tr>
<tr>
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr>
<td>-v var=value</td>
<td>定义一个变量和默认值</td>
</tr>
<tr>
<td>-mf N</td>
<td>定义要处理文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr>
<td>-W keyword</td>
<td>指定兼容模式或者警告等级</td>
</tr>
</tbody></table>
<p>gawk会自动的为文本文件中的数据分配为变量，其中：</p>
<ol>
<li>$0 表示整个文本行</li>
<li>$1 表示第一个数据字段</li>
<li>$n 表示第n个数据字段</li>
</ol>
<p>可以通过BEGIN来指定程序在读取数据前运行脚本内容，类似的也有END</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>一般Linux支持两种正则表达式类型：BRE（基本），ERE（拓展）</p>
<p><strong>锚字符</strong>：默认情况下，正则表达式可以匹配整行的内容，如果想锁定在行首或者行尾匹配，则需要锚字符锁定位置</p>
<p>锁定在行首：^,通过使用该字符可以使其匹配锁定在行首，需要放在模式最前面<br>锁定在行尾：$，需要放在模式的最后面</p>
<p><strong>点号字符</strong>：代表换行符以外任意一个字符。<br><strong>字符组</strong>：中括号将需要匹配的一个数据组放在其中。可以在字符组中使用^符号表示匹配除了字符组给出的字符的模式</p>
<p><strong>特殊字符组：</strong><br><img src="https://cdn.img.wenhairu.com/images/2020/02/03/AvFzu.jpg" alt="特殊字符组示例"></p>
<p><strong>星号</strong>：字符后面放置星号表示该字符出现0次或者多次，可以和字符组组合起来使用</p>
<h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>以下为ERE模式的正则表达式部分，sed只支持BRE而gawk支持大部分ERE因此比sed要慢一些</p>
<p><strong>问号（ ？）</strong>：类似于星号，但是问号只表示出现0或者1次，仅此而已<br><strong>加号（ + ）</strong>：是星号的另一个模式，表示出现一次或者多次，但是至少一次。<br><strong>花括号（{})</strong>：表示允许可重复正则表达式的上限。m为准确出现m次；m，n为至少m次，至多n次<br>默认情况下gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval选项才可以。</p>
<p><strong>管道符号（｜）</strong>：使用or方式指定多个模式<br><strong>表达式分组（（））</strong>：正则表达式模式可以使用圆括号进行分组，该组会被视为一个标准字符，可以一样给该组使用特殊字符。</p>
<h2 id="zsh简介"><a href="#zsh简介" class="headerlink" title="zsh简介"></a>zsh简介</h2><p>zsh是一个开源的shell，其最值得称道的是具有加载命令模块的功能，即可以通过这种方式添加内建指令。</p>
<p>zsh是shell中可定制性最强的，可以通过不同的选项定制需要的shell</p>
<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><p>通过zmodload管理zsh的模块。</p>
<p>没有任何参数的zmodload指令显示已经加载了的模块，如果需要安装则直接在后面跟上模块名，没有任何输出则表示已经加载完成。删除则是使用-u选项。</p>
<blockquote>
<p>通常会将zmodload指令放在zshrc文件中，这样每次打开可以自动加载需要的内容。<br>实测发现加载模块的命令不是一直有效的，退出后则重置所以需要写入zshrc文件中</p>
</blockquote>
<p>可以使用<strong>man zshmodules</strong>命令查看各个模块的内容</p>
<p>zsh提过更加全面的数学操作，其可以使用浮点数运算。<br>有两种方式：let命令或者双圆括号</p>
<ol>
<li><code>let values=&quot; 4 * 1.8 &quot;</code></li>
<li><code>values=$(( 4 * 1.8 ))</code></li>
</ol>
<p>如果一开始没有指定变量的类型，就会导致一些出乎意料的效果。</p>
<pre><code class="bash">value=10
value2=$(( $value / 3 ))
# value2=3

value=10.
value2=$(( $value / 3 ))
# value2=3.33333333</code></pre>
<p>zsh中数学函数可以通过加载mathfunc库实现，加载之后就可以使用整个数学函数库。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>shell的学习到这里就差不多了，这本书我感觉更像是一本工具书，过年期间有些东西看的也不是很细。</p>
<ul>
<li><input disabled type="checkbox"> sed，gawk进阶部分</li>
<li><input disabled type="checkbox"> exec重定向</li>
</ul>
<p>以上的部分没有怎么看，之后有用到在回来看一下。<br>个人认为shell还是得多写，同一个功能在shell中可能有很多的选择可以实现，这本书就作为一本🔧书常备着就好了。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell learning</title>
    <url>/blog/2020/01/23/Shell-learning/</url>
    <content><![CDATA[<h1 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title="shell学习笔记"></a>shell学习笔记</h1><blockquote>
<p><a href="https://www.runoob.com/linux/linux-shell-passing-arguments.html" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>shell本身是用户访问内核的桥梁，所谓的shell学习，实际上是学习shell脚本。</p>
<p>和大多数脚本语言一样，shell只需要一个编辑器和一个解释器就可以了，常见的shell解释器种类众多，有sh、bash、zsh等，我们本次学习bash脚本。</p>
<a id="more"></a>

<p>第一个shell脚本</p>
<pre><code class="bash">#! /bin/bash
echo &quot;hello, world!&quot;</code></pre>
<p>其中第一行告诉系统使用什么解释器来解释shell脚本。</p>
<p>运行shell的方法：</p>
<ol>
<li>作为可执行程序</li>
<li>作为命令解释器的参数</li>
</ol>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>定义变量时不需要加美元符号，如：<br><code>my_name=&quot;lyhhhhh&quot;</code></p>
<p>命名规则：</p>
<ol>
<li>只能使用英文，不能以数字开头</li>
<li>中间不可以有空格，可以使用下划线</li>
<li>不能使用标点</li>
<li>注意不能使用保留关键字</li>
</ol>
<p>使用一个定义过的变量，只需要变量名加美元符号即可，而变量名外面的花括号是可选的，添加是为了方便区分界限。</p>
<pre><code class="bash">my_name=&#39;lyhhhhh&#39;
#the ways below are both valid
echo $my_name
echo ${my_name}
</code></pre>
<p>可以使用readonly命令将变量声明为只读变量<br>也可以使用unset命令将变量删除，之后就无法使用，unset命令不能使用在readonly变量上</p>
<p><strong>变量的类型：</strong></p>
<ol>
<li>局部变量： 局部变量在脚本中定义，只在当前shell实例中有效</li>
<li>环境变量： 属于系统定义的变量，所有的程序和shell都可以访问</li>
<li>shell变量： 是shell程序设置的特殊变量，一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>字符串是shell中最经常使用的类型，实际上在shell中除了字符串和数字也没啥可以用的了。</p>
<p>字符串分为单引号和双引号两种，两者的区别在于单引号字符串的内容即为引号中的内容，如果里面有对变量的引用是无效的。<br>而双引号中可以存在转义字符和变量等可以解释的内容。</p>
<pre><code class="bash">greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;
greeting_3=&#39;hello, ${your_name} !&#39;
echo $greeting_2  $greeting_3
</code></pre>
<p>输出结果为：</p>
<pre><code class="bash">hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !</code></pre>
<p><strong>shell中的字符串存在一些可以使用的操作：</strong></p>
<ol>
<li>获取字符串长度：在字符串前添加#</li>
<li>提取子字符串：${str:begin_index:num} 形如前式，其中beginindex为起始索引（起始为0），num为字符数量。</li>
<li>查找子字符串：见下面例子，注意使用的是反引号而不是单引号</li>
</ol>
<pre><code class="bash">string=&#39;hello, world&#39;
echo ${#string} #output: 4, calculate the length of the string
echo ${string:1:3} #output: ell, substring
echo `exper index &quot;$string&quot; ol`
# 输出o和l在字符串中的位置，那个先出现就输出哪个，注意是反引号而不是单引号。
</code></pre>
<h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>bash支持一维数组而不支持多维数组，类似于c语言，数组元素下标从0开始，可以是表达式，但是需要值合法。</p>
<p>shell中使用括号表示数组，使用空格将数组元素分开。<br>也可以单个定义数组各个元素，下标可以不连续。</p>
<p>获取数组长度与获取字符串长度类似，例如：</p>
<pre><code class="bash">length=${#array[@]}
# get the num of the array
length=${#array[*]}
# same as the way given above

length=${#array[n]}
# get the length of the array[n]
</code></pre>
<h3 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h3><p>单行注释通过#来实现。<br>多行注释可以使用每行都添加#或者</p>
<pre><code class="bash">:&lt;&lt;!
注释内容...
注释内容...
注释内容...
!
</code></pre>
<p>其中！可以被其他标志代替。</p>
<h2 id="shell传递参数"><a href="#shell传递参数" class="headerlink" title="shell传递参数"></a>shell传递参数</h2><p>在执行脚本时我们可以通过命令行为脚本附加参数，调用这些参数的规则如$n，n=0表示的是脚本文件名，1、2、3···以此类推为第一第二个参数</p>
<p>另外还有几个特殊的参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>将所有参数合并到一个字符输出</td>
</tr>
<tr>
<td>$$</td>
<td>脚本当前运行进程的id</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的id</td>
</tr>
<tr>
<td>$@</td>
<td>与第二个类似，不过是以多个字符串组合的形式</td>
</tr>
<tr>
<td>$-</td>
<td>显示shell使用的当前选项，和set命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>现实最后命令的退出状态，0为没有错误</td>
</tr>
</tbody></table>
<p>$*和$@区别：只有在双括号中才能显现出来，例子如下：</p>
<pre><code class="bash">for i in &quot;$*&quot;; do
    echo $i
done

for i in &quot;$@&quot;; do
    echo $i
done
</code></pre>
<p>output:<br>1 2 3</p>
<p>1<br>2<br>3</p>
<h2 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h2><p>shell和其他语言一样支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>后两者比较有趣，后面会详细介绍</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算只能对于数字，不能适用于字符串，除非字符串全部由数字构成。</p>
<p>原生的bash不支持简单的数学运算，需要通过其他的命令来实现，比如awk和expr，其中expr最常用，expr是一款表达式计算工具，可以完成表达式确知操作。</p>
<pre><code class="bash">var=`expr 2 + 2`
echo &quot;the sum of two nums: $var&quot;
</code></pre>
<p>应当注意的是，表达式中的运算符和数字之间应当有空格，这和我们大多数的习惯不同。</p>
<p>常用的算数运算符和C语言类似，即加减乘除、取余等</p>
<p><strong>注意</strong>：乘号前面需要加\转义</p>
<h3 id="shell中-的使用方式"><a href="#shell中-的使用方式" class="headerlink" title="shell中[]的使用方式"></a>shell中[]的使用方式</h3><p><strong>[]在shell中作为测试语句说明</strong><br>比如算术比较、文件属性比较、字符串比较等</p>
<p>使用算术比较举例：</p>
<pre><code class="bash">if [ $a == $b ]
then
    echo &quot;equal&quot;
fi</code></pre>
<p>值得注意的是，【】和比较的元素之间需要使用空格隔开。除了使用==、！=等C语言类似的算术比较之外，我们还可以使用-eq这样的比较运算符。例如，</p>
<pre><code class="bash">if [ $var -eq 0 ]
then
    echo &quot;var=0&quot;
fi

if [ $var1 -eq 0 -a $var2 -gt 1 ]
then
    echo &quot;success&quot;
fi</code></pre>
<p>常用的运算符如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-gt</td>
<td>greater than</td>
</tr>
<tr>
<td>-lt</td>
<td>less than</td>
</tr>
<tr>
<td>-ge</td>
<td>greater and equal</td>
</tr>
<tr>
<td>-lt</td>
<td>less and equal</td>
</tr>
<tr>
<td>-ne</td>
<td>not equal</td>
</tr>
<tr>
<td>-a, -o</td>
<td>and or（用于结合多个判断操作）</td>
</tr>
</tbody></table>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>同c等类似，逻辑运算无非就是 ｜｜ 和 &amp;&amp;<br>需要注意的是，一旦使用逻辑运算，最好使用双中括号，不然可能出现错误，这在字符串运算中也是类似的。</p>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>常用运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>判断运算符是否相等，返回true或者false</td>
</tr>
<tr>
<td>！=</td>
<td>判断运算符是否不等</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0为true</td>
</tr>
<tr>
<td>-n</td>
<td>功能同上，返回值相反。</td>
</tr>
<tr>
<td>$</td>
<td>检测是否为空，不为空则true</td>
</tr>
</tbody></table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>用于测试Unix文件属性</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r、-w、-x</td>
<td>测试文件是否可读可写可执行</td>
</tr>
<tr>
<td>-c、-b</td>
<td>测试是否为字符或者块设备文件</td>
</tr>
<tr>
<td>-d</td>
<td>测试是否为目录</td>
</tr>
<tr>
<td>-e</td>
<td>测试文件（目录）是否存在</td>
</tr>
<tr>
<td>-s</td>
<td>测试是否为空，不为空返回true</td>
</tr>
</tbody></table>
<h2 id="shell中的printf"><a href="#shell中的printf" class="headerlink" title="shell中的printf"></a>shell中的printf</h2><p>和c语言基本一致，除了不需要括号以外，应当注意的是当参数比规格化字符串多时，会按照该格式将多出的参数全部输出</p>
<p><code>printf &quot;%s %s %s\n&quot; a b c d e f g h i j</code></p>
<p>输出为：<br>a b c<br>d e f<br>g h i<br>j</p>
<p>转义字符等和c语言一致</p>
<h2 id="shell-test"><a href="#shell-test" class="headerlink" title="shell test"></a>shell test</h2><p>test指令实际上和上文中提到的[]功能一致</p>
<pre><code class="bash"># they are same
if [ $a == $b ]
if test $a == $b

result=$[a+b]
#the[], is used to calculate the result.
</code></pre>
<p>应当注意后面的情况，此时中括号用于计算结果。</p>
<h2 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h2><p>shell中不能存在没有指令的分支，如果该分支无事可做则不写出来.</p>
<h3 id="if-else分支"><a href="#if-else分支" class="headerlink" title="if-else分支"></a>if-else分支</h3><pre><code class="bash">if condition
then
    command1
    command2
elif condition2
then
    command3
else
    command4
fi

if condition; then command; fi
</code></pre>
<p>上式中两种写法均可。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>shell中提供的for循环是for-in循环<br>变量值存在in列表中，for循环则执行一次所有内容。</p>
<p>shell中还有类似c语言的循环格式，形似下面给出的代码段：</p>
<pre><code class="bash">for((i=1;i&lt;=5;i++));do
    command1;
done</code></pre>
<p>值得注意的是，一般来讲shell中变量的调用是要使用$的，但是在for循环中并不需要。如果对于变量的更改是在函数体中，则需要加美元符号</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code class="bash">while condition
do
    command
done</code></pre>
<pre><code class="bash">int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done

while read FILM
do
    echo &quot;hello, input is: $FILM&quot;
done
</code></pre>
<p>其中使用了shell let指令，用于执行一个或者多个表达式，不需要使用美元符号。</p>
<blockquote>
<p>let 是shell中用于计算的表达式不需要时使用美元符号，如果表达式中存在空格或者其他字符则需要引用起来。</p>
</blockquote>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><pre><code class="bash">case value in
val1)
    command1
    ;;
val2)
    command2
    ;;
*)
    command3
    ;;
esac
</code></pre>
<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>linux shell中可以定义函数，然后在脚本中可以调用。</p>
<p>函数形式如下：</p>
<pre><code class="bash">[ function ] func_name ()
{
    command1

    [ return int; ]
}
</code></pre>
<p>其中【】表示可选项，即函数可以不使用function定义或者没有返回值。<br>函数的返回值可以使用$?调用<br><strong>注意</strong>：由于shell执行顺序是依次执行的，因此函数定义必须在使用之前。而且$?只对上一条指令负责。</p>
<p>函数参数传递形式和shell脚本一样，然后通过美元符号加数字调用。</p>
<p>函数与指令的执行结果可以作为条件语句使用，<strong>要注意的是，和c语言不同该，0在shell中是true，其他为false</strong></p>
<h2 id="shell文件重定向"><a href="#shell文件重定向" class="headerlink" title="shell文件重定向"></a>shell文件重定向</h2><p>重定向指令列表：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将输出重定向之file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向至file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出追加至file</td>
</tr>
<tr>
<td>n &gt; file</td>
<td>将文件描述符为n的文件重定向至file</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td>将文件描述符为n的文件追加到file</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件m和n合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件m与n合并</td>
</tr>
<tr>
<td>&lt;&lt;tag</td>
<td>将开始标记和结束标记之间等我内容作为输入</td>
</tr>
</tbody></table>
<p><code>command1 &lt; infile &gt; outfile</code><br>此命令将命令的输入输出全部替换了</p>
<p><strong>⚠️注意：0通常是标准输入，1是标准输出，2是标准错误输出</strong></p>
<p><code>command &gt; file 2&gt;&amp;1</code><br>可以将stdout和stderr都重定向至file</p>
<p>Here Document<br>是一种特殊的重定向方式，用于将输入重定向到一个交互式脚本或者程序中。<br>基本格式如下：</p>
<pre><code class="bash">command &lt;&lt; tag
    document
tag
</code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>结尾的tag应当顶格写，前后都不能有任何字符</li>
<li>开始的tag前后的空格会被忽略。</li>
</ul>
<p>如果执行某指令不希望有任何输出可以将输出重定向至/dev/null，这是一个特殊文件，重定向至它的所有内容都会被丢弃。</p>
<h2 id="shell外部调用"><a href="#shell外部调用" class="headerlink" title="shell外部调用"></a>shell外部调用</h2><p>shell中也可以包含外部脚本，这样就可以封装一些常用的公用脚本作为独立文件。<br>常用的调用格式如下：</p>
<pre><code class="bash">. filename
# otherwise
source filename
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li>被调用的文件可以不需要可执行权限</li>
<li>path中不包含当前路径则需要写出。/filename</li>
</ol>
<blockquote>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux命令大全</a></p>
</blockquote>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog</title>
    <url>/blog/2020/01/23/My-first-blog/</url>
    <content><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>费了不少功夫才把这个博客搭好</p>
<p>虽然大部分是按照前人走过的路来搞得，但是也需要自己去摸索一些东西</p>
<p>很早就想有这样一个平台来记录自己的学习过程了，想通过这样一点一滴的记录看到自己的成长</p>
<p>这样才有动力去向着996的生活进发，hhhhhhhhhh</p>
<p>加油，奥力给！！！</p>
<a id="more"></a>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
